From 5ac8de674f2a56b30e52a74dafa3bb6ffba5b1cc Mon Sep 17 00:00:00 2001
From: wen <wlin@utias.utoronto.ca>
Date: Tue, 11 Sep 2007 11:31:30 -0400
Subject: not finished yet, soon.

---
 src_2D/CFD/CFD.h                                   |    6 +-
 src_2D/LESPremixed2D/LESPremixed2DInput.cc         |   12 +-
 src_2D/LESPremixed2D/LESPremixed2DInput.h          |   14 +-
 src_2D/LESPremixed2D/LESPremixed2DQuad.h           |  287 +++----
 .../LESPremixed2D/LESPremixed2DQuadMultiBlock.cc   |   12 +-
 .../LESPremixed2D/LESPremixed2DQuadSingleBlock.cc  |  344 +++++---
 src_2D/LESPremixed2D/LESPremixed2DQuadSolvers.cc   |   41 +-
 src_2D/LESPremixed2D/LESPremixed2DState.cc         |  892 +++++++++-----------
 src_2D/LESPremixed2D/LESPremixed2DState.h          |  220 +++---
 src_2D/LESPremixed2D/LESPremixed2DdRdU.cc          |  153 +++-
 src_2D/LESPremixed2D/Scalars.h                     |   36 +-
 src_2D/makefile.def                                |    4 +-
 12 files changed, 1008 insertions(+), 1013 deletions(-)

diff --git a/src_2D/CFD/CFD.h b/src_2D/CFD/CFD.h
index 3ae4e662748d5733593b469ced3c1d3263adf471..266c24722a49c31946a654dfcab3e330b5864391 100644
--- a/src_2D/CFD/CFD.h
+++ b/src_2D/CFD/CFD.h
@@ -361,9 +361,9 @@ inline char *Date_And_Time() {
 #define FLOWTYPE_TURBULENT_LES_NO_MODEL                9
 #define FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY         10
 #define FLOWTYPE_TURBULENT_LES_TF_K                   11
-#define FLOWTYPE_LAMINAR_FSD                          12
-#define FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY        13
-#define FLOWTYPE_TURBULENT_LES_FSD_K                  14
+#define FLOWTYPE_LAMINAR_C_FSD                        12 
+#define FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY      13
+#define FLOWTYPE_TURBULENT_LES_C_FSD_K                14
 #define FLOWTYPE_TURBULENT_DES                        15
 #define FLOWTYPE_TURBULENT_DES_K_OMEGA                16
 #define FLOWTYPE_TURBULENT_DNS                        17
diff --git a/src_2D/LESPremixed2D/LESPremixed2DInput.cc b/src_2D/LESPremixed2D/LESPremixed2DInput.cc
index 2bbcdb5b3627fcb9aea184fdb7ba4fe65420c956..3a8e5401dc43bbc8f4ad3084069d9cd9405314f6 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DInput.cc
+++ b/src_2D/LESPremixed2D/LESPremixed2DInput.cc
@@ -3049,12 +3049,12 @@ int Parse_Next_Input_Control_Parameter(LESPremixed2D_Input_Parameters &IP) {
          IP.FlowType = FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY;
        } else if (strcmp(IP.Flow_Type, "Turbulent-LES-TF-k") == 0) {
          IP.FlowType = FLOWTYPE_TURBULENT_LES_TF_K;
-       } else if (strcmp(IP.Flow_Type, "Laminar-FSD") == 0) {
-         IP.FlowType = FLOWTYPE_LAMINAR_FSD;
-       } else if (strcmp(IP.Flow_Type, "Turbulent-LES-FSD-Smagorinsky") == 0) {
-         IP.FlowType = FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY;
-       } else if (strcmp(IP.Flow_Type, "Turbulent-LES-FSD-k") == 0) {
-         IP.FlowType = FLOWTYPE_TURBULENT_LES_FSD_K;
+       } else if (strcmp(IP.Flow_Type, "Laminar-C-FSD") == 0) {
+         IP.FlowType = FLOWTYPE_LAMINAR_C_FSD;
+       } else if (strcmp(IP.Flow_Type, "Turbulent-LES-C-FSD-Smagorinsky") == 0) {
+         IP.FlowType = FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY;
+       } else if (strcmp(IP.Flow_Type, "Turbulent-LES-C-FSD-K") == 0) {
+         IP.FlowType = FLOWTYPE_TURBULENT_LES_C_FSD_K;
        } else if (strcmp(IP.Flow_Type, "Turbulent-DNS") == 0) {
 	 IP.FlowType = FLOWTYPE_TURBULENT_DNS;
        } else {
diff --git a/src_2D/LESPremixed2D/LESPremixed2DInput.h b/src_2D/LESPremixed2D/LESPremixed2DInput.h
index 20f6ea1cc589d2f246c2f5d26c94fad4ac8c1f86..73002b8a92a5fb1a481c2e2451d6dc08f44b2503 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DInput.h
+++ b/src_2D/LESPremixed2D/LESPremixed2DInput.h
@@ -484,14 +484,12 @@ inline ostream &operator << (ostream &out_file,
       out_file << "\n  -> Spectrum: " << IP.Spectrum_Type;  
     } else if (IP.FlowType == FLOWTYPE_TURBULENT_LES_TF_K) {
       out_file << "\n  -> Turbulent flow: Thickened flame LES with k-equation ";
-    } else if (IP.FlowType == FLOWTYPE_LAMINAR_FSD) {
-      out_file << "\n  -> Laminar flow: flame surface density model ";
-    } else if (IP.FlowType == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY) {    
-      out_file << "\n  -> Turbulent flow: LES with flame surface density model and Smagorinsky model ";
-      out_file << "\n  -> Smagorinsky constant " << IP.Smagorinsky_Constant;
-      out_file << "\n  -> Spectrum: " << IP.Spectrum_Type; 
-    } else if (IP.FlowType == FLOWTYPE_TURBULENT_LES_FSD_K) {
-      out_file << "\n  -> Turbulent flow: LES with flame surface density model and k-equation ";
+    } else if (IP.FlowType == FLOWTYPE_LAMINAR_C_FSD) {
+      out_file << "\n  -> Laminar flow: progress variable and flame surface density ";
+    } else if (IP.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY) {
+      out_file << "\n  -> Turbulent flow: progress variable and flame surface density with Smagorinsky model";
+    } else if (IP.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
+      out_file << "\n  -> Turbulent flow: progress variable, flame surface density with k equation ";
     } else if (IP.FlowType == FLOWTYPE_TURBULENT_DNS) {
       out_file << "\n  -> Turbulent flow: DNS ";
     }
diff --git a/src_2D/LESPremixed2D/LESPremixed2DQuad.h b/src_2D/LESPremixed2D/LESPremixed2DQuad.h
index f008155831e4f499d57fc043f93e5fae4db40166..9c2303b80b685b67b5c438ebe024b0b1639fad59 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DQuad.h
+++ b/src_2D/LESPremixed2D/LESPremixed2DQuad.h
@@ -228,6 +228,12 @@ class LESPremixed2D_Quad_Block{
   LESPremixed2D_pState         **phi;     //!< Solution slope limiter.
   //@}  
 
+  //@{ @name Solution second derivative arrays:
+  LESPremixed2D_pState        **d_dWdx_dx;     //!< (x-direction).
+  LESPremixed2D_pState        **d_dWdx_dy;     //!< (cross-direction).
+  LESPremixed2D_pState        **d_dWdy_dy;     //!< (y-direction).
+  //@}  
+
   //Store face gradients for Diamond Path & Jacobian formation
   LESPremixed2D_pState       **dWdx_faceN;   //!< north cell face(x-direction).
   LESPremixed2D_pState       **dWdx_faceE;   //!< east  cell face(x-direction).
@@ -273,6 +279,7 @@ class LESPremixed2D_Quad_Block{
     dWdx_faceE = NULL; dWdy_faceE = NULL;
     dWdx_faceW = NULL; dWdy_faceW = NULL;
     dWdx_faceS = NULL; dWdy_faceS = NULL;
+    d_dWdx_dx = NULL; d_dWdx_dy = NULL; d_dWdy_dy = NULL;
     phi = NULL;  Uo = NULL; Ut = NULL; Uold = NULL;
     FluxN = NULL; FluxS = NULL; FluxE = NULL; FluxW = NULL;
     WoN = NULL; WoS = NULL; WoE = NULL; WoW = NULL;
@@ -292,6 +299,7 @@ class LESPremixed2D_Quad_Block{
     dWdx_faceE = Soln.dWdx_faceE; dWdy_faceE = Soln.dWdy_faceE;
     dWdx_faceW = Soln.dWdx_faceW; dWdy_faceW = Soln.dWdy_faceW;
     dWdx_faceS = Soln.dWdx_faceS; dWdy_faceS = Soln.dWdy_faceS;
+    d_dWdx_dx = Soln.d_dWdx_dx; d_dWdx_dy = Soln.d_dWdx_dy; d_dWdy_dy = Soln.d_dWdy_dy;  
     phi = Soln.phi; Uo = Soln.Uo; Ut = Soln.Ut; Uold = Soln.Uold; 
     FluxN = Soln.FluxN; FluxS = Soln.FluxS; FluxE = Soln.FluxE; FluxW = Soln.FluxW;
     WoN = Soln.WoN; WoS = Soln.WoS; WoE = Soln.WoE; WoW = Soln.WoW;
@@ -366,19 +374,15 @@ class LESPremixed2D_Quad_Block{
     double Reaction_Rate_Fsd_n(const int &ii, const int &jj);
     double Resolved_Strain_n(const int &ii, const int &jj);
     double Resolved_Propagation_Curvature_n(const int &ii, const int &jj);
-/*     double Resolved_Curvature_n(const int &ii, const int &jj); */
-/*     double Resolved_Propagation_n(const int &ii, const int &jj); */
+    double Resolved_Curvature_n(const int &ii, const int &jj); 
+    double Resolved_Propagation_n(const int &ii, const int &jj); 
     double SFS_Strain_n(const int &ii, const int &jj, const int &Flow_Type);
     double SFS_Curvature_n(const int &ii, const int &jj, const int &Flow_Type);
-/*     double Resolved_Convection_Progvar_n(const int &ii, const int &jj); */
-/*     double Resolved_Convection_Fsd_n(const int &ii, const int &jj); */
-/*     double NGT_Progvar_n(const int &ii, const int &jj); */
-/*     double NGT_Fsd_n(const int &ii, const int &jj); */
-/*     double SFS_Diffusion_Progvar_n(const int &ii, const int &jj, const int &Flow_Type); */
-/*     double SFS_Diffusion_Fsd_n(const int &ii, const int &jj, const int &Flow_Type); */
-/*     double Heat_Release_Strain_n(const int &ii, const int &jj); */
-/*     double Net_Rate_Change_Progvar_n(const int &ii, const int &jj, const int &Flow_Type); */
-/*     double Net_Rate_Change_Fsd_n(const int &ii, const int &jj, const int &Flow_Type); */
+    double Resolved_Convection_Progvar_n(const int &ii, const int &jj); 
+    double Resolved_Convection_Fsd_n(const int &ii, const int &jj); 
+    double NGT_Progvar_n(const int &ii, const int &jj); 
+    double NGT_Fsd_n(const int &ii, const int &jj); 
+    double Heat_Release_Strain_n(const int &ii, const int &jj); 
   
   /* Set flags for limiter evaluation. */
   void evaluate_limiters(void) {Freeze_Limiter = OFF; } 
@@ -510,6 +514,7 @@ inline void LESPremixed2D_Quad_Block::allocate(const int Ni, const int Nj, const
    dWdx_faceE = new LESPremixed2D_pState*[NCi]; dWdy_faceE = new LESPremixed2D_pState*[NCi];
    dWdx_faceW = new LESPremixed2D_pState*[NCi]; dWdy_faceW = new LESPremixed2D_pState*[NCi];
    dWdx_faceS = new LESPremixed2D_pState*[NCi]; dWdy_faceS = new LESPremixed2D_pState*[NCi];
+   d_dWdx_dx = new LESPremixed2D_pState*[NCi]; d_dWdx_dy = new LESPremixed2D_pState*[NCi]; d_dWdy_dy = new LESPremixed2D_pState*[NCi];
    phi = new LESPremixed2D_pState*[NCi]; Uo = new LESPremixed2D_cState*[NCi];
    Ut = new LESPremixed2D_cState*[NCi]; Uold = new LESPremixed2D_cState*[NCi];
    Wall = new Turbulent2DWallData*[NCi];
@@ -528,6 +533,7 @@ inline void LESPremixed2D_Quad_Block::allocate(const int Ni, const int Nj, const
       phi[i] = new LESPremixed2D_pState[NCj]; Uo[i] = new LESPremixed2D_cState[NCj];
       Ut[i] = new LESPremixed2D_cState[NCj]; Uold[i] = new LESPremixed2D_cState[NCj]; 
       Wall[i] = new Turbulent2DWallData[NCj];
+      d_dWdx_dx[i] = new LESPremixed2D_pState[NCj]; d_dWdx_dy[i] = new LESPremixed2D_pState[NCj]; d_dWdy_dy[i] = new LESPremixed2D_pState[NCj];
    } /* endfor */
    FluxN = new LESPremixed2D_cState[NCi]; FluxS = new LESPremixed2D_cState[NCi];
    FluxE = new LESPremixed2D_cState[NCj]; FluxW = new LESPremixed2D_cState[NCj];
@@ -563,6 +569,9 @@ inline void LESPremixed2D_Quad_Block::deallocate(void) {
       delete []dWdx_faceE[i]; dWdx_faceE[i] = NULL; delete []dWdy_faceE[i]; dWdy_faceE[i] = NULL;
       delete []dWdx_faceW[i]; dWdx_faceW[i] = NULL; delete []dWdy_faceW[i]; dWdy_faceW[i] = NULL;
       delete []dWdx_faceS[i]; dWdx_faceS[i] = NULL; delete []dWdy_faceS[i]; dWdy_faceS[i] = NULL;
+      delete []d_dWdx_dx[i]; d_dWdx_dx[i] = NULL; 
+      delete []d_dWdx_dy[i]; d_dWdx_dy[i] = NULL;
+      delete []d_dWdy_dy[i]; d_dWdy_dy[i] = NULL;
       delete []phi[i]; phi[i] = NULL; delete []Uo[i]; Uo[i] = NULL; 
       delete []Ut[i]; Ut[i] = NULL; delete []Uold[i]; Uold[i] = NULL;
       delete []Wall[i]; Wall[i] = NULL; 
@@ -574,6 +583,9 @@ inline void LESPremixed2D_Quad_Block::deallocate(void) {
    delete []dWdx_faceE; dWdx_faceE = NULL; delete []dWdy_faceE; dWdy_faceE = NULL;
    delete []dWdx_faceW; dWdx_faceW = NULL; delete []dWdy_faceW; dWdy_faceW = NULL;
    delete []dWdx_faceS; dWdx_faceS = NULL; delete []dWdy_faceS; dWdy_faceS = NULL;
+   delete []d_dWdx_dx[i]; d_dWdx_dx[i] = NULL; 
+   delete []d_dWdx_dy[i]; d_dWdx_dy[i] = NULL;
+   delete []d_dWdy_dy[i]; d_dWdy_dy[i] = NULL;
 
    delete []phi; phi = NULL; delete []Uo; Uo = NULL;  
    delete []Ut; Ut = NULL; delete []Uold; Uold = NULL;
@@ -801,41 +813,41 @@ inline double LESPremixed2D_Quad_Block::Resolved_Propagation_Curvature_n(const i
 
 }
 
-/* inline double LESPremixed2D_Quad_Block::Resolved_Curvature_n(const int &ii, const int &jj) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
+inline double LESPremixed2D_Quad_Block::Resolved_Curvature_n(const int &ii, const int &jj) {
+  double eta, zeta;
+  eta = ZERO;
+  zeta = ZERO;
   
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
+  BiLinearInterpolationCoefficients(eta, zeta, ii, jj);
       
-/*     double h1, h2, h3, h4; */
+    double h1, h2, h3, h4;
 
-/*     h1 = W[ii-1][jj-1].Resolved_Curvature(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1]); */
-/*     h2 = W[ii-1][jj].Resolved_Curvature(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj]); */
-/*     h3 = W[ii][jj-1].Resolved_Curvature(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1]); */
-/*     h4 = W[ii][jj].Resolved_Curvature(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj]); */
+    h1 = W[ii-1][jj-1].Resolved_Curvature(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1]);
+    h2 = W[ii-1][jj].Resolved_Curvature(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj]);
+    h3 = W[ii][jj-1].Resolved_Curvature(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1]);
+    h4 = W[ii][jj].Resolved_Curvature(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj]);
 
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
+  return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);
 
-/* } */
+}
 
-/* inline double LESPremixed2D_Quad_Block::Resolved_Propagation_n(const int &ii, const int &jj) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
+inline double LESPremixed2D_Quad_Block::Resolved_Propagation_n(const int &ii, const int &jj) {
+  double eta, zeta;
+  eta = ZERO;
+  zeta = ZERO;
   
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
+  BiLinearInterpolationCoefficients(eta, zeta, ii, jj);
       
-/*     double h1, h2, h3, h4; */
+    double h1, h2, h3, h4;
 
-/*     h1 = W[ii-1][jj-1].Resolved_Propagation(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1]); */
-/*     h2 = W[ii-1][jj].Resolved_Propagation(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj]); */
-/*     h3 = W[ii][jj-1].Resolved_Propagation(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1]); */
-/*     h4 = W[ii][jj].Resolved_Propagation(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj]); */
+    h1 = W[ii-1][jj-1].Resolved_Propagation(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1]);
+    h2 = W[ii-1][jj].Resolved_Propagation(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj]);
+    h3 = W[ii][jj-1].Resolved_Propagation(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1]);
+    h4 = W[ii][jj].Resolved_Propagation(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj]);
 
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
+  return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);
 
-/* } */
+}
 
 inline double LESPremixed2D_Quad_Block::SFS_Strain_n(const int &ii, const int &jj, const int &Flow_Type) {
   double eta, zeta;
@@ -873,169 +885,95 @@ inline double LESPremixed2D_Quad_Block::SFS_Curvature_n(const int &ii, const int
 
 }
 
-/* inline double LESPremixed2D_Quad_Block::Resolved_Convection_Progvar_n(const int &ii, const int &jj) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
-  
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
-      
-/*     double h1, h2, h3, h4; */
-
-/*     h1 = W[ii-1][jj-1].Resolved_Convection_Progvar(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1]); */
-/*     h2 = W[ii-1][jj].Resolved_Convection_Progvar(dWdx[ii-1][jj],dWdy[ii-1][jj]); */
-/*     h3 = W[ii][jj-1].Resolved_Convection_Progvar(dWdx[ii][jj-1],dWdy[ii][jj-1]); */
-/*     h4 = W[ii][jj].Resolved_Convection_Progvar(dWdx[ii][jj],dWdy[ii][jj]); */
-
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
-
-/* } */
-
-/* inline double LESPremixed2D_Quad_Block::Resolved_Convection_Fsd_n(const int &ii, const int &jj) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
-  
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
-      
-/*     double h1, h2, h3, h4; */
-
-/*     h1 = W[ii-1][jj-1].Resolved_Convection_Fsd(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1]); */
-/*     h2 = W[ii-1][jj].Resolved_Convection_Fsd(dWdx[ii-1][jj],dWdy[ii-1][jj]); */
-/*     h3 = W[ii][jj-1].Resolved_Convection_Fsd(dWdx[ii][jj-1],dWdy[ii][jj-1]); */
-/*     h4 = W[ii][jj].Resolved_Convection_Fsd(dWdx[ii][jj],dWdy[ii][jj]); */
-
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
-
-/* } */
-
-/* inline double LESPremixed2D_Quad_Block::NGT_Progvar_n(const int &ii, const int &jj) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
-  
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
-      
-/*     double h1, h2, h3, h4; */
-
-/*     h1 = W[ii-1][jj-1].NGT_Progvar(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1]); */
-/*     h2 = W[ii-1][jj].NGT_Progvar(dWdx[ii-1][jj],dWdy[ii-1][jj]); */
-/*     h3 = W[ii][jj-1].NGT_Progvar(dWdx[ii][jj-1],dWdy[ii][jj-1]); */
-/*     h4 = W[ii][jj].NGT_Progvar(dWdx[ii][jj],dWdy[ii][jj]); */
-
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
-
-/* } */
-
-/* inline double LESPremixed2D_Quad_Block::NGT_Fsd_n(const int &ii, const int &jj) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
-  
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
-      
-/*     double h1, h2, h3, h4; */
-
-/*     h1 = W[ii-1][jj-1].NGT_Fsd(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1]); */
-/*     h2 = W[ii-1][jj].NGT_Fsd(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj]); */
-/*     h3 = W[ii][jj-1].NGT_Fsd(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1]); */
-/*     h4 = W[ii][jj].NGT_Fsd(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj]); */
-
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
-
-/* }  */
-
-/* inline double LESPremixed2D_Quad_Block::SFS_Diffusion_Progvar_n(const int &ii, const int &jj, const int &Flow_Type) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
+inline double LESPremixed2D_Quad_Block::Resolved_Convection_Progvar_n(const int &ii, const int &jj) {
+  double eta, zeta;
+  eta = ZERO;
+  zeta = ZERO;
   
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
+  BiLinearInterpolationCoefficients(eta, zeta, ii, jj);
       
-/*     double h1, h2, h3, h4; */
+    double h1, h2, h3, h4;
 
-/*     h1 = W[ii-1][jj-1].SFS_Diffusion_Progvar(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1],Flow_Type); */
-/*     h2 = W[ii-1][jj].SFS_Diffusion_Progvar(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj],Flow_Type); */
-/*     h3 = W[ii][jj-1].SFS_Diffusion_Progvar(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1],Flow_Type); */
-/*     h4 = W[ii][jj].SFS_Diffusion_Progvar(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj],Flow_Type); */
+    h1 = W[ii-1][jj-1].Resolved_Convection_Progvar(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1]);
+    h2 = W[ii-1][jj].Resolved_Convection_Progvar(dWdx[ii-1][jj],dWdy[ii-1][jj]);
+    h3 = W[ii][jj-1].Resolved_Convection_Progvar(dWdx[ii][jj-1],dWdy[ii][jj-1]);
+    h4 = W[ii][jj].Resolved_Convection_Progvar(dWdx[ii][jj],dWdy[ii][jj]);
 
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
+  return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);
 
-/* } */
+}
 
-/* inline double LESPremixed2D_Quad_Block::SFS_Diffusion_Fsd_n(const int &ii, const int &jj, const int &Flow_Type) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
+inline double LESPremixed2D_Quad_Block::Resolved_Convection_Fsd_n(const int &ii, const int &jj) {
+  double eta, zeta;
+  eta = ZERO;
+  zeta = ZERO;
   
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
+  BiLinearInterpolationCoefficients(eta, zeta, ii, jj);
       
-/*     double h1, h2, h3, h4; */
+    double h1, h2, h3, h4;
 
-/*     h1 = W[ii-1][jj-1].SFS_Diffusion_Fsd(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1],Flow_Type); */
-/*     h2 = W[ii-1][jj].SFS_Diffusion_Fsd(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj],Flow_Type); */
-/*     h3 = W[ii][jj-1].SFS_Diffusion_Fsd(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1],Flow_Type); */
-/*     h4 = W[ii][jj].SFS_Diffusion_Fsd(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj],Flow_Type); */
+    h1 = W[ii-1][jj-1].Resolved_Convection_Fsd(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1]);
+    h2 = W[ii-1][jj].Resolved_Convection_Fsd(dWdx[ii-1][jj],dWdy[ii-1][jj]);
+    h3 = W[ii][jj-1].Resolved_Convection_Fsd(dWdx[ii][jj-1],dWdy[ii][jj-1]);
+    h4 = W[ii][jj].Resolved_Convection_Fsd(dWdx[ii][jj],dWdy[ii][jj]);
 
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
+  return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);
 
-/* } */
+}
 
-/* inline double LESPremixed2D_Quad_Block::Heat_Release_Strain_n(const int &ii, const int &jj) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
+inline double LESPremixed2D_Quad_Block::NGT_Progvar_n(const int &ii, const int &jj) {
+  double eta, zeta;
+  eta = ZERO;
+  zeta = ZERO;
   
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
+  BiLinearInterpolationCoefficients(eta, zeta, ii, jj);
       
-/*     double h1, h2, h3, h4; */
+    double h1, h2, h3, h4;
 
-/*     h1 = W[ii-1][jj-1].Heat_Release_Strain(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1]); */
-/*     h2 = W[ii-1][jj].Heat_Release_Strain(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj]); */
-/*     h3 = W[ii][jj-1].Heat_Release_Strain(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1]); */
-/*     h4 = W[ii][jj].Heat_Release_Strain(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj]); */
+    h1 = W[ii-1][jj-1].NGT_Progvar(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1]);
+    h2 = W[ii-1][jj].NGT_Progvar(dWdx[ii-1][jj],dWdy[ii-1][jj]);
+    h3 = W[ii][jj-1].NGT_Progvar(dWdx[ii][jj-1],dWdy[ii][jj-1]);
+    h4 = W[ii][jj].NGT_Progvar(dWdx[ii][jj],dWdy[ii][jj]);
 
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
+  return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);
 
-/* } */
+}
 
-/* inline double LESPremixed2D_Quad_Block::Net_Rate_Change_Progvar_n(const int &ii, const int &jj, const int &Flow_Type) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
+inline double LESPremixed2D_Quad_Block::NGT_Fsd_n(const int &ii, const int &jj) {
+  double eta, zeta;
+  eta = ZERO;
+  zeta = ZERO;
   
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
+  BiLinearInterpolationCoefficients(eta, zeta, ii, jj);
       
-/*     double h1, h2, h3, h4; */
+    double h1, h2, h3, h4;
 
-/*     h1 = W[ii-1][jj-1].Net_Rate_Change_Progvar(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1],Flow_Type); */
-/*     h2 = W[ii-1][jj].Net_Rate_Change_Progvar(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj],Flow_Type); */
-/*     h3 = W[ii][jj-1].Net_Rate_Change_Progvar(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1],Flow_Type); */
-/*     h4 = W[ii][jj].Net_Rate_Change_Progvar(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj],Flow_Type); */
+    h1 = W[ii-1][jj-1].NGT_Fsd(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1]);
+    h2 = W[ii-1][jj].NGT_Fsd(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj]);
+    h3 = W[ii][jj-1].NGT_Fsd(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1]);
+    h4 = W[ii][jj].NGT_Fsd(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj]);
 
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
+  return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);
 
-/* } */
+}
 
-/* inline double LESPremixed2D_Quad_Block::Net_Rate_Change_Fsd_n(const int &ii, const int &jj, const int &Flow_Type) { */
-/*   double eta, zeta; */
-/*   eta = ZERO; */
-/*   zeta = ZERO; */
+inline double LESPremixed2D_Quad_Block::Heat_Release_Strain_n(const int &ii, const int &jj) {
+  double eta, zeta;
+  eta = ZERO;
+  zeta = ZERO;
   
-/*   BiLinearInterpolationCoefficients(eta, zeta, ii, jj); */
+  BiLinearInterpolationCoefficients(eta, zeta, ii, jj);
       
-/*     double h1, h2, h3, h4; */
-
-/*     h1 = W[ii-1][jj-1].Net_Rate_Change_Fsd(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1],Flow_Type); */
-/*     h2 = W[ii-1][jj].Net_Rate_Change_Fsd(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj],Flow_Type); */
-/*     h3 = W[ii][jj-1].Net_Rate_Change_Fsd(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1],Flow_Type); */
-/*     h4 = W[ii][jj].Net_Rate_Change_Fsd(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj],Flow_Type); */
-
-/*   return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);  */
+    double h1, h2, h3, h4;
 
-/* } */
+    h1 = W[ii-1][jj-1].Heat_Release_Strain(dWdx[ii-1][jj-1],dWdy[ii-1][jj-1],d_dWdx_dx[ii-1][jj-1],d_dWdx_dy[ii-1][jj-1],d_dWdy_dy[ii-1][jj-1]);
+    h2 = W[ii-1][jj].Heat_Release_Strain(dWdx[ii-1][jj],dWdy[ii-1][jj],d_dWdx_dx[ii-1][jj],d_dWdx_dy[ii-1][jj],d_dWdy_dy[ii-1][jj]);
+    h3 = W[ii][jj-1].Heat_Release_Strain(dWdx[ii][jj-1],dWdy[ii][jj-1],d_dWdx_dx[ii][jj-1],d_dWdx_dy[ii][jj-1],d_dWdy_dy[ii][jj-1]);
+    h4 = W[ii][jj].Heat_Release_Strain(dWdx[ii][jj],dWdy[ii][jj],d_dWdx_dx[ii][jj],d_dWdx_dy[ii][jj],d_dWdy_dy[ii][jj]);
 
+  return (h1 +(h2- h1)*zeta+ (h3-h1)*eta + (h4+h1-h2-h3)*zeta*eta);
 
+}
 
 /**************************************************************************
  * LESPremixed2D_Quad_Block::Wn -- Node primitive solution.               *
@@ -1366,8 +1304,8 @@ inline istream &operator >> (istream &in_file,
 			     LESPremixed2D_Quad_Block &SolnBlk) {
 
   int i, j, k, ni, il, iu, nj, jl, ju, ng;
-  LESPremixed2D_pState LESPremixed2D_W_VACUUM(ZERO, Vector2D_ZERO, ZERO);
-  LESPremixed2D_cState LESPremixed2D_U_VACUUM(ZERO, Vector2D_ZERO, ZERO);
+  LESPremixed2D_pState LESPremixed2D_W_VACUUM(ZERO, Vector2D_ZERO, ZERO, ZERO);
+  LESPremixed2D_cState LESPremixed2D_U_VACUUM(ZERO, Vector2D_ZERO, ZERO, ZERO);
   Grid2D_Quad_Block New_Grid; in_file >> New_Grid;
   in_file.setf(ios::skipws);
   in_file >> ni >> il >> iu >> ng; in_file >> nj >> jl >> ju;
@@ -1389,7 +1327,9 @@ inline istream &operator >> (istream &in_file,
   Copy_Quad_Block(SolnBlk.Grid, New_Grid); New_Grid.deallocate();
   for ( j  = SolnBlk.JCl-SolnBlk.Nghost ; j <= SolnBlk.JCu+SolnBlk.Nghost ; ++j ) {
      for ( i = SolnBlk.ICl-SolnBlk.Nghost ; i <= SolnBlk.ICu+SolnBlk.Nghost ; ++i ) {
-         in_file >> SolnBlk.U[i][j] >> SolnBlk.Ut[i][j] >> SolnBlk.Uold[i][j];
+         in_file >> SolnBlk.U[i][j] 
+                 >> SolnBlk.Ut[i][j] 
+                 >> SolnBlk.Uold[i][j];
          SolnBlk.W[i][j] = W(SolnBlk.U[i][j]);
 	 SolnBlk.Ut[i][j] = SolnBlk.U[i][j]; 
          for ( k = 0 ; k <= NUMBER_OF_RESIDUAL_VECTORS_LESPREMIXED2D-1 ; ++k ) {
@@ -2752,6 +2692,9 @@ extern void Linear_Reconstruction_GreenGauss_Diamond(LESPremixed2D_Quad_Block &S
 extern double Laplacian_of_Vorticity(LESPremixed2D_Quad_Block &SolnBlk,
                                      const int i,const int j);
 
+extern void Reconstruction_Second_Derivative(LESPremixed2D_Quad_Block &SolnBlk,
+					     const int i,const int j );
+
 extern void Residual_Smoothing(LESPremixed2D_Quad_Block &SolnBlk,
                                const int k_residual,
 			       double &epsilon, 
diff --git a/src_2D/LESPremixed2D/LESPremixed2DQuadMultiBlock.cc b/src_2D/LESPremixed2D/LESPremixed2DQuadMultiBlock.cc
index 9604b703d2d1cafc87ccc7f68736fc6a91bd6b95..a9caaf91d1d4315fa8a46c5a0504bf593541b4a3 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DQuadMultiBlock.cc
+++ b/src_2D/LESPremixed2D/LESPremixed2DQuadMultiBlock.cc
@@ -228,18 +228,20 @@ int Read_Restart_Solution(LESPremixed2D_Quad_Block *Soln_ptr,
                                                            Input_Parameters.Wo.adiabatic_temp,
                                                            Input_Parameters.Wo.equivalence_ratio,
                                                            Input_Parameters.Wo.reactants_den);
+	  Input_Parameters.Uo = U(Input_Parameters.Wo);
 
-	  
 	  //Reset  Wo species mass fractions
           Input_Parameters.Wo.set_initial_values(Input_Parameters.mass_fractions);  
+	  
           // Update Uo from Wo
           Input_Parameters.Uo = U(Input_Parameters.Wo);
 
+
           /********* Turbulent Premixed Reacting Flow ***********************************/
           if (Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
 	      Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_K ||
-              Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-	      Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_K) {
+              Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+	      Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
             restart_file.setf(ios::skipws); 
             restart_file >> Input_Parameters.Fresh_Fuel_Mass_Fraction
                          >> Input_Parameters.Burnt_Fuel_Mass_Fraction
@@ -361,8 +363,8 @@ int Write_Restart_Solution(LESPremixed2D_Quad_Block *Soln_ptr,
           /********* Turbulent Premixed Reacting Flow ***********************************/
           if (Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
 	     Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_K ||
-              Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-	      Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_K) {
+              Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+	      Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
             restart_file << Input_Parameters.Fresh_Fuel_Mass_Fraction << " "
                          << Input_Parameters.Burnt_Fuel_Mass_Fraction << " "
                          << Input_Parameters.Fresh_Density << endl;
diff --git a/src_2D/LESPremixed2D/LESPremixed2DQuadSingleBlock.cc b/src_2D/LESPremixed2D/LESPremixed2DQuadSingleBlock.cc
index 84e740ccb693a56fd7474e523f8108a482933c7a..8cba51f227a14a8f2ef477b62f03aceff2417ba7 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DQuadSingleBlock.cc
+++ b/src_2D/LESPremixed2D/LESPremixed2DQuadSingleBlock.cc
@@ -63,7 +63,7 @@ void Broadcast_Solution_Block(LESPremixed2D_Quad_Block &SolnBlk) {
     double *buffer;
 
     int NUM_VAR_LESPREMIXED2D = SolnBlk.NumVar(); 
-
+    cout<<"nn_broad=    "<<NUM_VAR_LESPREMIXED2D<<endl;
     /* Broadcast the number of cells in each direction. */
     if (CFFC_Primary_MPI_Processor()) {
       ni = SolnBlk.NCi;
@@ -269,6 +269,7 @@ void Broadcast_Solution_Block(LESPremixed2D_Quad_Block &SolnBlk,
   double *buffer;
 
   int NUM_VAR_LESPREMIXED2D = SolnBlk.NumVar();
+    cout<<"nn_broad2=    "<<NUM_VAR_LESPREMIXED2D<<endl;
 
   /* Broadcast the number of cells in each direction. */
 
@@ -1141,6 +1142,12 @@ void Output_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
     }
   }
    
+    for (int j  = SolnBlk.JCl; j <= SolnBlk.JCu; ++j ) {
+      for (int i = SolnBlk.ICl; i <= SolnBlk.ICu; ++i ) {
+         Reconstruction_Second_Derivative(SolnBlk,i,j);	 
+      }
+    }
+
   /* Cell centered shear and qflux */
   if (SolnBlk.Flow_Type != FLOWTYPE_INVISCID) {
     Viscous_Calculations(SolnBlk);
@@ -1210,9 +1217,9 @@ void Output_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
     Out_File << "\"k_sfs\" \\ \n"
 	     << "\"vorticity\" \\ \n"
 	     << "\"enstrophy\" \\ \n";
-     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
      Out_File <<"\"FSD\" \\ \n"
               <<"\"Reaction Rate\" \\ \n"
               <<"\"FSD Total Source\" \\ \n"
@@ -1220,19 +1227,15 @@ void Output_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
               <<"\"M_y\" \\ \n"
               <<"\"Resolved Strain\" \\ \n"
               <<"\"Resolved Propagation_Curvature\" \\ \n"
-//               <<"\"Resolved Propagation\" \\ \n"
-//               <<"\"Resolved Curvature\" \\ \n"
+              <<"\"Resolved Propagation\" \\ \n"
+              <<"\"Resolved Curvature\" \\ \n"
               <<"\"SFS Strain\" \\ \n"
-              <<"\"SFS Curvature\" \\ \n";
-//               <<"\"Resolved_Convection_Progvar\" \\ \n"
-//               <<"\"Resolved_Convection_Fsd\" \\ \n"
-//               <<"\"NGT_Progvar\" \\ \n"
-//               <<"\"NGT_Fsd\" \\ \n"
-//               <<"\"SFS Diffusion_Progvar\" \\ \n"
-//               <<"\"SFS Diffusion_Fsd\" \\ \n"
-//               <<"\"Heat_Release_Strain\" \\ \n"
-//               <<"\"Net_Rate_Change_Progvar\" \\ \n"
-//               <<"\"Net_Rate_Change_Fsd\" \\ \n"
+              <<"\"SFS Curvature\" \\ \n"
+              <<"\"Resolved_Convection_Progvar\" \\ \n"
+              <<"\"Resolved_Convection_Fsd\" \\ \n"
+              <<"\"NGT_Progvar\" \\ \n"
+              <<"\"NGT_Fsd\" \\ \n"
+              <<"\"Heat_Release_Strain\" \\ \n";
     }
       // Zone details
    Out_File << "ZONE T =  \"Block Number = " << Block_Number
@@ -1271,9 +1274,9 @@ void Output_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
       Out_File << " " << W_node.k() 
 	       << " " << SolnBlk.vorticity_n(i, j)
 	       << " " << SolnBlk.enstrophy_n(i, j); 
-     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
        Out_File<< " " << W_node.scalar[1]*W_node.rho
                << " " << SolnBlk.Reaction_Rate_Fsd_n(i,j)
                << " " << W_node.S_turbulence_model( SolnBlk.dWdx[i][j],
@@ -1285,19 +1288,15 @@ void Output_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
 	       << " " << SolnBlk.M_y_n(i,j)
                << " " << SolnBlk.Resolved_Strain_n(i,j)
 	       << " " << SolnBlk.Resolved_Propagation_Curvature_n(i,j)
-// 	       << " " << SolnBlk.Resolved_Propagation_n(i,j)
-// 	       << " " << SolnBlk.Resolved_Curvature_n(i,j)
+ 	       << " " << SolnBlk.Resolved_Propagation_n(i,j)
+ 	       << " " << SolnBlk.Resolved_Curvature_n(i,j)
 	       << " " << SolnBlk.SFS_Strain_n(i,j,SolnBlk.Flow_Type)
-	       << " " << SolnBlk.SFS_Curvature_n(i,j,SolnBlk.Flow_Type);
-// 	       << " " << SolnBlk.Resolved_Convection_Progvar_n(i,j)
-// 	       << " " << SolnBlk.Resolved_Convection_Fsd_n(i,j)
-// 	       << " " << SolnBlk.NGT_Progvar_n(i,j)
-// 	       << " " << SolnBlk.NGT_Fsd_n(i,j)
-//  	       << " " << SolnBlk.SFS_Diffusion_Progvar_n(i,j,SolnBlk.Flow_Type)
-//  	       << " " << SolnBlk.SFS_Diffusion_Fsd_n(i,j,SolnBlk.Flow_Type)
-// 	       << " " << SolnBlk.Heat_Release_Strain_n(i,j)
-//  	       << " " << SolnBlk.Net_Rate_Change_Progvar_n(i,j,SolnBlk.Flow_Type)
-//  	       << " " << SolnBlk.Net_Rate_Change_Fsd_n(i,j,SolnBlk.Flow_Type);
+	       << " " << SolnBlk.SFS_Curvature_n(i,j,SolnBlk.Flow_Type)
+ 	       << " " << SolnBlk.Resolved_Convection_Progvar_n(i,j)
+ 	       << " " << SolnBlk.Resolved_Convection_Fsd_n(i,j)
+ 	       << " " << SolnBlk.NGT_Progvar_n(i,j)
+ 	       << " " << SolnBlk.NGT_Fsd_n(i,j)
+ 	       << " " << SolnBlk.Heat_Release_Strain_n(i,j);
     }
   
       Out_File.unsetf(ios::scientific);
@@ -1328,6 +1327,12 @@ void Output_Cells_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
 
     int i, j;
 
+    for (int j  = SolnBlk.JCl; j <= SolnBlk.JCu; ++j ) {
+      for (int i = SolnBlk.ICl; i <= SolnBlk.ICu; ++i ) {
+         Reconstruction_Second_Derivative(SolnBlk,i,j);	 
+      }
+    }
+
     /* Cell centered shear and qflux */
     if (SolnBlk.Flow_Type != FLOWTYPE_INVISCID) {
       Viscous_Calculations(SolnBlk);
@@ -1412,9 +1417,9 @@ void Output_Cells_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
                 << "\"vorticity\" \\ \n"
                 << "\"enstrophy\" \\ \n"
                 << "\"laplacian_vort\" \\ \n";
-     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
       Out_File<<"\"FSD\" \\ \n"
               <<"\"Reaction Rate\" \\ \n"
               <<"\"FSD Total Source\" \\ \n"
@@ -1422,19 +1427,15 @@ void Output_Cells_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
               <<"\"M_y\" \\ \n"
               <<"\"Resolved Strain\" \\ \n"
               <<"\"Resolved Propagation\" \\ \n"
-//               <<"\"Total_Resolved Propagation\" \\ \n"
-//               <<"\"Total_Resolved Curvature\" \\ \n"
+              <<"\"Total_Resolved Propagation\" \\ \n"
+              <<"\"Total_Resolved Curvature\" \\ \n"
               <<"\"SFS Strain\" \\ \n"
-              <<"\"SFS Curvature\" \\ \n";
-//               <<"\"Resolved_Convection_Progvar\" \\ \n"
-//               <<"\"Resolved_Convection_Fsd\" \\ \n"
-//               <<"\"NGT_Progvar\" \\ \n"
-//               <<"\"NGT_Fsd\" \\ \n"
-//               <<"\"SFS Diffusion_Progvar\" \\ \n"
-//               <<"\"SFS Diffusion_Fsd\" \\ \n"
-//               <<"\"Heat_Release_Strain\" \\ \n"
-//               <<"\"Net_Rate_Change_Progvar\" \\ \n"
-//               <<"\"Net_Rate_Change_Fsd\" \\ \n";
+              <<"\"SFS Curvature\" \\ \n"
+              <<"\"Resolved_Convection_Progvar\" \\ \n"
+              <<"\"Resolved_Convection_Fsd\" \\ \n"
+              <<"\"NGT_Progvar\" \\ \n"
+              <<"\"NGT_Fsd\" \\ \n"
+              <<"\"Heat_Release_Strain\" \\ \n";
      }
 
                    
@@ -1519,9 +1520,9 @@ void Output_Cells_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
 	            << " " << SolnBlk.vorticity(i, j)
                     << " " << SolnBlk.enstrophy(i, j) 
 	            << " " << Laplacian_of_Vorticity(SolnBlk, i, j);
-     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
        Out_File<< " " << SolnBlk.W[i][j].scalar[1]*SolnBlk.W[i][j].rho
                << " " << SolnBlk.W[i][j].Reaction_Rate_Fsd(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
 	       << " " << SolnBlk.W[i][j].S_turbulence_model(SolnBlk.dWdx[i][j],
@@ -1533,19 +1534,15 @@ void Output_Cells_Tecplot(LESPremixed2D_Quad_Block &SolnBlk,
 	       << " " << SolnBlk.W[i][j].M_y(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
 	       << " " << SolnBlk.W[i][j].Resolved_Strain(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
 	       << " " << SolnBlk.W[i][j].Resolved_Propagation_Curvature(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
-// 	       << " " << SolnBlk.W[i][j].Resolved_Propagation(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j])
-// 	       << " " << SolnBlk.W[i][j].Resolved_Curvature(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j])
+ 	       << " " << SolnBlk.W[i][j].Resolved_Propagation(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j])
+ 	       << " " << SolnBlk.W[i][j].Resolved_Curvature(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j])
 	       << " " << SolnBlk.W[i][j].SFS_Strain(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.Flow_Type)
-	       << " " << SolnBlk.W[i][j].SFS_Curvature(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.Flow_Type);
-// 	       << " " << SolnBlk.W[i][j].Resolved_Convection_Progvar(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
-// 	       << " " << SolnBlk.W[i][j].Resolved_Convection_Fsd(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
-// 	       << " " << SolnBlk.W[i][j].NGT_Progvar(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
-// 	       << " " << SolnBlk.W[i][j].NGT_Fsd(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j])
-//  	       << " " << SolnBlk.W[i][j].SFS_Diffusion_Progvar(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j],SolnBlk.Flow_Type)
-//  	       << " " << SolnBlk.W[i][j].SFS_Diffusion_Fsd(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j],SolnBlk.Flow_Type)
-// 	       << " " << SolnBlk.W[i][j].Heat_Release_Strain(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j])
-//  	       << " " << SolnBlk.W[i][j].Net_Rate_Change_Progvar(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j],SolnBlk.Flow_Type)
-//  	       << " " << SolnBlk.W[i][j].Net_Rate_Change_Fsd(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j],SolnBlk.Flow_Type);
+	       << " " << SolnBlk.W[i][j].SFS_Curvature(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.Flow_Type)
+ 	       << " " << SolnBlk.W[i][j].Resolved_Convection_Progvar(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
+ 	       << " " << SolnBlk.W[i][j].Resolved_Convection_Fsd(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
+ 	       << " " << SolnBlk.W[i][j].NGT_Progvar(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j])
+ 	       << " " << SolnBlk.W[i][j].NGT_Fsd(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j])
+ 	       << " " << SolnBlk.W[i][j].Heat_Release_Strain(SolnBlk.dWdx[i][j],SolnBlk.dWdy[i][j],SolnBlk.d_dWdx_dx[i][j],SolnBlk.d_dWdx_dy[i][j],SolnBlk.d_dWdy_dy[i][j]);
        }
 	 
 //	   //limiters
@@ -2285,14 +2282,13 @@ void ICs(LESPremixed2D_Quad_Block &SolnBlk,
       // Set Initial condtions on 1D grid
       for (int j  = SolnBlk.JCl-SolnBlk.Nghost ; j <= SolnBlk.JCu+SolnBlk.Nghost ; ++j ) {
 	for ( int i = SolnBlk.ICl-SolnBlk.Nghost ; i <= SolnBlk.ICu+SolnBlk.Nghost ; ++i ) {
+         if ( SolnBlk.Flow_Type != FLOWTYPE_LAMINAR_C_FSD ) {
 	  if (SolnBlk.Grid.Cell[i][j].Xc.x <= 0.01){ //spatial relation, grid independent 
 	    SolnBlk.W[i][j] = Wl;  
 	  } else {
  	    SolnBlk.W[i][j] = Wr;	     
  	  } /* end if */
-     if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+	 }else{
             double xx = SolnBlk.Grid.Cell[i][j].Xc.x-0.01;
 	    double tau_fsd = SolnBlk.W[i][j].HeatRelease_Parameter();
        	  SolnBlk.W[i][j].scalar[0] = (erf(xx*4000.0)+1.0)/2.0;
@@ -2301,10 +2297,7 @@ void ICs(LESPremixed2D_Quad_Block &SolnBlk,
        	  SolnBlk.W[i][j].rho = SolnBlk.W[i][j].reactants_den*SolnBlk.W[2][j].Rtot()/SolnBlk.W[i][j].Rtot()/(1.0+tau_fsd*SolnBlk.W[i][j].scalar[0]);
        	  SolnBlk.W[i][j].v.x = SolnBlk.W[i][j].reactants_den*SolnBlk.W[i][j].laminar_speed/SolnBlk.W[i][j].rho;
        	  SolnBlk.W[i][j].scalar[1] = 4000.0*exp(-sqr(xx*4000.0))/sqrt(3.1415926)/SolnBlk.W[i][j].rho;
-  	  if (  SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
-  	    SolnBlk.W[i][j].scalar[2] = SolnBlk.W[i][j].k();
-	  }
-     }
+	 }
 	  SolnBlk.U[i][j] = U(SolnBlk.W[i][j]);
 	} 
       } 
@@ -2855,7 +2848,15 @@ void ICs(LESPremixed2D_Quad_Block &SolnBlk,
 	    SolnBlk.W[i][j].v.x += uprime_x;
 	    SolnBlk.W[i][j].v.y += uprime_y;
 	  }
-
+  if (  SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
+      Linear_Reconstruction_LeastSquares_2(SolnBlk, i, j, LIMITER_VENKATAKRISHNAN);
+      Tensor2D strain_rate = SolnBlk.W[i][j].Strain_Rate(SolnBlk.dWdx[i][j], 
+							 SolnBlk.dWdy[i][j], 
+							 SolnBlk.Flow_Type, 
+							 SolnBlk.Axisymmetric, 
+							 SolnBlk.Grid.Cell[i][j].Xc);  
+      SolnBlk.W[i][j].scalar[2] = SolnBlk.W[i][j].SFSmodel.sfs_k_Yoshizawa(strain_rate,SolnBlk.W[i][j].filter_width);
+  }
 #ifdef THICKENED_FLAME_ON
 	  SolnBlk.W[i][j].flame.unphysical_check(SolnBlk.W[i][j].TFactor);
 	  if (SolnBlk.W[i][j].flame.TF < (ONE-NANO)  || 
@@ -2865,8 +2866,9 @@ void ICs(LESPremixed2D_Quad_Block &SolnBlk,
 #endif
 	  // Update U from W
 	  SolnBlk.U[i][j] = U(SolnBlk.W[i][j]);
-	}
       }
+  }
+
       InFile.unsetf(ios::skipws);
       InFile.close();
 
@@ -2977,7 +2979,7 @@ void ICs(LESPremixed2D_Quad_Block &SolnBlk,
 
 
 // 	    // Initialize the turbulence kinetic energy k
-// 	    // if (SolnBlk.W[i][j].Scal_sys.scalar_flag == LES_TF_K  ||  SolnBlk.W[i][j].Scal_sys.scalar_flag == LES_FSD_C_K) {
+// 	    // if (SolnBlk.W[i][j].Scal_sys.scalar_flag == LES_TF_K  ||  SolnBlk.W[i][j].Scal_sys.scalar_flag == LES_C_FSD_C_K) {
 // // 	      double dudx, dudy, dvdx, dvdy, SS, trace;
 // // 	      dudx = (SolnBlk.W[i+1][j].v.x - SolnBlk.W[i-1][j].v.x)/
 // // 		(SolnBlk.Grid.Cell[i+1][j].Xc.x - SolnBlk.Grid.Cell[i-1][j].Xc.x);
@@ -4259,15 +4261,14 @@ double CFL(LESPremixed2D_Quad_Block &SolnBlk,
 	  rhomu = SolnBlk.W[i][j].mu()/SolnBlk.W[i][j].rho;
 	  if(SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY || 
 	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K || 
-	     SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD || 
-	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY || 
-	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
+	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY || 
+	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
 	    Tensor2D strain_rate;
 	    strain_rate = SolnBlk.W[i][j].Strain_Rate(SolnBlk.dWdx[i][j], SolnBlk.dWdy[i][j], 
 						      SolnBlk.Flow_Type, SolnBlk.Axisymmetric, 
 						      SolnBlk.Grid.Cell[i][j].Xc);  
 	    
-	    rhomut = SolnBlk.W[i][j].mu_t(strain_rate)/SolnBlk.W[i][j].rho; 
+	    rhomut = SolnBlk.W[i][j].mu_t(strain_rate,SolnBlk.Flow_Type)/SolnBlk.W[i][j].rho; 
 	    rhomu = max(rhomu, rhomut);
 	  }
 	  
@@ -4277,42 +4278,43 @@ double CFL(LESPremixed2D_Quad_Block &SolnBlk,
 	
 	/******** Chemical Source Term deltat calculation ************/   
 	if (SolnBlk.W[i][j].React.reactset_flag != NO_REACTIONS &&
-	     SolnBlk.Flow_Type != FLOWTYPE_LAMINAR_FSD && 
-	     SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY && 
-	     SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_FSD_K ){
+	     SolnBlk.Flow_Type != FLOWTYPE_LAMINAR_C_FSD && 
+	     SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY && 
+	     SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_C_FSD_K ){
 	  dt_chem = HALF/SolnBlk.W[i][j].dSwdU_max_diagonal(Input_Parameters.Preconditioning,
 							    SolnBlk.Flow_Type,
 							    delta_n,Input_Parameters.Solver_Type); 
 	  SolnBlk.dt[i][j] = min(dt_chem, SolnBlk.dt[i][j]);	  
 	}
 	
-	if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD || 
-	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY || 
-	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
-	
-	     int nn = SolnBlk.NumVar() - SolnBlk.W[0][0].ns;
-             DenseMatrix dSdU(nn,nn);
-             dSdU.zero();
+	if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD || 
+	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY || 
+	     SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
+  	     int NN = SolnBlk.NumVar() - SolnBlk.W[0][0].ns;
+             DenseMatrix dSdW(NN,NN);
+             dSdW.zero();
              double max_diagonal = ONE;
-	     SemiImplicitBlockJacobi(dSdU,SolnBlk,EXPLICIT,i, j);
+             SemiImplicitBlockJacobi_dSdW(dSdW,SolnBlk,EXPLICIT,i, j);
+
              if(Input_Parameters.Preconditioning == 1){
- 	      DenseMatrix Pinv(nn,nn);
+ 	      DenseMatrix Pinv(NN,NN);
  	      Pinv.zero();
  	      SolnBlk.U[i][j].Low_Mach_Number_Preconditioner_Inverse(Pinv,
    		  			           	             SolnBlk.Flow_Type,
  				 			             delta_n);	 
- 	      dSdU = Pinv*dSdU;
+ 	      dSdW = Pinv*dSdW;
            
              }
-             for(int ii=0; ii<nn; ii++){
-              max_diagonal = max(max_diagonal,fabs(dSdU(ii,ii)));
+	     
+             for(int ii=0; ii<NN; ii++){
+              max_diagonal = max(max_diagonal,fabs(dSdW(ii,ii)));
              }
 
  	       SolnBlk.dt[i][j] = min(HALF/max_diagonal, SolnBlk.dt[i][j]);
 	       //	       cout<<"\nFsd=   "<<SolnBlk.dt[i][j]<<endl;
 	       //	       if ( SolnBlk.dt[i][j] < 1.0e-08 ) { SolnBlk.dt[i][j] = 1.0e-08; }
  	     }
-
+	
 	/************ Global Minimum ********************************/
 	dtMin = min(dtMin, SolnBlk.dt[i][j]);
 	
@@ -6770,6 +6772,84 @@ double Laplacian_of_Vorticity(LESPremixed2D_Quad_Block &SolnBlk,
   return laplacian;
 }
 
+ void Reconstruction_Second_Derivative(LESPremixed2D_Quad_Block &SolnBlk,
+                                       const int i,const int j ) {
+   double DX, DY;
+
+	  if (i == SolnBlk.ICu || j == SolnBlk.JCu) {
+	    //BFW
+	  DX = SolnBlk.Grid.Cell[i][j].Xc.x - SolnBlk.Grid.Cell[i-1][j].Xc.x;
+	  DY = SolnBlk.Grid.Cell[i][j].Xc.y - SolnBlk.Grid.Cell[i][j-1].Xc.y;
+	  SolnBlk.d_dWdx_dx[i][j] = ( SolnBlk.dWdx[i][j] - SolnBlk.dWdx[i-1][j] )/ DX;
+	  SolnBlk.d_dWdx_dy[i][j] = ( SolnBlk.dWdx[i][j] - SolnBlk.dWdx[i][j-1] )/ DY;
+	  SolnBlk.d_dWdy_dy[i][j] = ( SolnBlk.dWdy[i][j] - SolnBlk.dWdy[i][j-1] )/ DY;
+
+	  }else if (i == SolnBlk.ICl || j == SolnBlk.JCl){
+	    //FFW
+	  DX = SolnBlk.Grid.Cell[i+1][j].Xc.x - SolnBlk.Grid.Cell[i][j].Xc.x;
+	  DY = SolnBlk.Grid.Cell[i][j+1].Xc.y - SolnBlk.Grid.Cell[i][j].Xc.y;
+	  SolnBlk.d_dWdx_dx[i][j] = ( SolnBlk.dWdx[i+1][j] - SolnBlk.dWdx[i][j] )/ DX;
+	  SolnBlk.d_dWdx_dy[i][j] = ( SolnBlk.dWdx[i][j+1] - SolnBlk.dWdx[i][j] )/ DY;
+	  SolnBlk.d_dWdy_dy[i][j] = ( SolnBlk.dWdy[i][j+1] - SolnBlk.dWdy[i][j] )/ DY;
+
+	  }else{
+
+	  DX = SolnBlk.Grid.Cell[i+1][j].Xc.x - SolnBlk.Grid.Cell[i-1][j].Xc.x;
+	  DY = SolnBlk.Grid.Cell[i][j+1].Xc.y - SolnBlk.Grid.Cell[i][j-1].Xc.y;
+	  SolnBlk.d_dWdx_dx[i][j] = ( SolnBlk.dWdx[i+1][j] - SolnBlk.dWdx[i-1][j] )/ DX;
+	  SolnBlk.d_dWdx_dy[i][j] = ( SolnBlk.dWdx[i][j+1] - SolnBlk.dWdx[i][j-1] )/ DY;
+	  SolnBlk.d_dWdy_dy[i][j] = ( SolnBlk.dWdy[i][j+1] - SolnBlk.dWdy[i][j-1] )/ DY;
+
+	  }
+
+//   Vector2D  n_north, n_south, n_east, n_west;
+//   double l_north, l_south, l_east, l_west;
+//   double dCdx_N, dCdx_S, dCdx_E, dCdx_W;
+//   double dCdy_N, dCdy_S, dCdy_E, dCdy_W;
+
+//   l_north = SolnBlk.Grid.lfaceN(i, j);
+//   l_south = SolnBlk.Grid.lfaceS(i, j);
+//   l_east = SolnBlk.Grid.lfaceE(i, j);
+//   l_west = SolnBlk.Grid.lfaceW(i, j);
+
+//   n_north = SolnBlk.Grid.nfaceN(i, j);
+//   n_south = SolnBlk.Grid.nfaceS(i, j);
+//   n_east = SolnBlk.Grid.nfaceE(i, j);
+//   n_west = SolnBlk.Grid.nfaceW(i, j);
+
+//   dCdx_N = SolnBlk.dWdx_faceN[i][j].scalar[0];
+//   dCdx_S = SolnBlk.dWdx_faceS[i][j].scalar[0];
+//   dCdx_E = SolnBlk.dWdx_faceE[i][j].scalar[0];
+//   dCdx_W = SolnBlk.dWdx_faceW[i][j].scalar[0];  
+
+//   dCdy_N = SolnBlk.dWdy_faceN[i][j].scalar[0];
+//   dCdy_S = SolnBlk.dWdy_faceS[i][j].scalar[0];
+//   dCdy_E = SolnBlk.dWdy_faceE[i][j].scalar[0];
+//   dCdy_W = SolnBlk.dWdy_faceW[i][j].scalar[0];
+
+//   /* North face of the cell */
+//   SolnBlk.d_dWdx_dx[i][j] = l_north*dCdx_N*n_north.x 
+//   SolnBlk.d_dWdy_dy[i][j] = l_north*dCdy_N*n_north.y; 
+
+//   /* West face of the cell */
+//   SolnBlk.d_dWdx_dx[i][j] += l_west*dCdx_W*n_west.x;
+//   SolnBlk.d_dWdy_dy[i][j] += l_west*dCdy_W*n_west.y;
+
+//   /* South face of the cell */
+//   SolnBlk.d_dWdx_dx[i][j] += l_south*dCdx_S*n_south.x;
+//   SolnBlk.d_dWdy_dy[i][j] += l_south*dCdy_S*n_south.y;
+
+//   /* East face of the cell */
+//   SolnBlk.d_dWdx_dx[i][j] += l_east*dCdx_E*n_east.x; 
+//   SolnBlk.d_dWdy_dy[i][j] += l_east*dCdy_E*n_east.y;
+
+
+//   /* Componentes of the average laplacian of the velocity 
+//      in the cell (i,j) */
+//   SolnBlk.d_dWdx_dx[i][j] = SolnBlk.d_dWdx_dx[i][j]/SolnBlk.Grid.Cell[i][j].A;
+//   SolnBlk.d_dWdy_dy[i][j] = SolnBlk.d_dWdy_dy[i][j]/SolnBlk.Grid.Cell[i][j].A;
+
+ }
 
 /********************************************************
  * Routine: Residual_Smoothing                          *
@@ -6990,8 +7070,8 @@ void Calculate_Refinement_Criteria(double *refinement_criteria,
 	     grad_CO2_criteria = sqrt(SolnBlk.Grid.Cell[i][j].A)*grad_CO2_abs;
              grad_CO2_criteria_max = max(grad_CO2_criteria_max, grad_CO2_criteria);
 
-	     if ( SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-                  SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+	     if ( SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+                  SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
 	     fsd_x = SolnBlk.W[i][j].scalar[1];
              fsd_y = SolnBlk.W[i][j].scalar[1];
              fsd_abs = sqrt(sqr(fsd_x) + sqr(fsd_y));
@@ -7772,9 +7852,9 @@ int dUdt_Residual_Evaluation(LESPremixed2D_Quad_Block &SolnBlk,
 	if (SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA ||
 	    SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_RANS_K_EPSILON ||
 	    SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
-	    SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-	    SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-	    SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
+	    SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+	    SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+	    SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
 	  SolnBlk.dUdt[i][j][0] += SolnBlk.W[i][j].S_turbulence_model(SolnBlk.dWdx[i][j],
 								      SolnBlk.dWdy[i][j],
 								      SolnBlk.Grid.Cell[i][j].Xc,
@@ -8138,7 +8218,6 @@ int dUdt_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
 #else
     int NUM_VAR_LESPREMIXED2D = SolnBlk.NumVar();
 #endif
-
     double delta_n;
 
     /* Additional variables for dual time stepping. */
@@ -8176,7 +8255,6 @@ int dUdt_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
                                                Input_Parameters.N_Stage,
                                                Input_Parameters.i_Limiter);
         k_residual = 0;
-
         break;
       default:
         omega = Runge_Kutta(i_stage, Input_Parameters.N_Stage);
@@ -8206,7 +8284,6 @@ int dUdt_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
        Linear_Reconstruction_LeastSquares(SolnBlk,Input_Parameters.i_Limiter);
        break;
     } /* endswitch */
-
     /********************************************************/
     /********************************************************/
   
@@ -8215,7 +8292,6 @@ int dUdt_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
         Input_Parameters.i_Viscous_Flux_Evaluation == VISCOUS_RECONSTRUCTION_ARITHMETIC) {
        Viscous_Calculations(SolnBlk);
     }
-  
     /********************************************************/
     /********************************************************/
 
@@ -8517,9 +8593,9 @@ int dUdt_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
           if (SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA ||
               SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_RANS_K_EPSILON ||
 	      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
-	      SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-	      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
- 	      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
+	      SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+	      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+ 	      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
 	    SolnBlk.dUdt[i][j][k_residual] += 
 	      (Input_Parameters.CFL_Number*SolnBlk.dt[i][j])*
 	      SolnBlk.W[i][j].S_turbulence_model(SolnBlk.dWdx[i][j],
@@ -8531,9 +8607,9 @@ int dUdt_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
 	  /* Include source terms associated with the finite-rate chemistry and 
              turbulence/chemistry interactions */ 
 	  if (SolnBlk.W[i][j].React.reactset_flag != NO_REACTIONS &&
-	    SolnBlk.Flow_Type != FLOWTYPE_LAMINAR_FSD &&
-    	    SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY &&
-	    SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_FSD_K) {	 
+	    SolnBlk.Flow_Type != FLOWTYPE_LAMINAR_C_FSD &&
+	    SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY &&
+	    SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_C_FSD_K) {	 
 	    //rho*omega_dot
 	    //
 	    SolnBlk.dUdt[i][j][k_residual] += (Input_Parameters.CFL_Number*SolnBlk.dt[i][j])* 
@@ -8888,12 +8964,11 @@ int Update_Solution_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
   double dTime(ZERO);          // Physical time step
   if (Input_Parameters.Dual_Time_Stepping) dTime = Input_Parameters.dTime;
  
-   if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-        SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-        SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ){
+  if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+       SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+       SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ){
     NUM_VAR_LESPREMIXED2D = SolnBlk.NumVar()-Input_Parameters.Wo.ns+1; 
-   }
-  
+  }
 
   // Memory for linear system solver. 
   DenseSystemLinEqs LinSys;
@@ -8951,9 +9026,9 @@ int Update_Solution_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
 	  Input_Parameters.Local_Time_Stepping == SCALAR_LOCAL_TIME_STEPPING ) {
 	//Update
 	SolnBlk.U[i][j] = SolnBlk.Uo[i][j] + omega*SolnBlk.dUdt[i][j][k_residual];
-        if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+        if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
 	  SolnBlk.U[i][j] = SolnBlk.U[i][j].premixed_mfrac(Input_Parameters.Wo);
 	} else {
 	//N-1 species
@@ -8989,9 +9064,9 @@ int Update_Solution_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
 	    
 	    //Update
 	    SolnBlk.U[i][j] = SolnBlk.Uo[i][j] + omega*SolnBlk.dUdt[i][j][k_residual];
-        if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+        if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
 	  SolnBlk.U[i][j] = SolnBlk.U[i][j].premixed_mfrac(Input_Parameters.Wo);
 	} else {
 	    //N-1 species
@@ -9162,7 +9237,6 @@ int Update_Solution_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
 	}
 
 	
-	
 	/******************************************************************
 	 ******************* EVALUATE RHS *********************************
 	 ******************************************************************/
@@ -9178,9 +9252,9 @@ int Update_Solution_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
 	  SolnBlk.U[i][j][k+1] = SolnBlk.Uo[i][j][k+1] + LinSys.x(k);
 	} 
 
-        if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+        if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
 	  SolnBlk.U[i][j] = SolnBlk.U[i][j].premixed_mfrac(Input_Parameters.Wo);
 	} else {
 	/*********************************************************
@@ -9244,9 +9318,9 @@ int Update_Solution_Multistage_Explicit(LESPremixed2D_Quad_Block &SolnBlk,
 	      SolnBlk.U[i][j][k+1] = SolnBlk.Uo[i][j][k+1] + LinSys.x(k);
 	    } 
 	    
-        if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+        if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
 	  SolnBlk.U[i][j] = SolnBlk.U[i][j].premixed_mfrac(Input_Parameters.Wo);
 	} else {
 	    SolnBlk.U[i][j][NUM_VAR_LESPREMIXED2D] = SolnBlk.U[i][j].rho*(ONE - SolnBlk.U[i][j].sum_species());
@@ -9404,10 +9478,10 @@ void Viscous_Calculations(LESPremixed2D_Quad_Block &SolnBlk) {
       /* Determine the turbulent transport properties. */
       if (SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
-          SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
-         mut = SolnBlk.W[i][j].mu_t(strain_rate);
+          SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
+	mut = SolnBlk.W[i][j].mu_t(strain_rate,SolnBlk.Flow_Type);
          kappa_t =  SolnBlk.W[i][j].Kappa_turb(mut);
          Dm_t = SolnBlk.W[i][j].Dm_turb(mut);
       } /* endif */
@@ -9445,10 +9519,10 @@ void Viscous_Calculations(LESPremixed2D_Quad_Block &SolnBlk) {
       /********************** Turbulent Stresses ***********************/
       if (SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
-          SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) { 
-	SolnBlk.W[i][j].SFS_Stress(strain_rate);          
+          SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) { 
+	SolnBlk.W[i][j].SFS_Stress(strain_rate,SolnBlk.Flow_Type);          
 	SolnBlk.U[i][j].lambda = SolnBlk.W[i][j].lambda;
       } /* endif */
 
@@ -9465,9 +9539,9 @@ void Viscous_Calculations(LESPremixed2D_Quad_Block &SolnBlk) {
          q = - kappa * grad(T)                                         */
       if (SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
           SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
-          SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
+          SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
         SolnBlk.U[i][j].theta = - kappa_t*grad_T;
       /****************** Thermal Diffusion ****************************/
       // q -= rho * sum ( hs * Ds *gradcs)   
diff --git a/src_2D/LESPremixed2D/LESPremixed2DQuadSolvers.cc b/src_2D/LESPremixed2D/LESPremixed2DQuadSolvers.cc
index e43d73e0de0925d62376d0b282dd7ef9a80a8c12..9ac0ec094dcfb4ae57044b3e21be9ff2ff03669f 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DQuadSolvers.cc
+++ b/src_2D/LESPremixed2D/LESPremixed2DQuadSolvers.cc
@@ -181,6 +181,7 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 						 List_of_Global_Solution_Blocks,
 						 List_of_Local_Solution_Blocks);
 
+ 
   
   if (Local_SolnBlk == NULL){ return (1); }
 
@@ -385,7 +386,7 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
           << QuadTree.efficiencyRefinement() << "\n"; 
      cout.flush();
   } /* endif */
-
+ 
   /***********************************************************************	
    MORTON ORDERING of initial solution blocks 
   (should be meshed with AMR, ie when Refine_Grid is done call the ordering)
@@ -418,7 +419,7 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 			      Input_Parameters, 
 			      List_of_Local_Solution_Blocks);
   } 
-
+  
   /****************************************************************************
    *********************** MAIN SOLVER ****************************************
    Solve IBVP or BVP for conservation form of 2D Axisymmetric multispecies 
@@ -461,7 +462,6 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
     if (Input_Parameters.i_ICs != IC_RESTART) {
       Input_Parameters.first_step = first_step;
     }
-
     if (CFFC_Primary_MPI_Processor()) {
       error_flag = Open_Progress_File(residual_file,
 				      Input_Parameters.Output_File_Name,
@@ -479,8 +479,8 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
       if( Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
           Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_K ||
           Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_NO_MODEL ||
-          Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_K ||
+          Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_K ||
           Input_Parameters.i_ICs == IC_HOMOGENEOUS_TURBULENCE ){
 
 	error_flag = Open_Energy_File(energy_file,
@@ -500,8 +500,8 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
     CFFC_Barrier_MPI(); // MPI barrier to ensure processor synchronization.
     CFFC_Broadcast_MPI(&error_flag, 1);
     if (error_flag) return (error_flag);
-    processor_cpu_time.reset();
     
+    processor_cpu_time.reset();
     /**************************************************************************
      Perform required number of iterations (time steps). 
     **************************************************************************/ 
@@ -606,6 +606,7 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 	  *************************************************************************/
 
 	  dTime = CFL(Local_SolnBlk, List_of_Local_Solution_Blocks, Input_Parameters);
+
 	  if (!Input_Parameters.Dual_Time_Stepping) {
 	    // Find global minimum time step for all processors.
 	    dTime = CFFC_Minimum_MPI(dTime);
@@ -727,8 +728,8 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 	    //calculate the turbulence kinetic energy and enstrophy for unsteady turbulent flows
 	    if (Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
 		Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_K ||
-                Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-                Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_K ||
+                Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+                Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_K ||
                 Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_NO_MODEL ||
 		Input_Parameters.i_ICs == IC_HOMOGENEOUS_TURBULENCE) {
 
@@ -760,8 +761,8 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 
 	      if (Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
 		  Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_K ||
-                  Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-                  Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_K ||
+                  Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+                  Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_K ||
                   Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_NO_MODEL ||
                   Input_Parameters.i_ICs == IC_HOMOGENEOUS_TURBULENCE ){
             
@@ -830,7 +831,6 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
             Update solution for next time step using a multistage
             time stepping scheme. 
 	  ***************************************************************************/
-
 	  for ( i_stage  = 1 ; i_stage <= Input_Parameters.N_Stage ; ++i_stage ) {
 	    // 1. Exchange solution information between neighbouring blocks.
 	    error_flag = Send_All_Messages(Local_SolnBlk, 
@@ -843,7 +843,6 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 		   << ".\n";
 	      cout.flush();
 	    } /* endif */
-
 	    // Reduce message passing error flag to other MPI processors.
 	    error_flag = CFFC_OR_MPI(error_flag);
 	    if (error_flag) return (error_flag);
@@ -852,10 +851,9 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 	    /************* BOUNDARY CONDITIONS *********************************/
 	    // 2. Apply boundary conditions for stage.
 	    BCs(Local_SolnBlk, List_of_Local_Solution_Blocks,Input_Parameters);
-	    
 	    /*************** UPDATE SOLUTION ************************************/
 	    // 3. Determine solution residuals for stage.
-	    
+
 	    error_flag = dUdt_Multistage_Explicit(Local_SolnBlk,
 						  List_of_Global_Solution_Blocks,
 						  List_of_Local_Solution_Blocks,
@@ -870,7 +868,7 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 	    
 	    error_flag = CFFC_OR_MPI(error_flag);
 	    if (error_flag) return (error_flag);
-	    
+
 	    // 4. Send boundary flux corrections at block interfaces with resolution changes.
 	    error_flag = Send_Conservative_Flux_Corrections(Local_SolnBlk, 
 							    List_of_Local_Solution_Blocks,
@@ -883,14 +881,11 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 	    } /* endif */
 	    error_flag = CFFC_OR_MPI(error_flag);
 	    if (error_flag) return (error_flag);
-	    
-	
 	    // 5. Apply boundary flux corrections to ensure that method is conservative.
 	    Apply_Boundary_Flux_Corrections_Multistage_Explicit(Local_SolnBlk, 
 								List_of_Local_Solution_Blocks,
 								Input_Parameters,
 								i_stage);
-	 
 	    // 6. Smooth the solution residual using implicit residual smoothing. */
 	    if (Input_Parameters.Residual_Smoothing) {
               Residual_Smoothing(Local_SolnBlk,
@@ -898,13 +893,11 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
                                  Input_Parameters,
                                  i_stage);
 	    } 
-	    
 	    // 7. Update solution for stage.
 	    error_flag = Update_Solution_Multistage_Explicit(Local_SolnBlk, 
 							     List_of_Local_Solution_Blocks,
 							     Input_Parameters,
 							     i_stage);
-	    
 	    if (error_flag) {
 	      cout << "\n LESPremixed2D ERROR: LESPremixed2D solution update error on processor "
 		   << List_of_Local_Solution_Blocks.ThisCPU
@@ -970,8 +963,8 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
         if (Input_Parameters.Dual_Time_Stepping ||
             (Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
 	     Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_K ||
-             Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-             Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_K ||
+             Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+             Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_K ||
 	     Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_NO_MODEL)) {
 
 	  TKEold = energy;
@@ -983,8 +976,8 @@ int LESPremixed2DQuadSolver(char *Input_File_Name_ptr,  int batch_flag) {
 
      if (Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
 	  Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_TF_K ||
-          Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-          Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_FSD_K ||
+          Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+          Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_C_FSD_K ||
 	  Input_Parameters.FlowType == FLOWTYPE_TURBULENT_LES_NO_MODEL) {
 
 	flame_x = Average_Flame_Position(Local_SolnBlk, 
diff --git a/src_2D/LESPremixed2D/LESPremixed2DState.cc b/src_2D/LESPremixed2D/LESPremixed2DState.cc
index da506c4909530bdb8ba5fd1b1ec902f69d8e451d..4e2b4521b0a139b75ad64e86e1c969b5e15b0e61 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DState.cc
+++ b/src_2D/LESPremixed2D/LESPremixed2DState.cc
@@ -94,6 +94,7 @@ void LESPremixed2D_pState::set_species_data(const int &n,
 
   ns = n;
   nscal = n2;
+
   NUM_VAR_LESPREMIXED2D = ns + nscal + NUM_LESPREMIXED2D_VAR_SANS_SPECIES;
 
   //read in NASA data for each species to be used  
@@ -140,8 +141,9 @@ void LESPremixed2D_cState::set_species_data(const int &n,
  
   ns = n;
   nscal = n2;
-  NUM_VAR_LESPREMIXED2D = ns + nscal + NUM_LESPREMIXED2D_VAR_SANS_SPECIES;
 
+  NUM_VAR_LESPREMIXED2D = ns + nscal + NUM_LESPREMIXED2D_VAR_SANS_SPECIES;
+ 
   //read in NASA data for each species to be used
   Deallocate_static();
   specdata = new NASARP1311data[ns];
@@ -512,8 +514,16 @@ double LESPremixed2D_pState::kappa(void) const{
 /**************************************************
   Turbulence model related parameters
 ***************************************************/
-double LESPremixed2D_pState::mu_t(const Tensor2D &strain_rate) const{
-  double mut = rho*SFSmodel.eddy_viscosity_Smagorinsky(strain_rate, filter_width);
+double LESPremixed2D_pState::mu_t(const Tensor2D &strain_rate,
+                                  const int &Flow_Type) const{
+  double mut;
+  if(Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
+     Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ) {
+  mut = rho*SFSmodel.eddy_viscosity_Smagorinsky(strain_rate, filter_width);
+  }else if (Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
+            Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
+    mut = rho*SFSmodel.eddy_viscosity_k(k(), filter_width);
+  }
 #ifdef THICKENED_FLAME_ON
   return (flame.WF*flame.TF)*mut;
 #else
@@ -600,7 +610,7 @@ double LESPremixed2D_pState::T(double &h_s) const{
     numit++;
   }
   if (numit>=19 || T <= low_temp_range){
-    T = max(Tguess,low_temp_range);
+    T = max(Tguess,low_temp_range); 
     cout<<"\nTemperature didn't converge in LESPremixed2D_cState::T(void)";
     cout<<" with polytopic Tguess "<<Tguess<<", or lower than Tmin "
 	<<low_temp_range<<" using "<<T;
@@ -676,13 +686,13 @@ LESPremixed2D_cState LESPremixed2D_pState::Fx(void) const{
 
   if(nscal) for(int i=0; i<nscal; ++i) Temp.rhoscalar[i] = rho*v.x*scalar[i];
    
-   if(Scal_sys.scalar_flag != LES_FSD_C &&
-      Scal_sys.scalar_flag != LES_FSD_C_K) {
+//   if(Scal_sys.scalar_flag != LES_C_FSD &&
+//      Scal_sys.scalar_flag != LES_C_FSD_K) {
   //multispecies transport
   for(int i=0; i<ns; ++i){
     Temp.rhospec[i].c = rho*v.x*spec[i].c;
   }
-   }
+  // }
   return (Temp);
 }
 
@@ -708,12 +718,13 @@ void dFIdU(DenseMatrix &dFdU, const LESPremixed2D_pState &W, const int Flow_Type
   double kk = W.k();
   double denominator = (C_p/Rt - ONE);
 
-  if ( Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+  if ( Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
+
     double eta_fsd = W.Progvar_Species_Grad();
     dFdU(0,1) = ONE;
-    dFdU(1,0) = (HALF*W.v.sqr()-W.v.x*W.v.x*denominator-ht-5.0*kk/3.0+C_p*Temp+W.scalar[0]*eta_fsd)/denominator;
+    dFdU(1,0) = (HALF*W.v.sqr()+W.v.x*W.v.x*denominator-ht-5.0*kk/3.0+C_p*pt/(W.rho*Rt)+W.scalar[0]*eta_fsd)/denominator;
     dFdU(1,1) = W.v.x*(TWO-ONE/denominator); 
     dFdU(1,2) = -W.v.y/denominator;
     dFdU(1,3) = ONE/denominator;
@@ -721,7 +732,7 @@ void dFIdU(DenseMatrix &dFdU, const LESPremixed2D_pState &W, const int Flow_Type
     dFdU(2,0) = -W.v.x*W.v.y;
     dFdU(2,1) = W.v.y;
     dFdU(2,2) = W.v.x;
-    dFdU(3,0) = (W.v.sqr()+C_p*Temp+W.scalar[0]*eta_fsd-C_p/Rt*(HALF*W.v.sqr()+ht+5.0*kk/3.0))*W.v.x/denominator;
+    dFdU(3,0) = (W.v.sqr()+C_p*pt/(W.rho*Rt)+W.scalar[0]*eta_fsd-C_p/Rt*(HALF*W.v.sqr()+ht+5.0*kk/3.0))*W.v.x/denominator;
     dFdU(3,1) = ht+HALF*W.v.sqr()+5.0*kk/3.0-W.v.x*W.v.x/denominator;
     dFdU(3,2) = -W.v.x*W.v.y/denominator;
     dFdU(3,3) = W.v.x*C_p/Rt/denominator;
@@ -733,12 +744,14 @@ void dFIdU(DenseMatrix &dFdU, const LESPremixed2D_pState &W, const int Flow_Type
     dFdU(5,1) = W.scalar[1];
     dFdU(5,5) = W.v.x;
 
-    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
-      dFdU(3,0) = (W.v.sqr()+5.0*kk/3.0+C_p*Temp+W.scalar[0]*eta_fsd-C_p/Rt*(HALF*W.v.sqr()+ht+5.0*kk/3.0))*W.v.x/denominator;
+    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
+      dFdU(1,0) = (HALF*W.v.sqr()+W.v.x*W.v.x*denominator-ht+C_p*pt/(W.rho*Rt)+W.scalar[0]*eta_fsd)/denominator;
+      dFdU(3,0) = (W.v.sqr()+5.0*kk/3.0+C_p*pt/(W.rho*Rt)+W.scalar[0]*eta_fsd-C_p/Rt*(HALF*W.v.sqr()+ht+5.0*kk/3.0))*W.v.x/denominator;
+      dFdU(6,0) = -W.v.x*W.scalar[2];
+      dFdU(6,1) = W.scalar[2];
       dFdU(1,6) = -5.0/3.0/denominator;
       dFdU(3,6) = -5.0/3.0/denominator;
-      dFdU(0,6) = -W.v.x*W.scalar[2];
-      dFdU(1,6) = W.scalar[2];
+      dFdU(6,6) = W.v.x;
     }
 
   }else{
@@ -874,9 +887,9 @@ void dFIdW(DenseMatrix &dFdW, const LESPremixed2D_pState &W, const int Flow_Type
   dFdW(3,2) = W.rho*W.v.x*W.v.y;
   dFdW(3,3) = W.v.x*C_p/Rt;
 
-  if ( Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+  if ( Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
     double eta_fsd = W.Progvar_Species_Grad();
     dFdW(3,4) = W.rho*W.v.x*eta_fsd;
     dFdW(4,0) = W.v.x*W.scalar[0];
@@ -885,7 +898,7 @@ void dFIdW(DenseMatrix &dFdW, const LESPremixed2D_pState &W, const int Flow_Type
     dFdW(5,0) = W.v.x*W.scalar[1];
     dFdW(5,1) = W.rho*W.scalar[1];
     dFdW(5,5) = W.rho*W.v.x;
-    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
       dFdW(3,6) = 5.0*W.rho*W.v.x/3.0;
       dFdW(6,0) = W.v.x*W.scalar[2];
       dFdW(6,1) = W.rho*W.scalar[2];
@@ -976,11 +989,11 @@ void LESPremixed2D_pState::dWdU(DenseMatrix &dWdQ, const int Flow_Type) const{
   dWdQ(2,0) = -v.y/rho;
   dWdQ(2,2) = ONE/rho; 
 
-  if ( Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+  if ( Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
     double eta_fsd = Progvar_Species_Grad();
-    dWdQ(3,0) = HALF*v.sqr()-ht+C_p*Temp+scalar[0]*eta_fsd;
+    dWdQ(3,0) = HALF*v.sqr()-ht-5.0*kk/3.0+C_p*pt/(rho*Rt)+scalar[0]*eta_fsd;
     dWdQ(3,1) = -v.x/denominator;
     dWdQ(3,2) = -v.y/denominator;
     dWdQ(3,3) = ONE/denominator;
@@ -989,7 +1002,8 @@ void LESPremixed2D_pState::dWdU(DenseMatrix &dWdQ, const int Flow_Type) const{
     dWdQ(4,4) = ONE/rho;
     dWdQ(5,0) = -scalar[1]/rho;;
     dWdQ(5,5) = ONE/rho;
-    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
+      dWdQ(3,0) = HALF*v.sqr()-ht+C_p*pt/(rho*Rt)+scalar[0]*eta_fsd;
       dWdQ(3,6) = -5.0/3.0/denominator;
       dWdQ(6,0) = -scalar[2]/rho;
       dWdQ(6,6) = ONE/rho;
@@ -1099,16 +1113,16 @@ void LESPremixed2D_pState::dUdW(DenseMatrix &dQdW, const int Flow_Type){
   dQdW(3,2) =  rho*v.y;
   dQdW(3,3) =  C_p/Rt - ONE;
 
-  if ( Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+  if ( Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
     double eta_fsd = Progvar_Species_Grad();
     dQdW(3,4) = rho*eta_fsd;
     dQdW(4,0) = scalar[0];
     dQdW(4,4) = rho;
     dQdW(5,0) = scalar[1];
     dQdW(5,5) = rho;
-    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
       dQdW(3,6) = 5.0*rho/3.0;
       dQdW(6,0) = scalar[2];
       dQdW(6,6) = rho;
@@ -1190,11 +1204,11 @@ LESPremixed2D_pState LESPremixed2D_pState::lambda_x(void) const {
   Temp.p = v.x + c;
   if(nscal) for(int i=0; i<nscal; ++i) Temp.scalar[i] = v.x;
 
-   if(Scal_sys.scalar_flag != LES_FSD_C &&
-      Scal_sys.scalar_flag != LES_FSD_C_K) {
+   if(Scal_sys.scalar_flag != LES_C_FSD &&
+      Scal_sys.scalar_flag != LES_C_FSD_K) {
   for(int i=0; i<ns; ++i){
     Temp.spec[i].c = v.x;
-   }
+  }
   }     
   return (Temp);
 }
@@ -1217,12 +1231,12 @@ LESPremixed2D_pState LESPremixed2D_pState::lambda_preconditioned_x(const double
   NEW.p = uprimed + cprimed;
   if(nscal) for(int i=0; i<nscal; ++i) NEW.scalar[i] = v.x;
 
-   if(Scal_sys.scalar_flag != LES_FSD_C &&
-      Scal_sys.scalar_flag != LES_FSD_C_K) {
+    if(Scal_sys.scalar_flag != LES_C_FSD &&
+       Scal_sys.scalar_flag != LES_C_FSD_K) {
   for(int i=0; i<ns; ++i){
     NEW.spec[i].c = v.x;
-   }
-  }    
+  }
+ }    
   return (NEW);
 }
 
@@ -1232,33 +1246,36 @@ LESPremixed2D_pState LESPremixed2D_pState::lambda_preconditioned_x(const double
 // Conserved Right Eigenvector -- (x-direction)
 LESPremixed2D_cState LESPremixed2D_pState::rc_x(const int &index) const {
 
-  if(Scal_sys.scalar_flag == LES_FSD_C ||
-     Scal_sys.scalar_flag == LES_FSD_C_K) {
+  if(Scal_sys.scalar_flag == LES_C_FSD ||
+     Scal_sys.scalar_flag == LES_C_FSD_K) {
       double c = amodified(); 
       double eta_fsd = Progvar_Species_Grad();
+    assert( index >= 1 && index <= (NUM_VAR_LESPREMIXED2D) );
     if(index == 1){
       return (LESPremixed2D_cState(ONE, v.x-c, v.y, H()/rho-v.x*c, scalar));
     } else if(index == 2) {
+      cout<<"index=   "<<index<<LESPremixed2D_cState(ONE, v.x, v.y, H()/rho-c*c/(g()-ONE), scalar)<<endl;
       return (LESPremixed2D_cState(ONE, v.x, v.y, H()/rho-c*c/(g()-ONE), scalar)); 
     } else if(index == 3) {
       return (LESPremixed2D_cState(ZERO, ZERO, rho, rho*v.y, ZERO));
     } else if(index == 4) {
       return (LESPremixed2D_cState(ONE, v.x+c, v.y, H()/rho+v.x*c, scalar));
-    } else if( nscal  &&  index >=5 && index<=(NUM_VAR_LESPREMIXED2D-ns)){
-      for(int i=5; i<=(NUM_VAR_LESPREMIXED2D-ns); ++i){
-        if(index == 5){
-          LESPremixed2D_cState NEW(ZERO);
-          NEW.E = eta_fsd;//FIVE*rho/THREE;   // For k equation
-          NEW.rhoscalar[i-5] = rho; //rho*scalar[i-5];
-          return NEW;
-	} else {  
-          LESPremixed2D_cState NEW(ZERO);
-          NEW.rhoscalar[i-5] = rho*scalar[i-5]; // ????
-          return NEW;
-        }
-      }
+    } else if( nscal  &&  index >=5 && index<=NUM_VAR_LESPREMIXED2D-ns){
+      //       for(int i=5; i<=NUM_VAR_LESPREMIXED2D; ++i){
+         if(index == 5){
+           LESPremixed2D_cState NEW(ZERO);
+           NEW.E = rho*eta_fsd;//FIVE*rho/THREE;   // For k equation
+           NEW.rhoscalar[index-5] = rho;
+           return NEW;
+ 	} else {  
+           LESPremixed2D_cState NEW(ZERO);
+           NEW.rhoscalar[index-5] = rho; // ????
+           return NEW;
+	   //         }
+       }
     }
   }else{
+
     if(index == 1){
       double c = amodified(); 
       return (LESPremixed2D_cState(ONE, v.x-c, v.y, H()/rho-v.x*c, scalar, spec));
@@ -1270,8 +1287,8 @@ LESPremixed2D_cState LESPremixed2D_pState::rc_x(const int &index) const {
     } else if(index == 4) {
       double c = amodified();
       return (LESPremixed2D_cState(ONE, v.x+c, v.y, H()/rho+v.x*c, scalar, spec));
-    } else if( nscal  &&  index >=5 && index<=(NUM_VAR_LESPREMIXED2D-ns)){
-      for(int i=5; i<=(NUM_VAR_LESPREMIXED2D-ns); ++i){
+    } else if( nscal  &&  index >=5 && index<=NUM_VAR_LESPREMIXED2D-ns){
+      for(int i=5; i<=NUM_VAR_LESPREMIXED2D-ns; ++i){
         if(index == 5){
           LESPremixed2D_cState NEW(ZERO);
           NEW.E = FIVE*rho/THREE;   // For k equation
@@ -1297,40 +1314,41 @@ LESPremixed2D_cState LESPremixed2D_pState::rc_x(const int &index) const {
       NEW.rhospec[count].c = rho;
       return NEW;
     }
-}
+ }
 }
 // Primitive Left Eigenvector -- (x-direction)
 LESPremixed2D_pState LESPremixed2D_pState::lp_x(const int &index) const {
  
-   if(index == 1){
+  if(Scal_sys.scalar_flag == LES_C_FSD ||
+     Scal_sys.scalar_flag == LES_C_FSD_K) {
+    assert( index >= 1 && index <= (NUM_VAR_LESPREMIXED2D) );
+  }
       double c = amodified(); 
+   if(index == 1){
       return (LESPremixed2D_pState(ZERO, -HALF*rho/c, ZERO, HALF/(c*c), ZERO));
+      cout<<"lpx=  "<<LESPremixed2D_pState(ZERO, -HALF*rho/c, ZERO, HALF/(c*c), ZERO)<<endl;
    } else if(index == 2) {
-      double c = amodified(); 
       return (LESPremixed2D_pState(ONE, ZERO, ZERO, -ONE/(c*c), ZERO));
    } else if(index == 3) {
       return  (LESPremixed2D_pState(ZERO, ZERO, ONE, ZERO, ZERO));
    } else if(index == 4) {  
-      double c = amodified(); 
       return (LESPremixed2D_pState(ZERO, HALF*rho/c, ZERO, HALF/(c*c), ZERO));
-
    } else if(nscal  &&  index >=5  &&  index<=(NUM_VAR_LESPREMIXED2D-ns) ){
      for(int i=5; i<=(NUM_VAR_LESPREMIXED2D-ns); ++i){
        if(index == i){
 	 LESPremixed2D_pState NEW(ZERO);
-	 NEW.scalar[i-5] = ONE; 
+	 NEW.scalar[i-5] = ONE;//scalar[i-5];//ONE; 
 	 return NEW;
        }
      }
-
-   } else{ 
-  if(Scal_sys.scalar_flag != LES_FSD_C &&
-     Scal_sys.scalar_flag != LES_FSD_C_K) {
+     } else{
+     if(Scal_sys.scalar_flag != LES_C_FSD &&
+        Scal_sys.scalar_flag != LES_C_FSD_K) {
      LESPremixed2D_pState NEW(ZERO);
      NEW.spec[index-(NUM_VAR_LESPREMIXED2D-ns+1)].c = ONE;
      return NEW;
+     }
    } 
-   }
 }
 
 /************************************************************
@@ -1338,13 +1356,14 @@ LESPremixed2D_pState LESPremixed2D_pState::lp_x(const int &index) const {
  ************************************************************/
 // Conserved Right Eigenvector -- (x-direction)
 LESPremixed2D_cState LESPremixed2D_pState::rc_x_precon(const int &index, const double &MR2) const {
-
-  if(Scal_sys.scalar_flag == LES_FSD_C ||
-     Scal_sys.scalar_flag == LES_FSD_C_K) {
+  
+  if(Scal_sys.scalar_flag == LES_C_FSD ||
+     Scal_sys.scalar_flag == LES_C_FSD_K) {
        double c = amodified(); 
        double uprimed,cprimed;
        u_a_precon(MR2*c*c,uprimed,cprimed);
        double eta_fsd = Progvar_Species_Grad();
+       assert( index >= 1 && index <= (NUM_VAR_LESPREMIXED2D-ns) );
 
   if(index == 1){
     return (LESPremixed2D_cState(ONE, 
@@ -1353,7 +1372,7 @@ LESPremixed2D_cState LESPremixed2D_pState::rc_x_precon(const int &index, const d
 				 h()+HALF*(v.y*v.y+v.x*v.x/MR2)+FIVE*k()/THREE-(v.x*cprimed)/MR2,
 				 scalar));
   } else if(index == 2) {
-    return (LESPremixed2D_cState(ONE, v.x, v.y, (H()/rho-c*c/(g()-ONE)), scalar));
+    return (LESPremixed2D_cState(ONE, v.x, v.y, h()-Cp()*T()+ HALF*v.sqr()-scalar[0]*eta_fsd, scalar));
   } else if(index == 3) {
     return (LESPremixed2D_cState(ZERO, ZERO, rho, rho*v.y, ZERO));
   } else if(index == 4) { 
@@ -1362,21 +1381,22 @@ LESPremixed2D_cState LESPremixed2D_pState::rc_x_precon(const int &index, const d
 				 v.y, 
 				 h()+HALF*(v.y*v.y+v.x*v.x/MR2)+FIVE*k()/THREE+(v.x*cprimed)/MR2,
 				 scalar));
-  } else if(nscal  && index >=5  && index<=(NUM_VAR_LESPREMIXED2D-ns) ){
-    for(int i=5; i<=(NUM_VAR_LESPREMIXED2D-ns); ++i){
+  } else if(nscal  && index >=5  && index<=NUM_VAR_LESPREMIXED2D-ns ){
+    //    for( int i=5; i<=NUM_VAR_LESPREMIXED2D-ns; ++i){
       if(index == 5){
 	LESPremixed2D_cState NEW(ZERO);
-	NEW.E = eta_fsd;//FIVE*rho/THREE;   // For k equation
-	NEW.rhoscalar[i-5] = rho; 
+	NEW.E = rho*eta_fsd;//FIVE*rho/THREE;   // For k equation
+	NEW.rhoscalar[index-5] = rho; 
 	return NEW;
       } else {  
 	LESPremixed2D_cState NEW(ZERO);
-	NEW.rhoscalar[i-5] = rho*scalar[i-5]; // ????
+	NEW.rhoscalar[index-5] = rho; // ????
 	return NEW;
-      }        
+	//      }        
     }  
   }
   }else{
+  
   if(index == 1){
     double c = amodified(); 
     double uprimed,cprimed;
@@ -1433,62 +1453,30 @@ LESPremixed2D_cState LESPremixed2D_pState::rc_x_precon(const int &index, const d
     NEW.rhospec[count].c = rho;
     return NEW;    
   }
-  }
+ }
 }
 
 // Primitive Left Eigenvector -- (x-direction)
 LESPremixed2D_pState LESPremixed2D_pState::lp_x_precon(const int &index, const double &MR2) const {
-  
-  if(Scal_sys.scalar_flag == LES_FSD_C ||
-     Scal_sys.scalar_flag == LES_FSD_C_K) {
-       double c = amodified(); 
-       double uprimed,cprimed;
-       u_a_precon(MR2*c*c,uprimed,cprimed);
-       double eta_fsd = Progvar_Species_Grad();
-  if(index == 1){
-    return (LESPremixed2D_pState(ZERO, 
-				 -HALF*rho*MR2/cprimed, 
-				 ZERO,
-				 (-uprimed+cprimed + v.x)/(TWO*cprimed*c*c),
-				 ZERO));
-  } else if(index == 2) {
-    return (LESPremixed2D_pState(ONE, ZERO, ZERO, -ONE/(c*c), ZERO));
-  } else if(index == 3) {
-    return  (LESPremixed2D_pState(ZERO, ZERO, ONE, ZERO,ZERO));
-  } else if(index == 4) {  
-    return (LESPremixed2D_pState(ZERO, 
-				 HALF*rho*MR2/cprimed, 
-				 ZERO,
-				 (uprimed+cprimed - v.x)/(TWO*cprimed*c*c),
-				 ZERO));
-  } else if(nscal  &&  index >=5 && index<=(NUM_VAR_LESPREMIXED2D-ns) ){
-    for(int i=5; i<=(NUM_VAR_LESPREMIXED2D-ns); ++i){
-      if(index == i){
-	LESPremixed2D_pState NEW(ZERO);
-	NEW.scalar[i-5] = ONE; // scalar[i-5]; ?????
-	return NEW;
-      }
-    }
+
+  if(Scal_sys.scalar_flag == LES_C_FSD ||
+     Scal_sys.scalar_flag == LES_C_FSD_K) {
+       assert( index >= 1 && index <= (NUM_VAR_LESPREMIXED2D-ns) );
   }
-  }else{
-  if(index == 1){
     double c = amodified();   
     double uprimed,cprimed;
     u_a_precon(MR2*c*c,uprimed,cprimed);
+  if(index == 1){
     return (LESPremixed2D_pState(ZERO, 
 				 -HALF*rho*MR2/cprimed, 
 				 ZERO,
 				 (-uprimed+cprimed + v.x)/(TWO*cprimed*c*c),
 				 ZERO));
   } else if(index == 2) {
-    double c = amodified(); 
     return (LESPremixed2D_pState(ONE, ZERO, ZERO, -ONE/(c*c), ZERO));
   } else if(index == 3) {
     return  (LESPremixed2D_pState(ZERO, ZERO, ONE, ZERO,ZERO));
   } else if(index == 4) {  
-    double c = amodified(); 
-    double uprimed,cprimed;
-    u_a_precon(MR2*c*c,uprimed,cprimed);
     return (LESPremixed2D_pState(ZERO, 
 				 HALF*rho*MR2/cprimed, 
 				 ZERO,
@@ -1496,19 +1484,21 @@ LESPremixed2D_pState LESPremixed2D_pState::lp_x_precon(const int &index, const d
 				 ZERO));
 
   } else if(nscal  &&  index >=5 && index<=(NUM_VAR_LESPREMIXED2D-ns) ){
-    for(int i=5; i<=(NUM_VAR_LESPREMIXED2D-ns); ++i){
+    for( int i=5; i<=(NUM_VAR_LESPREMIXED2D-ns); ++i){
       if(index == i){
 	LESPremixed2D_pState NEW(ZERO);
-	NEW.scalar[i-5] = ONE; // scalar[i-5]; ?????
+	NEW.scalar[i-5] = ONE;//scalar[index-5];// ?????
 	return NEW;
       }
     }
   
   } else { 
+    if(Scal_sys.scalar_flag != LES_C_FSD &&
+       Scal_sys.scalar_flag != LES_C_FSD_K) {
     LESPremixed2D_pState NEW(ZERO);
     NEW.spec[index-(NUM_VAR_LESPREMIXED2D-ns+1)].c = ONE;
     return NEW;
-  }
+    }
   } 
 }
 
@@ -1581,62 +1571,65 @@ void LESPremixed2D_pState::Low_Mach_Number_Preconditioner(DenseMatrix &P,
   double theta = ONE/(Mr2(Viscous_flag,deltax)*c*c) + (g()-ONE)/(c*c);  
   double kk = k();
  
-  if ( Viscous_flag == FLOWTYPE_LAMINAR_FSD || 
-       Viscous_flag == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-       Viscous_flag == FLOWTYPE_TURBULENT_LES_FSD_K )  {
+  if ( Viscous_flag == FLOWTYPE_LAMINAR_C_FSD || 
+       Viscous_flag == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+       Viscous_flag == FLOWTYPE_TURBULENT_LES_C_FSD_K )  {
 
   double eta_fsd = Progvar_Species_Grad();
   double phi = scalar[0]*eta_fsd;
-  double alpha = theta*p/rho;
+  double alpha = theta*pt/rho;
   double alpham1 = alpha - ONE;
-  double Omega = (Rmix - CP)*p/(rho*Rmix);
-  double beta = enthalpy - CP*p/(rho*Rmix) - phi;
+  double Omega = (Rmix - CP)*pt/(rho*Rmix);
+  double beta = enthalpy - CP*p/(rho*Rmix) - phi + 5.0*kk/3.0;
   double V = HALF*v.sqr();
+  P(NUM_VAR_LESPREMIXED2D-ns,NUM_VAR_LESPREMIXED2D-ns);
   P.zero();
-
-  P(0,0) = (alpha*(beta-V)+V+Rmix*Temp-enthalpy+phi)/Omega;
+  P(0,0) = (alpha*(beta-V)+V+pt/rho-enthalpy+phi-FIVE*kk/THREE)/Omega;
   P(0,1) = v.x*alpham1/Omega;
   P(0,2) = v.y*alpham1/Omega;
   P(0,3) = -alpham1/Omega;
+  P(0,4) = eta_fsd*alpham1/Omega;
   P(1,0) = v.x*(beta-V)*alpham1/Omega;
-  P(1,1) = v.x*v.x*alpham1/Omega+1.0;
+  P(1,1) = v.x*v.x*alpham1/Omega+ONE;
   P(1,2) = v.x*v.y*alpham1/Omega;
   P(1,3) = -v.x*alpham1/Omega;
+  P(1,4) = v.x*eta_fsd*alpham1/Omega;
   P(2,0) = v.y*(beta-V)*alpham1/Omega;
   P(2,1) = v.x*v.y*alpham1/Omega;
-  P(2,2) = v.y*v.y*alpham1/Omega+1.0;
+  P(2,2) = v.y*v.y*alpham1/Omega+ONE;
   P(2,3) = -v.y*alpham1/Omega;
-  P(3,0) = (enthalpy+V)*(beta-V)*alpham1/Omega;
-  P(3,1) = v.x*(enthalpy+V)*alpham1/Omega;
-  P(3,2) = v.y*(enthalpy+V)*alpham1/Omega;
-  P(3,3) = -(alpha*(enthalpy+V)-V-Rmix*Temp-beta-phi)/Omega;
-  P(0,4) = eta_fsd*alpham1/Omega;
-  P(1,4) = v.x*eta_fsd*alpham1/Omega;
   P(2,4) = v.y*eta_fsd*alpham1/Omega;
-  P(3,4) = eta_fsd*(enthalpy+V)*alpham1/Omega;
+  P(3,0) = (enthalpy+V+FIVE*kk/THREE)*(beta-V)*alpham1/Omega;
+  P(3,1) = v.x*(enthalpy+V+FIVE*kk/THREE)*alpham1/Omega;
+  P(3,2) = v.y*(enthalpy+V+FIVE*kk/THREE)*alpham1/Omega;
+  P(3,3) = -(alpha*(enthalpy+V+FIVE*kk/THREE)-V-pt/rho-beta-phi)/Omega;
+  P(3,4) = eta_fsd*(enthalpy+V+FIVE*kk/THREE)*alpham1/Omega;
   P(4,0) = scalar[0]*(beta-V)*alpham1/Omega;
   P(4,1) = scalar[0]*v.x*alpham1/Omega;
   P(4,2) = scalar[0]*v.y*alpham1/Omega;
   P(4,3) = -scalar[0]*alpham1/Omega;
-  P(4,4) = scalar[0]*eta_fsd*alpham1/Omega+1.0;
+  P(4,4) = scalar[0]*eta_fsd*alpham1/Omega+ONE;
   P(5,0) = scalar[1]*(beta-V)*alpham1/Omega;
   P(5,1) = scalar[1]*v.x*alpham1/Omega;
   P(5,2) = scalar[1]*v.y*alpham1/Omega;
   P(5,3) = -scalar[1]*alpham1/Omega;
   P(5,4) = scalar[1]*eta_fsd*alpham1/Omega;
   P(5,5) = ONE;
-//   P(0,5) = scalar[1]*alpham1/Omega;
-//   P(1,5) = scalar[1]*v.x*alpham1/Omega;
-//   P(2,5) = scalar[1]*v.y*alpham1/Omega;
-//   P(3,5) = scalar[1]*(enthalpy+V)*alpham1/Omega;
-//   P(4,5) = scalar[1]*scalar[0]*alpham1/Omega; 
-      if ( Viscous_flag == FLOWTYPE_TURBULENT_LES_FSD_K ){
+      if ( Viscous_flag == FLOWTYPE_TURBULENT_LES_C_FSD_K ){
+  P(0,0) = (alpha*(beta-V)+V+pt/rho-enthalpy+phi)/Omega;
+  P(3,3) = -(alpha*(enthalpy+V+FIVE*kk/THREE)-V-pt/rho-beta-phi-FIVE*kk/THREE)/Omega;
   P(6,0) = scalar[2]*(beta-V)*alpham1/Omega;
   P(6,1) = scalar[2]*v.x*alpham1/Omega;
   P(6,2) = scalar[2]*v.y*alpham1/Omega;
   P(6,3) = -scalar[2]*alpham1/Omega;
   P(6,4) = scalar[2]*eta_fsd*alpham1/Omega;
-  P(6,6) = ONE;
+  P(0,6) = 5.0/3.0*alpham1/Omega;
+  P(1,6) = 5.0/3.0*v.x*alpham1/Omega;
+  P(2,6) = 5.0/3.0*v.y*alpham1/Omega;
+  P(3,6) = 5.0/3.0*(enthalpy+V+5.0/3.0*kk)*alpham1/Omega;
+  P(4,6) = 5.0/3.0*scalar[0]*alpham1/Omega;
+  P(5,6) = 5.0/3.0*scalar[1]*alpham1/Omega;
+  P(6,6) = 5.0/3.0*kk*alpham1/Omega + 1.0;
       }
     }else{
 
@@ -1762,64 +1755,65 @@ void LESPremixed2D_pState::Low_Mach_Number_Preconditioner_Inverse(DenseMatrix &P
   double theta = ONE/(Mr2(Viscous_flag,deltax)*c*c) + (g()-ONE)/(c*c);  
   double kk = k();
 
-  if ( Viscous_flag == FLOWTYPE_LAMINAR_FSD || 
-       Viscous_flag == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-       Viscous_flag == FLOWTYPE_TURBULENT_LES_FSD_K )  {
+  if ( Viscous_flag == FLOWTYPE_LAMINAR_C_FSD || 
+       Viscous_flag == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+       Viscous_flag == FLOWTYPE_TURBULENT_LES_C_FSD_K )  {
 
   double eta_fsd = Progvar_Species_Grad();
   double phi = scalar[0]*eta_fsd;
-  double AA = p*(rho*Rmix-theta*p*CP);
-  double BB = Rmix*rho*(theta*p-rho);
-  double EE = HALF*v.sqr() - enthalpy + phi;
-  double CC = EE + CP*Temp; 
-  double DD = HALF*v.sqr() + enthalpy;
+  double AA = pt*(rho*Rmix-theta*pt*CP);
+  double BB = Rmix*rho*(theta*pt-rho);
+  double EE = HALF*v.sqr() - enthalpy + phi - FIVE*kk/THREE;
+  double CC = EE + CP*pt/(rho*Rmix); 
+  double DD = HALF*v.sqr() + enthalpy + FIVE*kk/THREE;
+  Pinv(NUM_VAR_LESPREMIXED2D-ns,NUM_VAR_LESPREMIXED2D-ns);
   Pinv.zero();    
 
-  Pinv(0,0) = rho*Rmix/AA*(theta*p*EE-rho*CC+p);
+  Pinv(0,0) = rho*Rmix/AA*(theta*pt*EE-rho*CC+pt);
   Pinv(0,1) = -v.x*BB/AA;
   Pinv(0,2) = -v.y*BB/AA;
   Pinv(0,3) = BB/AA;
+  Pinv(0,4) = -eta_fsd*BB/AA;
   Pinv(1,0) = v.x*CC*BB/AA;
-  Pinv(1,1) = rho*Rmix/AA*(p+rho*v.x*v.x-theta*p*(v.x*v.x+CP*Temp));
+  Pinv(1,1) = rho*Rmix/AA*(pt+rho*v.x*v.x-theta*pt*(v.x*v.x+CP*pt/(rho*Rmix)));
   Pinv(1,2) = -v.x*v.y*BB/AA;
   Pinv(1,3) = v.x*BB/AA;    
+  Pinv(1,4) = -v.x*eta_fsd*BB/AA;
   Pinv(2,0) = v.y*CC*BB/AA;
   Pinv(2,1) = -v.x*v.y*BB/AA;
-  Pinv(2,2) = rho*Rmix/AA*(p+v.y*v.y*rho-theta*p*(v.y*v.y+CP*Temp));
+  Pinv(2,2) = rho*Rmix/AA*(pt+rho*v.y*v.y-theta*pt*(v.y*v.y+CP*pt/(rho*Rmix)));
   Pinv(2,3) = v.y*BB/AA;  
+  Pinv(2,4) = -v.y*eta_fsd*BB/AA;
   Pinv(3,0) = DD*CC*BB/AA;
   Pinv(3,1) = -v.x*DD*BB/AA;
   Pinv(3,2) = -v.y*DD*BB/AA;
-  Pinv(3,3) = rho*Rmix/AA*(theta*p*(DD-CP*Temp)-rho*DD+p);
-  Pinv(0,4) = -eta_fsd*BB/AA;
-  Pinv(1,4) = -v.x*eta_fsd*BB/AA;
-  Pinv(2,4) = -v.y*eta_fsd*BB/AA;
+  Pinv(3,3) = rho*Rmix/AA*(theta*pt*(DD-CP*pt/(rho*Rmix))-rho*DD+pt);
   Pinv(3,4) = -eta_fsd*BB*DD/AA;
   Pinv(4,0) = scalar[0]*CC*BB/AA;
   Pinv(4,1) = -scalar[0]*v.x*BB/AA;
   Pinv(4,2) = -scalar[0]*v.y*BB/AA;
   Pinv(4,3) = scalar[0]*BB/AA;
-  Pinv(4,4) = 1.0 - scalar[0]*eta_fsd*BB/AA;
+  Pinv(4,4) = ONE-scalar[0]*eta_fsd*BB/AA;
   Pinv(5,0) = scalar[1]*CC*BB/AA;
   Pinv(5,1) = -scalar[1]*v.x*BB/AA;
   Pinv(5,2) = -scalar[1]*v.y*BB/AA;
   Pinv(5,3) = scalar[1]*BB/AA;
   Pinv(5,4) = -scalar[1]*eta_fsd*BB/AA;
   Pinv(5,5) = ONE;
-//   Pinv(0,5) = -scalar[1]*BB/AA;
-//   Pinv(1,5) = -scalar[1]*v.x*BB/AA;
-//   Pinv(2,5) = -scalar[1]*v.y*BB/AA;
-//   Pinv(3,5) = -scalar[1]*DD*BB/AA;
-//   Pinv(4,5) = -scalar[1]*scalar[0]*BB/AA;
-      if ( Viscous_flag == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+      if ( Viscous_flag == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
   Pinv(6,0) = scalar[2]*CC*BB/AA;
   Pinv(6,1) = -scalar[2]*v.x*BB/AA;
   Pinv(6,2) = -scalar[2]*v.y*BB/AA;
   Pinv(6,3) = scalar[2]*BB/AA;
   Pinv(6,4) = -scalar[2]*eta_fsd*BB/AA;
-  Pinv(6,6) = ONE;
+  Pinv(0,6) = -5.0/3.0*BB/AA;
+  Pinv(1,6) = -5.0/3.0*v.x*BB/AA;
+  Pinv(2,6) = -5.0/3.0*v.y*BB/AA;
+  Pinv(3,6) = -5.0/3.0*DD*BB/AA;
+  Pinv(4,6) = -5.0/3.0*scalar[0]*BB/AA;
+  Pinv(5,6) = -5.0/3.0*scalar[1]*BB/AA;
+  Pinv(6,6) = 1.0-5.0/3.0*scalar[2]*BB/AA;
       }
-
 }else{
 
   double phi = ZERO;
@@ -1921,23 +1915,12 @@ double LESPremixed2D_pState::HeatRelease_Parameter(void) const {
     return (adiabatic_temp/298.0-1.0);
 }
 
-double LESPremixed2D_pState::SFS_Kinetic_Energy_Fsd(const LESPremixed2D_pState &dWdx,
-                                                    const LESPremixed2D_pState &dWdy,
-                                                    const int &Flow_Type) const {
-  double u_ratio = 1.0;
-  if ( Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ) {
-    return (k());
-  } else if ( Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
-    return (k());
-  }
-}
-
 double LESPremixed2D_pState::Efficiency_Function_Fsd(const LESPremixed2D_pState &dWdx,
                                                      const LESPremixed2D_pState &dWdy,
                                                      const int &Flow_Type) const {
   double k_fsd, kappa_fsd;
-  k_fsd = SFS_Kinetic_Energy_Fsd(dWdx,dWdy,Flow_Type);
-  kappa_fsd = 0.75*exp(-1.2/pow(sqrt(k_fsd)/laminar_speed,0.3))*pow(filter_width/laminar_thickness,2.0/3.0);
+  //  k_fsd = SFS_Kinetic_Energy_Fsd(dWdx,dWdy,Flow_Type);
+  kappa_fsd = 0.75*exp(-1.2/pow(sqrt(k())/laminar_speed,0.3))*pow(filter_width/laminar_thickness,2.0/3.0);
   return(kappa_fsd);
 }
 
@@ -1973,7 +1956,7 @@ double LESPremixed2D_pState::Reaction_Rate_Fsd(const LESPremixed2D_pState &dWdx,
                                                const LESPremixed2D_pState &dWdy) const {
      double tau_fsd = HeatRelease_Parameter();
      if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-     return ( reactants_den*laminar_speed*scalar[1]*rho-tau_fsd*laminar_speed*(rho*(1-2*scalar[0])*(dWdx.scalar[0]+dWdy.scalar[0])+scalar[0]*(1-scalar[0])*(dWdx.rho+dWdy.rho)) );
+       return ( reactants_den*laminar_speed*scalar[1]*rho);//-tau_fsd*laminar_speed*(rho*(1-2*scalar[0])*(dWdx.scalar[0]+dWdy.scalar[0])+scalar[0]*(1-scalar[0])*(dWdx.rho+dWdy.rho)) );
     }else{
      return ( 0.0 );
     }
@@ -2052,13 +2035,13 @@ double LESPremixed2D_pState::SFS_Strain(const LESPremixed2D_pState &dWdx,
                                         const int &Flow_Type) const {
 
     double k_fsd, kappa_fsd;
-    k_fsd = SFS_Kinetic_Energy_Fsd(dWdx,dWdy,Flow_Type);
+    //    k_fsd = SFS_Kinetic_Energy_Fsd(dWdx,dWdy,Flow_Type);
     kappa_fsd = Efficiency_Function_Fsd(dWdx,dWdy,Flow_Type);   
-    if ( Flow_Type == FLOWTYPE_LAMINAR_FSD ){
+    if ( Flow_Type == FLOWTYPE_LAMINAR_C_FSD ){
     return ( 0.0 );
     }else {
     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO) {
-    return ( kappa_fsd*sqrt(k_fsd)*scalar[1]*rho/filter_width );
+      return ( kappa_fsd*sqrt(k())*scalar[1]*rho/filter_width );
    }else{
     return (0.0);
    }
@@ -2074,14 +2057,14 @@ double LESPremixed2D_pState::SFS_Curvature(const LESPremixed2D_pState &dWdx,
     Mx = M_x(dWdx,dWdy);
     My = M_y(dWdx,dWdy);
     alpha_fsd = ONE - sqr(Mx) - sqr(My);
-    if ( Flow_Type == FLOWTYPE_LAMINAR_FSD ){
+    if ( Flow_Type == FLOWTYPE_LAMINAR_C_FSD ){
     return ( 0.0 );
     }else{
     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO && scalar[1] != ZERO) {
-      //    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ){
+      //    if ( Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ){
     return ( -beta_fsd*laminar_speed*sqr(scalar[1]*rho)/(ONE-scalar[0]) );
     //    }
-//     if ( Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_CHARLETTE ){
+//     if ( Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSDHARLETTE ){
 //     double tau_fsd = HeatRelease_Parameter();
 //     double c_bar = (1.0+tau_fsd)*scalar[0]/(1.0+tau_fsd*scalar[0]);
 //     return(-beta_fsd*laminar_speed*(scalar[1]-(1+tau_fsd)*sqrt(sqr(dWdx.scalar[0])+sqr(dWdy.scalar[0]))/sqr(1+tau_fsd*scalar[0]))*scalar[1]/c_bar/(1-c_bar));
@@ -2092,244 +2075,150 @@ double LESPremixed2D_pState::SFS_Curvature(const LESPremixed2D_pState &dWdx,
    }
 }
 
-// double LESPremixed2D_pState::M_xx(const LESPremixed2D_pState &dWdx,
-//                                   const LESPremixed2D_pState &dWdy,
-//                                   const LESPremixed2D_pState &d_dWdx_dx,
-//                                   const LESPremixed2D_pState &d_dWdx_dy,
-//                                   const LESPremixed2D_pState &d_dWdy_dy) const {
-//     double Mxx, magnitude_C;
-//     magnitude_C = sqrt(sqr(dWdx.scalar[0])+sqr(dWdy.scalar[0]));
-//     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) { 
-//     Mxx = -d_dWdx_dx.scalar[0]/magnitude_C+dWdx.scalar[0]*(dWdx.scalar[0]*d_dWdx_dx.scalar[0]+dWdy.scalar[0]*d_dWdx_dy.scalar[0])/pow(magnitude_C,3);
-//     return ( Mxx );
-//    }else{
-//     return (0.0);
-//    }
-// }
-
-// double LESPremixed2D_pState::M_yy(const LESPremixed2D_pState &dWdx,
-//                                   const LESPremixed2D_pState &dWdy,
-//                                   const LESPremixed2D_pState &d_dWdx_dx,
-//                                   const LESPremixed2D_pState &d_dWdx_dy,
-//                                   const LESPremixed2D_pState &d_dWdy_dy) const {
-//      double Myy, magnitude_C;
-//      magnitude_C = sqrt(sqr(dWdx.scalar[0])+sqr(dWdy.scalar[0]));
-//      if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//      Myy = -d_dWdy_dy.scalar[0]/magnitude_C+dWdy.scalar[0]*(dWdx.scalar[0]*d_dWdx_dy.scalar[0]+dWdy.scalar[0]*d_dWdy_dy.scalar[0])/pow(magnitude_C,3);
-//      return ( Myy );
-//      }else{
-//      return (0.0);
-//    }
-// }
+double LESPremixed2D_pState::M_xx(const LESPremixed2D_pState &dWdx,
+                                  const LESPremixed2D_pState &dWdy,
+                                  const LESPremixed2D_pState &d_dWdx_dx,
+                                  const LESPremixed2D_pState &d_dWdx_dy,
+                                  const LESPremixed2D_pState &d_dWdy_dy) const {
+    double Mxx, magnitude_C;
+    magnitude_C = sqrt(sqr(dWdx.scalar[0])+sqr(dWdy.scalar[0]));
+    if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) { 
+    Mxx = -d_dWdx_dx.scalar[0]/magnitude_C+dWdx.scalar[0]*(dWdx.scalar[0]*d_dWdx_dx.scalar[0]+dWdy.scalar[0]*d_dWdx_dy.scalar[0])/pow(magnitude_C,3);
+    return ( Mxx );
+   }else{
+    return (0.0);
+   }
+}
 
-// double LESPremixed2D_pState::Resolved_Curvature(const LESPremixed2D_pState &dWdx,
-//                                                 const LESPremixed2D_pState &dWdy,
-//                                                 const LESPremixed2D_pState &d_dWdx_dx,
-//                                                 const LESPremixed2D_pState &d_dWdx_dy,
-//                                                 const LESPremixed2D_pState &d_dWdy_dy) const {
-//    double tau_fsd, Mxx, Myy, resolved_curvature_xx, resolved_curvature_yy;
-//    tau_fsd = HeatRelease_Parameter();
-//    Mxx = M_xx(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
-//    Myy = M_yy(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
-
-//    if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//    resolved_curvature_xx = laminar_speed*(1.0+tau_fsd*scalar[0])*scalar[1]*rho*Mxx;
-//    resolved_curvature_yy = laminar_speed*(1.0+tau_fsd*scalar[0])*scalar[1]*rho*Myy;
-//    return ( resolved_curvature_xx + resolved_curvature_yy );
-//   }else{
-//    return (0.0);
-//   }
-// }
+double LESPremixed2D_pState::M_yy(const LESPremixed2D_pState &dWdx,
+                                  const LESPremixed2D_pState &dWdy,
+                                  const LESPremixed2D_pState &d_dWdx_dx,
+                                  const LESPremixed2D_pState &d_dWdx_dy,
+                                  const LESPremixed2D_pState &d_dWdy_dy) const {
+     double Myy, magnitude_C;
+     magnitude_C = sqrt(sqr(dWdx.scalar[0])+sqr(dWdy.scalar[0]));
+     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
+     Myy = -d_dWdy_dy.scalar[0]/magnitude_C+dWdy.scalar[0]*(dWdx.scalar[0]*d_dWdx_dy.scalar[0]+dWdy.scalar[0]*d_dWdy_dy.scalar[0])/pow(magnitude_C,3);
+     return ( Myy );
+     }else{
+     return (0.0);
+   }
+}
 
-// double LESPremixed2D_pState::Resolved_Propagation(const LESPremixed2D_pState &dWdx,
-//                                                   const LESPremixed2D_pState &dWdy,
-//                                                   const LESPremixed2D_pState &d_dWdx_dx,
-//                                                   const LESPremixed2D_pState &d_dWdx_dy,
-//                                                   const LESPremixed2D_pState &d_dWdy_dy) const {
+double LESPremixed2D_pState::Resolved_Curvature(const LESPremixed2D_pState &dWdx,
+                                                const LESPremixed2D_pState &dWdy,
+                                                const LESPremixed2D_pState &d_dWdx_dx,
+                                                const LESPremixed2D_pState &d_dWdx_dy,
+                                                const LESPremixed2D_pState &d_dWdy_dy) const {
+   double tau_fsd, Mxx, Myy, resolved_curvature_xx, resolved_curvature_yy;
+   tau_fsd = HeatRelease_Parameter();
+   Mxx = M_xx(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
+   Myy = M_yy(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
+
+   if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
+   resolved_curvature_xx = laminar_speed*(1.0+tau_fsd*scalar[0])*scalar[1]*rho*Mxx;
+   resolved_curvature_yy = laminar_speed*(1.0+tau_fsd*scalar[0])*scalar[1]*rho*Myy;
+   return ( resolved_curvature_xx + resolved_curvature_yy );
+  }else{
+   return (0.0);
+  }
+}
 
-//    if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//    return ( Resolved_Propagation_Curvature(dWdx,dWdy)-Resolved_Curvature(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy) );
-//   }else{
-//    return (0.0);
-//   }
-// }
+double LESPremixed2D_pState::Resolved_Propagation(const LESPremixed2D_pState &dWdx,
+                                                  const LESPremixed2D_pState &dWdy,
+                                                  const LESPremixed2D_pState &d_dWdx_dx,
+                                                  const LESPremixed2D_pState &d_dWdx_dy,
+                                                  const LESPremixed2D_pState &d_dWdy_dy) const {
 
-// double LESPremixed2D_pState::Resolved_Convection_Progvar (const LESPremixed2D_pState &dWdx,
-//                                                           const LESPremixed2D_pState &dWdy) const {
+   if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
+   return ( Resolved_Propagation_Curvature(dWdx,dWdy)-Resolved_Curvature(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy) );
+  }else{
+   return (0.0);
+  }
+}
 
-//     double resolved_convection_progvar_x, resolved_convection_progvar_y;
-//     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//     resolved_convection_progvar_x = -(dWdx.rho*v.x*scalar[0]+rho*dWdx.v.x*scalar[0]+rho*v.x*dWdx.scalar[0]);
-//     resolved_convection_progvar_y = -(dWdy.rho*v.y*scalar[0]+rho*dWdy.v.y*scalar[0]+rho*v.y*dWdy.scalar[0]);
-//     return( resolved_convection_progvar_x+resolved_convection_progvar_y );
-//    }else{
-//     return (0.0);
-//    }
-// }
+double LESPremixed2D_pState::Resolved_Convection_Progvar (const LESPremixed2D_pState &dWdx,
+                                                          const LESPremixed2D_pState &dWdy) const {
 
-// double LESPremixed2D_pState::Resolved_Convection_Fsd (const LESPremixed2D_pState &dWdx,
-//                                                       const LESPremixed2D_pState &dWdy) const {
+    double resolved_convection_progvar_x, resolved_convection_progvar_y;
+    if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
+    resolved_convection_progvar_x = -(dWdx.rho*v.x*scalar[0]+rho*dWdx.v.x*scalar[0]+rho*v.x*dWdx.scalar[0]);
+    resolved_convection_progvar_y = -(dWdy.rho*v.y*scalar[0]+rho*dWdy.v.y*scalar[0]+rho*v.y*dWdy.scalar[0]);
+    return( resolved_convection_progvar_x+resolved_convection_progvar_y );
+   }else{
+    return (0.0);
+   }
+}
 
-//     double resolved_convection_fsd_x, resolved_convection_fsd_y;
-//     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//     resolved_convection_fsd_x = -(dWdx.rho*v.x*scalar[1]+rho*dWdx.v.x*scalar[1]+rho*v.x*dWdx.scalar[1]);
-//     resolved_convection_fsd_y = -(dWdy.rho*v.y*scalar[1]+rho*dWdy.v.y*scalar[1]+rho*v.y*dWdy.scalar[1]);
-//     return( resolved_convection_fsd_x+resolved_convection_fsd_y );
-//    }else{
-//     return (0.0);
-//    }
-// }
+double LESPremixed2D_pState::Resolved_Convection_Fsd (const LESPremixed2D_pState &dWdx,
+                                                      const LESPremixed2D_pState &dWdy) const {
 
-// double LESPremixed2D_pState::NGT_Progvar (const LESPremixed2D_pState &dWdx,
-//                                           const LESPremixed2D_pState &dWdy) const {
-
-//     double tau_fsd, NGT_progvar_x, NGT_progvar_y;
-//     tau_fsd = HeatRelease_Parameter();
-//     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//     NGT_progvar_x = -tau_fsd*laminar_speed*(rho*(1-2*scalar[0])*dWdx.scalar[0]+scalar[0]*(1-scalar[0])*dWdx.rho);
-//     NGT_progvar_y = -tau_fsd*laminar_speed*(rho*(1-2*scalar[0])*dWdy.scalar[0]+scalar[0]*(1-scalar[0])*dWdy.rho);
-//     return ( NGT_progvar_x+NGT_progvar_y );
-//    }else{
-//     return (0.0);
-//    }
-// }
+    double resolved_convection_fsd_x, resolved_convection_fsd_y;
+    if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
+    resolved_convection_fsd_x = -(dWdx.rho*v.x*scalar[1]+rho*dWdx.v.x*scalar[1]+rho*v.x*dWdx.scalar[1]);
+    resolved_convection_fsd_y = -(dWdy.rho*v.y*scalar[1]+rho*dWdy.v.y*scalar[1]+rho*v.y*dWdy.scalar[1]);
+    return( resolved_convection_fsd_x+resolved_convection_fsd_y );
+   }else{
+    return (0.0);
+   }
+}
 
-// double LESPremixed2D_pState::NGT_Fsd (const LESPremixed2D_pState &dWdx,
-//                                       const LESPremixed2D_pState &dWdy,
-//                                       const LESPremixed2D_pState &d_dWdx_dx,
-//                                       const LESPremixed2D_pState &d_dWdx_dy,
-//                                       const LESPremixed2D_pState &d_dWdy_dy) const {
-
-//     double tau_fsd, Mx, My, Mxx, Myy, NGT_fsd_x, NGT_fsd_y;
-//     tau_fsd = HeatRelease_Parameter();
-//     Mx = M_x(dWdx,dWdy);
-//     My = M_y(dWdx,dWdy);
-//     Mxx = M_xx(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
-//     Myy = M_yy(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
-//     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//     NGT_fsd_x = -tau_fsd*laminar_speed*((0.5-scalar[0])*(scalar[1]*Mx*dWdx.rho+rho*Mx*dWdx.scalar[1]+rho*scalar[1]*Mxx)-rho*scalar[1]*Mx*dWdx.scalar[0]);
-//     NGT_fsd_y = -tau_fsd*laminar_speed*((0.5-scalar[0])*(scalar[1]*My*dWdy.rho+rho*My*dWdy.scalar[1]+rho*scalar[1]*Myy)-rho*scalar[1]*My*dWdy.scalar[0]);
-//     return ( NGT_fsd_x+NGT_fsd_y );
-//    }else{
-//     return (0.0);
-//    } 
-// }
+double LESPremixed2D_pState::NGT_Progvar (const LESPremixed2D_pState &dWdx,
+                                          const LESPremixed2D_pState &dWdy) const {
 
-// double LESPremixed2D_pState::SFS_Diffusion_Progvar (const LESPremixed2D_pState &dWdx,
-//                                                     const LESPremixed2D_pState &dWdy,
-//                                                     const LESPremixed2D_pState &d_dWdx_dx,
-//                                                     const LESPremixed2D_pState &d_dWdx_dy,
-//                                                     const LESPremixed2D_pState &d_dWdy_dy,
-//                                                     const int &Flow_Type) const {
-//     double grad_mu_x, grad_mu_y, sfs_diffusion_progvar_x, sfs_diffusion_progvar_y, Schmidt_sfs = 1.0;
-//     grad_mu_x = sqr(CS_constant*filter_width))*sqrt(2)*(d_dWdx_dx.v.x+0.5*(d_dWdx_dy.v.x+d_dWdx_dx.v.y)+d_dWdx_dy.v.y);
-//     grad_mu_y = sqr(CS_constant*filter_width)*sqrt(2)*(d_dWdx_dy.v.x+0.5*(d_dWdy_dy.v.x+d_dWdx_dy.v.y)+d_dWdy_dy.v.y);
-//     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//     sfs_diffusion_progvar_x = (eddy_viscosity(dWdx,dWdy,Flow_Type)*dWdx.scalar[0]*dWdx.rho+rho*dWdx.scalar[0]*grad_mu_x+rho*eddy_viscosity(dWdx,dWdy,Flow_Type)*d_dWdx_dx.scalar[0])/Schmidt_sfs;
-//     sfs_diffusion_progvar_y = (eddy_viscosity(dWdx,dWdy,Flow_Type)*dWdy.scalar[0]*dWdy.rho+rho*dWdy.scalar[0]*grad_mu_y+rho*eddy_viscosity(dWdx,dWdy,Flow_Type)*d_dWdy_dy.scalar[0])/Schmidt_sfs;
-//     return ( sfs_diffusion_progvar_x+sfs_diffusion_progvar_y );
-//    }else{
-//     return (0.0);
-//    }
-//  }
-
-// double LESPremixed2D_pState::SFS_Diffusion_Fsd (const LESPremixed2D_pState &dWdx,
-//                                                 const LESPremixed2D_pState &dWdy,
-//                                                 const LESPremixed2D_pState &d_dWdx_dx,
-//                                                 const LESPremixed2D_pState &d_dWdx_dy,
-//                                                 const LESPremixed2D_pState &d_dWdy_dy,
-//                                                 const int &Flow_Type) const {
-//      double grad_mu_x, grad_mu_y, sfs_diffusion_fsd_x, sfs_diffusion_fsd_y, Schmidt_sfs = 1.0;
-//      grad_mu_x = sqr(CS_constant*filter_width)*sqrt(2)*(d_dWdx_dx.v.x+0.5*(d_dWdx_dy.v.x+d_dWdx_dx.v.y)+d_dWdx_dy.v.y);
-//      grad_mu_y = sqr(CS_constant*filter_width)*sqrt(2)*(d_dWdx_dy.v.x+0.5*(d_dWdy_dy.v.x+d_dWdx_dy.v.y)+d_dWdy_dy.v.y);
-//      if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//        sfs_diffusion_fsd_x = (eddy_viscosity(dWdx,dWdy,Flow_Type)*dWdx.scalar[1]*dWdx.rho+rho*dWdx.scalar[1]*grad_mu_x+rho*eddy_viscosity(dWdx,dWdy,Flow_Type)*d_dWdx_dx.scalar[1])/Schmidt_sfs;
-//      sfs_diffusion_fsd_y = (eddy_viscosity(dWdx,dWdy,Flow_Type)*dWdy.scalar[1]*dWdy.rho+rho*dWdy.scalar[1]*grad_mu_y+rho*eddy_viscosity(dWdx,dWdy,Flow_Type)*d_dWdy_dy.scalar[1])/Schmidt_sfs;
-//      return ( sfs_diffusion_fsd_x+sfs_diffusion_fsd_y );
-//     }else{
-//      return (0.0);
-//     }
-//  }
-
-// double LESPremixed2D_pState::Heat_Release_Strain (const LESPremixed2D_pState &dWdx,
-//                                                   const LESPremixed2D_pState &dWdy,
-//                                                   const LESPremixed2D_pState &d_dWdx_dx,
-//                                                   const LESPremixed2D_pState &d_dWdx_dy,
-//                                                   const LESPremixed2D_pState &d_dWdy_dy) const {
-//      double tau_fsd, Mx, My, Mxx, Myy, heat_release_strain_xx, heat_release_strain_yy;
-//      tau_fsd = HeatRelease_Parameter();
-//      Mx = M_x(dWdx,dWdy);
-//      My = M_y(dWdx,dWdy);
-//      Mxx = M_xx(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
-//      Myy = M_yy(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
-//      if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
-//      heat_release_strain_xx = (0.5-scalar[0])*tau_fsd*laminar_speed*scalar[1]*rho*Mxx;
-//      heat_release_strain_yy = (0.5-scalar[0])*tau_fsd*laminar_speed*scalar[1]*rho*Myy;
-//      return ( heat_release_strain_xx + heat_release_strain_yy );
-//     }else{
-//      return (0.0);
-//     }
-// }
+    double tau_fsd, NGT_progvar_x, NGT_progvar_y;
+    tau_fsd = HeatRelease_Parameter();
+    if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
+    NGT_progvar_x = -tau_fsd*laminar_speed*(rho*(1-2*scalar[0])*dWdx.scalar[0]+scalar[0]*(1-scalar[0])*dWdx.rho);
+    NGT_progvar_y = -tau_fsd*laminar_speed*(rho*(1-2*scalar[0])*dWdy.scalar[0]+scalar[0]*(1-scalar[0])*dWdy.rho);
+    return ( NGT_progvar_x+NGT_progvar_y );
+   }else{
+    return (0.0);
+   }
+}
 
-// double LESPremixed2D_pState::Net_Rate_Change_Progvar (const LESPremixed2D_pState &dWdx,
-//                                                       const LESPremixed2D_pState &dWdy,
-//                                                       const LESPremixed2D_pState &d_dWdx_dx,
-//                                                       const LESPremixed2D_pState &d_dWdx_dy,
-//                                                       const LESPremixed2D_pState &d_dWdy_dy,
-//                                                       const int &Flow_Type) const {
-//      return(  Resolved_Convection_Progvar(dWdx,dWdy)
-//               +SFS_Diffusion_Progvar(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy,Flow_Type)
-//               +Reaction_Rate_Fsd(dWdx,dWdy) );
-// }
-           
-
-// double LESPremixed2D_pState::Net_Rate_Change_Fsd (const LESPremixed2D_pState &dWdx,
-//                                                   const LESPremixed2D_pState &dWdy,
-//                                                   const LESPremixed2D_pState &d_dWdx_dx,
-//                                                   const LESPremixed2D_pState &d_dWdx_dy,
-//                                                   const LESPremixed2D_pState &d_dWdy_dy,
-//                                                   const int &Flow_Type) const {
-//     return(  Resolved_Convection_Fsd(dWdx,dWdy)
-//             +SFS_Diffusion_Fsd(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy,Flow_Type)
-//             +Resolved_Strain(dWdx,dWdy)
-//             +Resolved_Propagation_Curvature(dWdx,dWdy)
-//             +SFS_Strain(dWdx,dWdy,Flow_Type)
-//             +SFS_Curvature(dWdx,dWdy,Flow_Type) );
-// }
+double LESPremixed2D_pState::NGT_Fsd (const LESPremixed2D_pState &dWdx,
+                                      const LESPremixed2D_pState &dWdy,
+                                      const LESPremixed2D_pState &d_dWdx_dx,
+                                      const LESPremixed2D_pState &d_dWdx_dy,
+                                      const LESPremixed2D_pState &d_dWdy_dy) const {
 
-double LESPremixed2D_pState::K_equ_sources(const LESPremixed2D_pState &dWdx,
-                                           const LESPremixed2D_pState &dWdy,
-                                           const int &Flow_Type) const {
+    double tau_fsd, Mx, My, Mxx, Myy, NGT_fsd_x, NGT_fsd_y;
+    tau_fsd = HeatRelease_Parameter();
+    Mx = M_x(dWdx,dWdy);
+    My = M_y(dWdx,dWdy);
+    Mxx = M_xx(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
+    Myy = M_yy(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
+    if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
+    NGT_fsd_x = -tau_fsd*laminar_speed*((0.5-scalar[0])*(scalar[1]*Mx*dWdx.rho+rho*Mx*dWdx.scalar[1]+rho*scalar[1]*Mxx)-rho*scalar[1]*Mx*dWdx.scalar[0]);
+    NGT_fsd_y = -tau_fsd*laminar_speed*((0.5-scalar[0])*(scalar[1]*My*dWdy.rho+rho*My*dWdy.scalar[1]+rho*scalar[1]*Myy)-rho*scalar[1]*My*dWdy.scalar[0]);
+    return ( NGT_fsd_x+NGT_fsd_y );
+   }else{
+    return (0.0);
+   } 
+}
 
-  double production, dissipation, source;
-  double div_v, sfs_stress_trace;
-  Tensor2D strain_rate;
-  Tensor2D lambda;
-  
-  /***************** Strain rate (+ dilatation) **********************/ 
-//   div_v = dWdx.v.x + dWdy.v.y;
-//   strain_rate.xx = dWdx.v.x - div_v/THREE;
-//   strain_rate.xy = HALF*(dWdx.v.y + dWdy.v.x);
-//   strain_rate.yy = dWdy.v.y - div_v/THREE;
-//   strain_rate.zz = -(strain_rate.xx + strain_rate.yy);
-    
-//   sfs_stress_trace = TWO*rho*k();
-     
-//   lambda.xx = TWO*eddy_viscosity(dWdx,dWdy,Flow_Type)*strain_rate.xx 
-//               - sfs_stress_trace/THREE;
-//   lambda.yy = TWO*eddy_viscosity(dWdx,dWdy,Flow_Type)*strain_rate.yy
-//               - sfs_stress_trace/THREE;
-//   lambda.xy = TWO*eddy_viscosity(dWdx,dWdy,Flow_Type)*strain_rate.xy;
-//   lambda.zz = TWO*eddy_viscosity(dWdx,dWdy,Flow_Type)*strain_rate.zz 
-//               - sfs_stress_trace/THREE;
-//   production = lambda.xx*strain_rate.xx + 
-//                lambda.xy*strain_rate.xy + 
-//                lambda.yy*strain_rate.yy;
-//   dissipation = CEPS_CONSTANT*rho*pow(k(), 3.0/2.0)/filter_width;
-//   source = production - dissipation;
-//   return(source);
+double LESPremixed2D_pState::Heat_Release_Strain (const LESPremixed2D_pState &dWdx,
+                                                  const LESPremixed2D_pState &dWdy,
+                                                  const LESPremixed2D_pState &d_dWdx_dx,
+                                                  const LESPremixed2D_pState &d_dWdx_dy,
+                                                  const LESPremixed2D_pState &d_dWdy_dy) const {
+     double tau_fsd, Mx, My, Mxx, Myy, heat_release_strain_xx, heat_release_strain_yy;
+     tau_fsd = HeatRelease_Parameter();
+     Mx = M_x(dWdx,dWdy);
+     My = M_y(dWdx,dWdy);
+     Mxx = M_xx(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
+     Myy = M_yy(dWdx,dWdy,d_dWdx_dx,d_dWdx_dy,d_dWdy_dy);
+     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO ) {
+     heat_release_strain_xx = (0.5-scalar[0])*tau_fsd*laminar_speed*scalar[1]*rho*Mxx;
+     heat_release_strain_yy = (0.5-scalar[0])*tau_fsd*laminar_speed*scalar[1]*rho*Myy;
+     return ( heat_release_strain_xx + heat_release_strain_yy );
+    }else{
+     return (0.0);
+    }
 }
 
+
 /*************************************************
          Premixed combustion
 *************************************************/
@@ -2922,7 +2811,7 @@ LESPremixed2D_cState LESPremixed2D_pState::Sa_viscous(const LESPremixed2D_pState
      Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K) {
 
     //Turbulence model eddy viscosity
-    mut = mu_t(strain_rate); 
+    mut = mu_t(strain_rate,Flow_Type); 
     Dm_t = Dm_turb(mut);
 
     theta = - mut*Cp()/Pr_turb()*grad_T;
@@ -2933,7 +2822,7 @@ LESPremixed2D_cState LESPremixed2D_pState::Sa_viscous(const LESPremixed2D_pState
       theta.y -= rhohsDs*dWdy.spec[i].c;
     }
 
-    SFS_Stress(strain_rate);
+    SFS_Stress(strain_rate,Flow_Type);
   
   } 
 
@@ -3054,9 +2943,9 @@ LESPremixed2D_cState LESPremixed2D_pState::S_turbulence_model(const LESPremixed2
   double production, dissipation;
   LESPremixed2D_cState Temp; Temp.Vacuum();
 
-  if ( Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
+  if ( Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
 
     if ( scalar[0] < 0.99 && scalar[0] > 0.01 && dWdx.scalar[0] != ZERO && dWdy.scalar[0] != ZERO) {
 
@@ -3081,9 +2970,14 @@ LESPremixed2D_cState LESPremixed2D_pState::S_turbulence_model(const LESPremixed2
    if (Temp.rhoscalar[0] < ZERO ) { Temp.rhoscalar[0] = ZERO; }
    if (Temp.rhoscalar[1] < ZERO ) { Temp.rhoscalar[1] = ZERO; }
 
-   if ( Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+   if ( Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
 
-    Temp.rhoscalar[2] = K_equ_sources(dWdx,dWdy,Flow_Type);
+  production = lambda.xx*dWdx.v.x + lambda.xy*(dWdy.v.x + dWdx.v.y) + 
+               lambda.yy*dWdy.v.y;
+
+  dissipation = rho*(SFSmodel.CEPS_coef)*pow(k(), 1.5)/filter_width;
+ 
+  Temp.rhoscalar[2] = production - dissipation;
 
       }
      }
@@ -3504,8 +3398,16 @@ double LESPremixed2D_cState::a(void) const{
 /**************************************************
   Turbulence model related parameters
 ***************************************************/
-double LESPremixed2D_cState::mu_t(const Tensor2D &strain_rate) const{
-  double mut = rho*SFSmodel.eddy_viscosity_Smagorinsky(strain_rate, filter_width);
+double LESPremixed2D_cState::mu_t(const Tensor2D &strain_rate,
+                                  const int &Flow_Type) const{
+  double mut;
+  if(Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
+     Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY) { 
+  mut = rho*SFSmodel.eddy_viscosity_Smagorinsky(strain_rate, filter_width);
+  }else if (Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
+            Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
+    mut = rho*SFSmodel.eddy_viscosity_k(k(), filter_width);
+  }
 #ifdef THICKENED_FLAME_ON
   return (flame.WF*flame.TF)*mut;
 #else
@@ -3746,7 +3648,7 @@ LESPremixed2D_cState LESPremixed2D_cState::Viscous_Flux_x(const LESPremixed2D_pS
   if (Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
       Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K) {
     Tensor2D strain_rate = Strain_Rate(dWdx,dWdy, Flow_Type, Axisymmetric, X);
-    double mut = mu_t(strain_rate); 
+    double mut = mu_t(strain_rate,Flow_Type); 
     double Dm_t = Dm_turb(mut);
     
     temp[2] += lambda.xx + 2.0*rhok()/3.0; 
@@ -3762,10 +3664,10 @@ LESPremixed2D_cState LESPremixed2D_cState::Viscous_Flux_x(const LESPremixed2D_pS
     }
   }
  
-  if (Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-      Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
+  if (Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+      Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
     Tensor2D strain_rate = Strain_Rate(dWdx,dWdy, Flow_Type, Axisymmetric, X);
-    double mut = mu_t(strain_rate); 
+    double mut = mu_t(strain_rate,Flow_Type); 
     double Dm_t = Dm_turb(mut);
     double Schmidt_sfs = ONE ;
     
@@ -3775,8 +3677,8 @@ LESPremixed2D_cState LESPremixed2D_cState::Viscous_Flux_x(const LESPremixed2D_pS
     temp[5] = mut*dWdx.scalar[0]/Schmidt_sfs;
     temp[6] = mut*dWdx.scalar[1]/Schmidt_sfs;
 
-      if (Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
-	temp[7] = (mu()+mut)*dWdx.scalar[2]/Pr_turb();
+      if (Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
+	temp.rhoscalar[2] = (mu()+mut)*dWdx.scalar[2]/Pr_turb();
       }
   }
 
@@ -3806,7 +3708,7 @@ LESPremixed2D_cState LESPremixed2D_cState::Viscous_Flux_y(const LESPremixed2D_pS
   if (Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
       Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K) {
     Tensor2D strain_rate = Strain_Rate(dWdx,dWdy, Flow_Type, Axisymmetric, X);
-    double mut = mu_t(strain_rate); 
+    double mut = mu_t(strain_rate,Flow_Type); 
     double Dm_t = Dm_turb(mut);
 
     temp[2] += lambda.xy; 
@@ -3824,10 +3726,10 @@ LESPremixed2D_cState LESPremixed2D_cState::Viscous_Flux_y(const LESPremixed2D_pS
     }
   }
 
-  if (Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-      Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
+  if (Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+      Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
     Tensor2D strain_rate = Strain_Rate(dWdx,dWdy, Flow_Type, Axisymmetric, X);
-    double mut = mu_t(strain_rate); 
+    double mut = mu_t(strain_rate,Flow_Type); 
     double Dm_t = Dm_turb(mut);
     double Schmidt_sfs = ONE ;
     
@@ -3837,8 +3739,8 @@ LESPremixed2D_cState LESPremixed2D_cState::Viscous_Flux_y(const LESPremixed2D_pS
     temp[5] = mut*dWdy.scalar[0]/Schmidt_sfs;
     temp[6] = mut*dWdy.scalar[1]/Schmidt_sfs;
 
-      if (Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
-	temp[7] = (mu()+mut)*dWdy.scalar[2]/Pr_turb();
+      if (Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
+	temp.rhoscalar[2] = (mu()+mut)*dWdy.scalar[2]/Pr_turb();
       }
   }
 
@@ -4768,12 +4670,13 @@ LESPremixed2D_pState RoeAverage(const LESPremixed2D_pState &Wl,
       for(int i=0; i<Wl.nscal; i++) Temp.scalar[i] = (srhol*Wl.scalar[i] + srhor*Wr.scalar[i])/(srhol+srhor);
     }
     
-//    if(Temp.Scal_sys.scalar_flag != LES_FSD_C &&
-//       Temp.Scal_sys.scalar_flag != LES_FSD_C_K) {
+//     if(Temp.Scal_sys.scalar_flag != LES_C_FSD &&
+//        Temp.Scal_sys.scalar_flag != LES_C_FSD_K) {
     for(int i=0; i<Wl.ns; ++i){
       Temp.spec[i].c = (srhol*Wl.spec[i].c + srhor*Wr.spec[i].c)/(srhol+srhor);
     }
-    //   }
+    //    }
+
     Ha = (srhol*Hl+srhor*Hr)/(srhol+srhor);
     ha = Ha - HALF*(sqr(Temp.v.x)+sqr(Temp.v.y));
     ha -= 5.0*Temp.k()/3.0;
@@ -4805,12 +4708,7 @@ LESPremixed2D_cState FluxHLLE_x(const LESPremixed2D_pState &Wl,
     double wavespeed_l, wavespeed_r;
     LESPremixed2D_pState Wa, lambdas_l, lambdas_r, lambdas_a;
     LESPremixed2D_cState Flux, dUrl;
-   if(Wa.Scal_sys.scalar_flag != LES_FSD_C &&
-      Wa.Scal_sys.scalar_flag != LES_FSD_C_K) {
-    int NUM_VAR_LESPREMIXED2D = Wa.NUM_VAR_LESPREMIXED2D;
-   }else{
-    int NUM_VAR_LESPREMIXED2D = Wa.NUM_VAR_LESPREMIXED2D - Wa.ns;
-   }
+    int NUM_VAR_LESPREMIXED2D = Wl.NUM_VAR_LESPREMIXED2D;
 
     /* Evaluate the Roe-average primitive solution state. */   
     Wa = RoeAverage(Wl, Wr);
@@ -4952,12 +4850,7 @@ LESPremixed2D_cState FluxLinde(const LESPremixed2D_pState &Wl,
     double wavespeed_l, wavespeed_r, wavespeed_m, rhoa, ca, dU, alpha;
     LESPremixed2D_pState Wa, lambdas_l, lambdas_r, lambdas_a;
     LESPremixed2D_cState Flux, dFrl, dUrl, dFwave;
-   if(Wa.Scal_sys.scalar_flag != LES_FSD_C &&
-      Wa.Scal_sys.scalar_flag != LES_FSD_C_K) {
-    int NUM_VAR_LESPREMIXED2D = Wa.NUM_VAR_LESPREMIXED2D;
-   }else{
-    int NUM_VAR_LESPREMIXED2D = Wa.NUM_VAR_LESPREMIXED2D - Wa.ns;
-   }
+    int NUM_VAR_LESPREMIXED2D = Wl.NUM_VAR_LESPREMIXED2D;
 
     /* Evaluate the Roe-average primitive solution state. */   
     Wa = RoeAverage(Wl, Wr);
@@ -5128,13 +5021,7 @@ Vector2D HLLE_wavespeeds(const LESPremixed2D_pState &Wl,
 
     Vector2D wavespeed;
     LESPremixed2D_pState Wa_n, lambdas_l, lambdas_r, lambdas_a, Wl_n, Wr_n;  
-   if(Wl_n.Scal_sys.scalar_flag != LES_FSD_C &&
-      Wl_n.Scal_sys.scalar_flag != LES_FSD_C_K) {
-    int NUM_VAR_LESPREMIXED2D = Wl_n.NUM_VAR_LESPREMIXED2D;
-   }else{
-    int NUM_VAR_LESPREMIXED2D = Wl_n.NUM_VAR_LESPREMIXED2D - Wl_n.ns;
-   }
-
+    int NUM_VAR_LESPREMIXED2D = (Wl.NUM_VAR_LESPREMIXED2D );
     /* Use rotated values to calculate eignvalues */
     Wl_n = Rotate(Wl, norm_dir);
     Wr_n = Rotate(Wr, norm_dir);
@@ -5194,14 +5081,7 @@ LESPremixed2D_pState WaveSpeedNeg(const LESPremixed2D_pState &lambdas_a,
 				  const LESPremixed2D_pState &lambdas_l,
 				  const LESPremixed2D_pState &lambdas_r) {
   LESPremixed2D_pState NEW;   
-  int NUM_VAR_LESPREMIXED2D;
-   if(NEW.Scal_sys.scalar_flag != LES_FSD_C &&
-      NEW.Scal_sys.scalar_flag != LES_FSD_C_K) {
-    NUM_VAR_LESPREMIXED2D = lambdas_a.NUM_VAR_LESPREMIXED2D;
-   }else{
-    NUM_VAR_LESPREMIXED2D = lambdas_a.NUM_VAR_LESPREMIXED2D - lambdas_a.ns;
-   }
-  for(int i=1; i<=NUM_VAR_LESPREMIXED2D; ++i){
+  for(int i=1; i<=lambdas_a.NUM_VAR_LESPREMIXED2D; ++i){
      NEW[i] = HALF*(lambdas_a[i]-fabs(lambdas_a[i]));
    }
    return(NEW);
@@ -5218,14 +5098,7 @@ LESPremixed2D_pState WaveSpeedAbs(const LESPremixed2D_pState &lambdas_a,
 				  const LESPremixed2D_pState &lambdas_l,
 				  const LESPremixed2D_pState &lambdas_r) {
    LESPremixed2D_pState NEW;   
-   int NUM_VAR_LESPREMIXED2D;
-   if(NEW.Scal_sys.scalar_flag != LES_FSD_C &&
-      NEW.Scal_sys.scalar_flag != LES_FSD_C_K) {
-      NUM_VAR_LESPREMIXED2D = lambdas_a.NUM_VAR_LESPREMIXED2D;
-   }else{
-      NUM_VAR_LESPREMIXED2D = lambdas_a.NUM_VAR_LESPREMIXED2D - lambdas_a.ns;
-   }
-   for(int i=1; i<=NUM_VAR_LESPREMIXED2D; ++i){
+   for(int i=1; i<=lambdas_a.NUM_VAR_LESPREMIXED2D; ++i){
      NEW[i] = fabs(lambdas_a[i]);
    }
    return(NEW);
@@ -5253,13 +5126,13 @@ LESPremixed2D_pState HartenFixPos(const LESPremixed2D_pState &lambdas_a,
       NEW.scalar[i-5] = HALF*(lambdas_a[i]+fabs(lambdas_a[i])); //fabs(lambdas_a[i]); ??????
     }
   }
-    
-   if(NEW.Scal_sys.scalar_flag != LES_FSD_C &&
-      NEW.Scal_sys.scalar_flag != LES_FSD_C_K) {
+
+//     if(NEW.Scal_sys.scalar_flag != LES_C_FSD &&
+//        NEW.Scal_sys.scalar_flag != LES_C_FSD_K) {
   for( int i=(NEW.NUM_VAR_LESPREMIXED2D-NEW.ns+1); i<=NEW.NUM_VAR_LESPREMIXED2D; ++i){
     NEW.spec[i-(NEW.NUM_VAR_LESPREMIXED2D-NEW.ns+1)].c = HALF*(lambdas_a[i]+fabs(lambdas_a[i]));
   }
- }  
+  //    }
   return (NEW);
 }
 
@@ -5279,19 +5152,17 @@ LESPremixed2D_pState HartenFixNeg(const LESPremixed2D_pState &lambdas_a,
   NEW.v.x = HALF*(lambdas_a[2]-fabs(lambdas_a[2]));
   NEW.v.y = HALF*(lambdas_a[3]-fabs(lambdas_a[3]));
   NEW.p = HartenFixNeg(lambdas_a[4],lambdas_l[4],lambdas_r[4]);
-
   if(NEW.nscal){
     for(int i=5; i<=(NEW.NUM_VAR_LESPREMIXED2D-NEW.ns); ++i){
       NEW.scalar[i-5] = HALF*(lambdas_a[i]-fabs(lambdas_a[i]));  // fabs(lambdas_a[i]) ???????
     }
   }
-  
-   if(NEW.Scal_sys.scalar_flag != LES_FSD_C &&
-      NEW.Scal_sys.scalar_flag != LES_FSD_C_K) {
+//     if(NEW.Scal_sys.scalar_flag != LES_C_FSD &&
+//        NEW.Scal_sys.scalar_flag != LES_C_FSD_K) {
   for( int i=(NEW.NUM_VAR_LESPREMIXED2D-NEW.ns+1); i<=NEW.NUM_VAR_LESPREMIXED2D; ++i){
     NEW.spec[i-(NEW.NUM_VAR_LESPREMIXED2D-NEW.ns+1)].c = HALF*(lambdas_a[i]-fabs(lambdas_a[i]));
   }
-   }
+  //    }
   return (NEW);
 }
 /********************************************************
@@ -5317,12 +5188,12 @@ LESPremixed2D_pState HartenFixAbs(const LESPremixed2D_pState &lambdas_a,
     }
   }
   
-   if(NEW.Scal_sys.scalar_flag != LES_FSD_C &&
-      NEW.Scal_sys.scalar_flag != LES_FSD_C_K) {
+//     if(NEW.Scal_sys.scalar_flag != LES_C_FSD &&
+//        NEW.Scal_sys.scalar_flag != LES_C_FSD_K) {
   for( int i=(NEW.NUM_VAR_LESPREMIXED2D-NEW.ns+1); i<=NEW.NUM_VAR_LESPREMIXED2D; ++i){
     NEW.spec[i-(NEW.NUM_VAR_LESPREMIXED2D-NEW.ns+1)].c = fabs(lambdas_a[i]);
   }
-   }
+  //    }
   return (NEW);
 }
 /*********************************************************
@@ -5370,14 +5241,14 @@ LESPremixed2D_cState FluxRoe_x(const LESPremixed2D_pState &Wl,
 //       Flux += Flux_dissipation;
 //       /////////////////////////////////
 
-     int NUM;
-     if(flow_type_flag == FLOWTYPE_LAMINAR_FSD ||
-        flow_type_flag == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-        flow_type_flag == FLOWTYPE_TURBULENT_LES_FSD_K ) {
- 	NUM = Wl.NUM_VAR_LESPREMIXED2D-Wl.ns;
-      }else{
-        NUM = Wl.NUM_VAR_LESPREMIXED2D;
-      }
+      int NN;
+  if(flow_type_flag == FLOWTYPE_LAMINAR_C_FSD ||
+     flow_type_flag == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+     flow_type_flag == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
+	NN = Wl.NUM_VAR_LESPREMIXED2D-Wl.ns+1;
+  }else{
+        NN = Wl.NUM_VAR_LESPREMIXED2D;
+  }
 
       /* Determine the intermediate state flux. */
       if (Wa.v.x >= ZERO) {
@@ -5385,8 +5256,7 @@ LESPremixed2D_cState FluxRoe_x(const LESPremixed2D_pState &Wl,
         wavespeeds = HartenFixNeg(lambdas_a,
                                   lambdas_l,
                                   lambdas_r);
-	
-        for (int i=1 ; i < NUM; ++i) {
+        for (int i=1 ; i < NN; ++i) {
 	  if (wavespeeds[i] < ZERO) {
  	    Flux += wavespeeds[i]*(Wa.lp_x(i)*dWrl)*Wa.rc_x(i);
 	  }
@@ -5396,13 +5266,12 @@ LESPremixed2D_cState FluxRoe_x(const LESPremixed2D_pState &Wl,
         wavespeeds = HartenFixPos(lambdas_a,
                                   lambdas_l,
                                   lambdas_r);
-        for (int i=1; i < NUM; ++i) {
+       for (int i=1; i < NN; ++i) {
 	  if (wavespeeds[i] > ZERO) {
 	    Flux -= wavespeeds[i]*(Wa.lp_x(i)*dWrl)*Wa.rc_x(i);
           }
         } 
       } 
-   
       /******* LOW MACH NUMBER PRECONDITIONING ********************/
       /* Evaluate the left, right, and average state eigenvalues. */
     } else if(Preconditioning){
@@ -5422,31 +5291,31 @@ LESPremixed2D_cState FluxRoe_x(const LESPremixed2D_pState &Wl,
       wavespeeds = HartenFixAbs(lambdas_a,
 				lambdas_l,
 				lambdas_r);
-          
-     int NUM;
-     if(flow_type_flag == FLOWTYPE_LAMINAR_FSD ||
-        flow_type_flag == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-        flow_type_flag == FLOWTYPE_TURBULENT_LES_FSD_K ) {
- 	NUM = Wl.NUM_VAR_LESPREMIXED2D-Wl.ns;
+                
+      int NN;
+  if(flow_type_flag == FLOWTYPE_LAMINAR_C_FSD ||
+     flow_type_flag == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+     flow_type_flag == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
+	NN = Wa.NUM_VAR_LESPREMIXED2D-Wa.ns+1;
       }else{
-        NUM = Wl.NUM_VAR_LESPREMIXED2D;
-      }
-
-      DenseMatrix P(NUM,NUM);     //COULD BE STORED IN CLASS AS STATIC AND REUSED REDUCING OVERHEAD???
+        NN = Wa.NUM_VAR_LESPREMIXED2D;
+     }
+      
+      DenseMatrix P(NN-1,NN-1);     //COULD BE STORED IN CLASS AS STATIC AND REUSED REDUCING OVERHEAD???
       /* Evaluate the low-Mach-number local preconditioner for the Roe-averaged state. */  
     
       Wa.Low_Mach_Number_Preconditioner(P,flow_type_flag,deltax);
-                                                                                     
+      
       /* Determine the intermediate state flux. */                                                
       Flux = HALF*(Wl.Fx()+Wr.Fx()); 
       LESPremixed2D_cState Flux_dissipation(ZERO);   
-    
-      for ( int i = 1 ; i < NUM ; ++i ) {
+
+      for ( int i = 1 ; i < NN ; ++i ) {
 	Flux_dissipation -= HALF*wavespeeds[i]*(Wa.lp_x_precon(i,MR2a)*dWrl)*Wa.rc_x_precon(i,MR2a);
       }
   
-      for ( int i = 1 ; i < NUM ; ++i ) {
-	for ( int j = 1 ; j < NUM ; ++j ) {
+      for ( int i = 1 ; i < NN ; ++i ) {
+	for ( int j = 1 ; j < NN ; ++j ) {
 	  Flux[i] += P(i-1,j-1)*Flux_dissipation[j]; // Add preconditioned upwind dissipation flux.
 	} 
       } 
@@ -5629,10 +5498,12 @@ LESPremixed2D_cState FluxAUSMplus_up(const LESPremixed2D_pState &Wl,
       for(int i=0; i<Wl.nscal; ++i) Convected_Quantities.rhoscalar[i] = Wl.scalar[i];
     }
 
+    if(Wl.Scal_sys.scalar_flag != LES_C_FSD &&
+       Wl.Scal_sys.scalar_flag != LES_C_FSD_K) {
     for(int i=0; i<Wl.ns; ++i){
       Convected_Quantities.rhospec[i].c = Wl.spec[i].c;
     }
-    
+    }    
   } else {
     Convected_Quantities.rho = ONE;
     Convected_Quantities.rhov.x = Wr.v.x; 
@@ -5646,7 +5517,6 @@ LESPremixed2D_cState FluxAUSMplus_up(const LESPremixed2D_pState &Wl,
     for(int i=0; i<Wr.ns; ++i){
       Convected_Quantities.rhospec[i].c = Wr.spec[i].c;
     }
-
   } //end if
 
   Flux = mass_flux_half*Convected_Quantities;
@@ -5832,10 +5702,10 @@ LESPremixed2D_cState Viscous_Flux_n(LESPremixed2D_pState &W,
   //Thermal conduction, q = - kappa * grad(T)
   if (Flow_Type == FLOWTYPE_TURBULENT_LES_TF_SMAGORINSKY ||
       Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
-      Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-      Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) {
+      Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+      Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) {
  
-    double mut = W.mu_t(strain_rate);
+    double mut = W.mu_t(strain_rate,Flow_Type);
     double Dm_t = W.Dm_turb(mut);
 
     U.theta = - mut*W.Cp()/W.Pr_turb()*grad_T;
@@ -5846,7 +5716,7 @@ LESPremixed2D_cState Viscous_Flux_n(LESPremixed2D_pState &W,
     }
     
     //SFS stresses 
-    W.SFS_Stress(strain_rate); 
+    W.SFS_Stress(strain_rate,Flow_Type); 
     U.lambda = W.lambda;
 
   } 
diff --git a/src_2D/LESPremixed2D/LESPremixed2DState.h b/src_2D/LESPremixed2D/LESPremixed2DState.h
index af6afd12fb664227ade117ce568d6aec0f05abfd..a662b0f5b472c92d825f3ac01a1acd4f22b8bc87 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DState.h
+++ b/src_2D/LESPremixed2D/LESPremixed2DState.h
@@ -216,7 +216,7 @@ class LESPremixed2D_pState {
 
    LESPremixed2D_pState(const double &d, const Vector2D &V, const double &pre, const double *scal):
 		rho(d), v(V), p(pre) 
- 		{ scalar = NULL; set_initial_values_scal(scal);  specnull();  set_initial_values(); } 
+     { scalar = NULL; set_initial_values_scal(scal);  specnull();  set_initial_values(); } 
 
    LESPremixed2D_pState(const double &d, const Vector2D &V, const double &pre, const double &value):
 		rho(d), v(V), p(pre) 
@@ -224,7 +224,7 @@ class LESPremixed2D_pState {
 
    LESPremixed2D_pState(const double &d, const double &vx, const double &vy, const double &pre, const double *scal):
                  rho(d), v(vx,vy), p(pre) 
- 		{ scalar = NULL; set_initial_values_scal(scal);  specnull();  set_initial_values(); }
+     { scalar = NULL; set_initial_values_scal(scal);  specnull();  set_initial_values(); }
 
    LESPremixed2D_pState(const double &d, const double &vx, const double &vy, const double &pre, const double &value):
                  rho(d), v(vx,vy), p(pre)                
@@ -248,7 +248,11 @@ class LESPremixed2D_pState {
    //this is needed for the operator overload returns!!!!
    LESPremixed2D_pState(const LESPremixed2D_pState &W): rho(W.rho), v(W.v), p(W.p),
  				 tau(W.tau), qflux(W.qflux), lambda(W.lambda), theta(W.theta) 
-                                 { scalar = NULL; set_initial_values_scal(W.scalar); specnull(); set_initial_values(W.spec); }      
+#ifdef THICKENED_FLAME_ON
+		   ,flame(W.flame)
+#endif 
+		   { scalar = NULL; set_initial_values_scal(W.scalar); 
+		     specnull(); set_initial_values(W.spec); }            
   //@}
 
    //read in ns species data, call only once as its static
@@ -269,6 +273,9 @@ class LESPremixed2D_pState {
    //Copy constructor, cheaper than = operator
    void Copy(const LESPremixed2D_pState &W);
 
+   // return the number of variables - number of species
+   int NumVarSansSpecies() const { return NUM_VAR_LESPREMIXED2D-ns; }
+
    /*************** VACUUM OPERATOR *********************/
    void Vacuum(){ rho=ZERO; v.zero(); p=ZERO;
      if (nscal) for(int i=0; i<nscal; ++i) scalar[i] = ZERO;
@@ -347,7 +354,7 @@ class LESPremixed2D_pState {
    double Gibbs(int species) const; //Gibbs Free Energy (H-TS) for species
 
    /**************** turbulence model related parameters*********/
-   double mu_t(const Tensor2D &strain_rate) const;      
+   double mu_t(const Tensor2D &strain_rate, const int &Flow_Type) const;      
    double Pr_turb(void) const;      
    double Sc_turb(void) const;      
    double Kappa_turb(const double &mut) const;      
@@ -373,7 +380,7 @@ class LESPremixed2D_pState {
 
    void Laminar_Stress(const Tensor2D &strain_rate);
 
-   void SFS_Stress(const Tensor2D &strain_rate);
+   void SFS_Stress(const Tensor2D &strain_rate, const int &Flow_Type);
 
    /************ Heat Flux vector thermal Diffusion ***********/
    Vector2D thermal_diffusion(void) const;
@@ -496,74 +503,48 @@ class LESPremixed2D_pState {
   double SFS_Curvature(const LESPremixed2D_pState &dWdx,
                        const LESPremixed2D_pState &dWdy,
                        const int &Flow_Type) const;
-/*   double M_xx(const LESPremixed2D_pState &dWdx, */
-/*               const LESPremixed2D_pState &dWdy, */
-/*               const LESPremixed2D_pState &d_dWdx_dx, */
-/*               const LESPremixed2D_pState &d_dWdx_dy, */
-/* 	      const LESPremixed2D_pState &d_dWdy_dy) const; */
-/*   double M_xy(const LESPremixed2D_pState &dWdx, */
-/*               const LESPremixed2D_pState &dWdy, */
-/*               const LESPremixed2D_pState &d_dWdx_dx, */
-/*               const LESPremixed2D_pState &d_dWdx_dy, */
-/* 	      const LESPremixed2D_pState &d_dWdy_dy) const; */
-/*   double M_yy(const LESPremixed2D_pState &dWdx, */
-/*               const LESPremixed2D_pState &dWdy, */
-/*               const LESPremixed2D_pState &d_dWdx_dx, */
-/*               const LESPremixed2D_pState &d_dWdx_dy, */
-/* 	      const LESPremixed2D_pState &d_dWdy_dy) const; */
-/*   double Resolved_Curvature(const LESPremixed2D_pState &dWdx, */
-/*                             const LESPremixed2D_pState &dWdy, */
-/*                             const LESPremixed2D_pState &d_dWdx_dx, */
-/*                             const LESPremixed2D_pState &d_dWdx_dy, */
-/*                             const LESPremixed2D_pState &d_dWdy_dy) const; */
-/*   double Resolved_Propagation(const LESPremixed2D_pState &dWdx, */
-/*                               const LESPremixed2D_pState &dWdy, */
-/*                               const LESPremixed2D_pState &d_dWdx_dx, */
-/*                               const LESPremixed2D_pState &d_dWdx_dy, */
-/*                               const LESPremixed2D_pState &d_dWdy_dy) const; */
-/*   double Resolved_Convection_Progvar (const LESPremixed2D_pState &dWdx, */
-/*                                       const LESPremixed2D_pState &dWdy) const; */
-/*   double Resolved_Convection_Fsd (const LESPremixed2D_pState &dWdx, */
-/*                                   const LESPremixed2D_pState &dWdy) const; */
-/*   double NGT_Progvar (const LESPremixed2D_pState &dWdx, */
-/*                       const LESPremixed2D_pState &dWdy) const; */
-/*   double NGT_Fsd (const LESPremixed2D_pState &dWdx, */
-/*                   const LESPremixed2D_pState &dWdy, */
-/*                   const LESPremixed2D_pState &d_dWdx_dx, */
-/*                   const LESPremixed2D_pState &d_dWdx_dy, */
-/*                   const LESPremixed2D_pState &d_dWdx_dy) const; */
-/*   double SFS_Diffusion_Progvar (const LESPremixed2D_pState &dWdx, */
-/*                                 const LESPremixed2D_pState &dWdy, */
-/*                                 const LESPremixed2D_pState &d_dWdx_dx, */
-/*                                 const LESPremixed2D_pState &d_dWdx_dy, */
-/*                                 const LESPremixed2D_pState &d_dWdy_dy, */
-/*                                 const int &Flow_Type) const; */
-/*   double SFS_Diffusion_Fsd (const LESPremixed2D_pState &dWdx, */
-/*                             const LESPremixed2D_pState &dWdy, */
-/*                             const LESPremixed2D_pState &d_dWdx_dx, */
-/*                             const LESPremixed2D_pState &d_dWdx_dy, */
-/*                             const LESPremixed2D_pState &d_dWdy_dy, */
-/*                             const int &Flow_Type) const; */
-/*   double Heat_Release_Strain (const LESPremixed2D_pState &dWdx, */
-/*                               const LESPremixed2D_pState &dWdy, */
-/*                               const LESPremixed2D_pState &d_dWdx_dx, */
-/*                               const LESPremixed2D_pState &d_dWdx_dy, */
-/*                               const LESPremixed2D_pState &d_dWdy_dy) const; */
-/*   double Net_Rate_Change_Progvar (const LESPremixed2D_pState &dWdx, */
-/*                                   const LESPremixed2D_pState &dWdy, */
-/*                                   const LESPremixed2D_pState &d_dWdx_dx, */
-/*                                   const LESPremixed2D_pState &d_dWdx_dy, */
-/*                                   const LESPremixed2D_pState &d_dWdy_dy, */
-/*                                   const int &Flow_Type) const; */
-/*   double Net_Rate_Change_Fsd (const LESPremixed2D_pState &dWdx, */
-/*                               const LESPremixed2D_pState &dWdy, */
-/*                               const LESPremixed2D_pState &d_dWdx_dx, */
-/*                               const LESPremixed2D_pState &d_dWdx_dy, */
-/*                               const LESPremixed2D_pState &d_dWdy_dy, */
-/*                               const int &Flow_Type) const; */
-  double K_equ_sources(const LESPremixed2D_pState &dWdx,
-                       const LESPremixed2D_pState &dWdy,
-                       const int &Flow_Type) const;
+  double M_xx(const LESPremixed2D_pState &dWdx,
+              const LESPremixed2D_pState &dWdy,
+              const LESPremixed2D_pState &d_dWdx_dx,
+              const LESPremixed2D_pState &d_dWdx_dy,
+	      const LESPremixed2D_pState &d_dWdy_dy) const;
+  double M_xy(const LESPremixed2D_pState &dWdx,
+              const LESPremixed2D_pState &dWdy,
+              const LESPremixed2D_pState &d_dWdx_dx,
+              const LESPremixed2D_pState &d_dWdx_dy,
+	      const LESPremixed2D_pState &d_dWdy_dy) const;
+  double M_yy(const LESPremixed2D_pState &dWdx,
+              const LESPremixed2D_pState &dWdy,
+              const LESPremixed2D_pState &d_dWdx_dx,
+              const LESPremixed2D_pState &d_dWdx_dy,
+	      const LESPremixed2D_pState &d_dWdy_dy) const;
+  double Resolved_Curvature(const LESPremixed2D_pState &dWdx,
+                            const LESPremixed2D_pState &dWdy,
+                            const LESPremixed2D_pState &d_dWdx_dx,
+                            const LESPremixed2D_pState &d_dWdx_dy,
+                            const LESPremixed2D_pState &d_dWdy_dy) const;
+  double Resolved_Propagation(const LESPremixed2D_pState &dWdx,
+                              const LESPremixed2D_pState &dWdy,
+                              const LESPremixed2D_pState &d_dWdx_dx,
+                              const LESPremixed2D_pState &d_dWdx_dy,
+                              const LESPremixed2D_pState &d_dWdy_dy) const;
+  double Resolved_Convection_Progvar (const LESPremixed2D_pState &dWdx,
+                                      const LESPremixed2D_pState &dWdy) const;
+  double Resolved_Convection_Fsd (const LESPremixed2D_pState &dWdx,
+                                  const LESPremixed2D_pState &dWdy) const;
+  double NGT_Progvar (const LESPremixed2D_pState &dWdx,
+                      const LESPremixed2D_pState &dWdy) const;
+  double NGT_Fsd (const LESPremixed2D_pState &dWdx,
+                  const LESPremixed2D_pState &dWdy,
+                  const LESPremixed2D_pState &d_dWdx_dx,
+                  const LESPremixed2D_pState &d_dWdx_dy,
+                  const LESPremixed2D_pState &d_dWdy_dy) const;
+  double Heat_Release_Strain (const LESPremixed2D_pState &dWdx,
+                              const LESPremixed2D_pState &dWdy,
+                              const LESPremixed2D_pState &d_dWdx_dx,
+                              const LESPremixed2D_pState &d_dWdx_dy,
+                              const LESPremixed2D_pState &d_dWdy_dy) const;
+
    /**************** Operators Overloading ********************/
    /* Index operator */
    double &operator[](int index);
@@ -665,6 +646,7 @@ class LESPremixed2D_pState {
    static int                      nscal; //!< number of scalars
    static NASARP1311data       *specdata; //!< Global species data 
    static double                *Schmidt; //!< Schmidt Number for each species
+   static Set_scalar            Scal_sys; //!< Set the group of scalars to be solved in the model
    static double          low_temp_range; //!< Low temp data range
    static double         high_temp_range; //!< High temp data range
    static int      NUM_VAR_LESPREMIXED2D; //!< Number of LESPremixed2D variables (4+ns)
@@ -711,7 +693,7 @@ class LESPremixed2D_pState {
    LESPremixed2D_cState(const double &d, const double &vx, const double &vy, const double &En, 
 		 const double *rhoscal):
                  rho(d), rhov(vx,vy), E(En)
- 		{ rhoscalar = NULL; set_initial_values_scal(rhoscal);  rhospecnull();   set_initial_values(); }
+     { rhoscalar = NULL; set_initial_values_scal(rhoscal);  rhospecnull();   set_initial_values(); }
 
    LESPremixed2D_cState(const double &d, const double &vx, const double &vy, const double &En, const double &value): 
                  rho(d), rhov(vx,vy), E(En)
@@ -729,11 +711,29 @@ class LESPremixed2D_pState {
 
    LESPremixed2D_cState(const double d, const Vector2D &V, const double &En, const double *rhoscal, const Species *rhomfrac): 
                  rho(d), rhov(V), E(En)
-                 { rhoscalar = NULL; set_initial_values_scal(rhoscal);  rhospecnull();   set_initial_values(rhomfrac); }
+     { rhoscalar = NULL; set_initial_values_scal(rhoscal);  rhospecnull();   set_initial_values(rhomfrac); }
+
+   // WARNING - automatic type conversion
+   LESPremixed2D_cState(const LESPremixed2D_pState &W) : rho(W.rho), rhov(W.rhov()), E(W.E()), 
+		   tau(W.tau), qflux(W.qflux), lambda(W.lambda), theta(W.theta) 
+#ifdef THICKENED_FLAME_ON
+		   ,flame(W.flame)
+#endif		   
+   {
+     for(int i=0; i<W.ns; ++i){
+       rhospec[i].c = W.rho*W.spec[i].c;
+       rhospec[i].gradc = W.rho*W.spec[i].gradc;
+       rhospec[i].diffusion_coef = W.rho*W.spec[i].diffusion_coef;
+     }
+     if(nscal) for(int i=0; i<nscal; ++i) rhoscalar[i] = W.rho*W.scalar[i];    
+   }
 
    //this is needed for the operator overload returns!!!!
    LESPremixed2D_cState(const LESPremixed2D_cState &U): rho(U.rho), rhov(U.rhov), E(U.E),
 		                  tau(U.tau), qflux(U.qflux), lambda(U.lambda), theta(U.theta)
+#ifdef THICKENED_FLAME_ON
+		   ,flame(U.flame)
+#endif
 		                  { rhoscalar = NULL; set_initial_values_scal(U.rhoscalar); 
 				    rhospecnull(); set_initial_values(U.rhospec); }
 
@@ -856,7 +856,7 @@ class LESPremixed2D_pState {
    friend LESPremixed2D_pState W(const LESPremixed2D_cState &U);
 
    /**************** turbulence model related parameters*********/
-   double mu_t(const Tensor2D &strain_rate) const;      
+   double mu_t(const Tensor2D &strain_rate, const int &Flow_Type) const;      
    double Pr_turb(void) const;      
    double Sc_turb(void) const;      
    double Dm_turb(const double &mut) const;  
@@ -965,7 +965,7 @@ class LESPremixed2D_pState {
 
  inline void  LESPremixed2D_pState::set_initial_values(const double &value){
    spec_memory();
-   for(int i=0; i<ns; ++i) spec[i].c = value;
+   for(int i=0; i<ns; ++i) spec[i].c = value; 
  }
 
  //user specified
@@ -1129,11 +1129,12 @@ inline void LESPremixed2D_pState::set_premixed_flame_variables(const double &lam
  }
 
  /***************** Turbulent SFS stress ******************************/
-inline void LESPremixed2D_pState::SFS_Stress(const Tensor2D &strain_rate){
+inline void LESPremixed2D_pState::SFS_Stress(const Tensor2D &strain_rate,
+                                             const int &Flow_Type){
 
-   double kk = SFSmodel.sfs_k_Yoshizawa(strain_rate, filter_width);
+  double kk = SFSmodel.sfs_k_Yoshizawa(strain_rate, filter_width);
 
-   lambda = TWO * mu_t(strain_rate) * strain_rate;
+   lambda = TWO * mu_t(strain_rate,Flow_Type) * strain_rate;
    lambda.xx -= (TWO/THREE)*rho*kk;
    lambda.yy -= (TWO/THREE)*rho*kk;
    lambda.zz -= (TWO/THREE)*rho*kk;
@@ -1249,6 +1250,7 @@ inline void LESPremixed2D_pState::Copy(const LESPremixed2D_pState &W){
 //**************** Index Operators *************************/
 inline double& LESPremixed2D_pState::operator[](int index) {  
   //  assert( index >= 1 && index <= NUM_VAR_LESPREMIXED2D );
+
   switch(index){  
   case 1:
     return rho;    
@@ -1259,11 +1261,11 @@ inline double& LESPremixed2D_pState::operator[](int index) {
   case 4:
     return p;
   default :
-    if(index <= NUM_VAR_LESPREMIXED2D-ns) {
+  if(index <= NUM_VAR_LESPREMIXED2D-ns) {
       return scalar[index-NUM_LESPREMIXED2D_VAR_SANS_SPECIES-1];
-    } else if(index <= NUM_VAR_LESPREMIXED2D) {
+  } else if(index <= NUM_VAR_LESPREMIXED2D) {
       return spec[index-(NUM_VAR_LESPREMIXED2D-ns)-1].c;
-    } else {
+  }
 #ifdef THICKENED_FLAME_ON
       if(index == NUM_VAR_LESPREMIXED2D+1) {
 	return flame.WF;
@@ -1271,12 +1273,12 @@ inline double& LESPremixed2D_pState::operator[](int index) {
 	return flame.TF;
       }
 #endif
-    }
-  };
-}
+   } 
+};
 
 inline const double& LESPremixed2D_pState::operator[](int index) const {  
-  //   assert( index >= 1 && index <= NUM_VAR_LESPREMIXED2D );
+  //  assert( index >= 1 && index <= NUM_VAR_LESPREMIXED2D );
+
   switch(index){  
   case 1:
     return rho;    
@@ -1287,11 +1289,11 @@ inline const double& LESPremixed2D_pState::operator[](int index) const {
   case 4:
     return p;
   default :
-    if(index <= NUM_VAR_LESPREMIXED2D-ns) {
+  if(index <= NUM_VAR_LESPREMIXED2D-ns) {
       return scalar[index-NUM_LESPREMIXED2D_VAR_SANS_SPECIES-1];
-    } else if(index <= NUM_VAR_LESPREMIXED2D) {
+  } else if(index <= NUM_VAR_LESPREMIXED2D) {
       return spec[index-(NUM_VAR_LESPREMIXED2D-ns)-1].c;
-    } else {
+  }
 #ifdef THICKENED_FLAME_ON
       if (index == NUM_VAR_LESPREMIXED2D+1) {
 	return flame.WF;
@@ -1300,9 +1302,8 @@ inline const double& LESPremixed2D_pState::operator[](int index) const {
       }
 #endif
     }      
-  };
+};
 
-}
 /**************************************************************
   Get max of the min temperature of the lowest region
   and min of the max temperature of the highest region
@@ -1554,11 +1555,11 @@ inline double& LESPremixed2D_cState::operator[](int index) {
   case 4:
     return (E);
   default :
-    if(index <= NUM_VAR_LESPREMIXED2D-ns) {
+  if(index <= NUM_VAR_LESPREMIXED2D-ns) {
       return rhoscalar[index-NUM_LESPREMIXED2D_VAR_SANS_SPECIES-1];
-    } else if(index <= NUM_VAR_LESPREMIXED2D) {
+  } else if(index <= NUM_VAR_LESPREMIXED2D) {
       return rhospec[index-(NUM_VAR_LESPREMIXED2D-ns)-1].c;
-    } else {
+  }
 #ifdef THICKENED_FLAME_ON
       if (index == NUM_VAR_LESPREMIXED2D+1) {
 	return flame.WF;
@@ -1567,8 +1568,7 @@ inline double& LESPremixed2D_cState::operator[](int index) {
       }
 #endif
     }
-  };
-}
+};
 
 inline const double& LESPremixed2D_cState::operator[](int index) const{
   //  assert( index >= 1 && index <= NUM_VAR_LESPREMIXED2D ); 
@@ -1582,11 +1582,11 @@ inline const double& LESPremixed2D_cState::operator[](int index) const{
   case 4:
     return (E);
   default :
-    if(index <= NUM_VAR_LESPREMIXED2D-ns) {
+   if(index <= NUM_VAR_LESPREMIXED2D-ns) {
       return rhoscalar[index-NUM_LESPREMIXED2D_VAR_SANS_SPECIES-1];
-    } else if(index <= NUM_VAR_LESPREMIXED2D) {
+  } else if(index <= NUM_VAR_LESPREMIXED2D) {
       return rhospec[index-(NUM_VAR_LESPREMIXED2D-ns)-1].c;
-    } else {
+  }
 #ifdef THICKENED_FLAME_ON
       if (index == NUM_VAR_LESPREMIXED2D+1) {
 	return flame.WF;
@@ -1595,8 +1595,7 @@ inline const double& LESPremixed2D_cState::operator[](int index) const{
       }
 #endif
     }
-  };
-}
+};
 
 /**************************************************************
   Check for -ve mass fractions and set small -ve values
@@ -1682,11 +1681,11 @@ inline bool LESPremixed2D_cState::negative_scalarcheck(void) const{
       rhoscalar[i] = ZERO;
     }
   }
-     if ( nscal > 1 ) {
-       if ( rhoscalar[0]/rho > 0.99 || rhoscalar[0]/rho < 0.01 ) {
-       rhoscalar[1] = ZERO;
-     }
-     }
+      if ( nscal > 1 ) {
+        if ( rhoscalar[0]/rho > 0.9905 || rhoscalar[0]/rho < 0.001 ) {
+        rhoscalar[1] = ZERO;
+      }
+      }
   return (1);
 }
 
@@ -1717,9 +1716,9 @@ inline bool LESPremixed2D_cState::Unphysical_Properties_Check(const int Flow_Typ
 	 << *this <<endl;
     return false;
   }
- if ((Flow_Type == FLOWTYPE_LAMINAR_FSD || 
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY || 
-       Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) &&
+ if ((Flow_Type == FLOWTYPE_LAMINAR_C_FSD || 
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY || 
+       Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) &&
       (rho <= ZERO || !negative_speccheck(n) || es() <= ZERO || !negative_scalarcheck() )) {
     cout << "\n " << CFFC_Name() 
 	 << " LESPremixed2D ERROR: Negative Density || Energy || Mass Fractions || Progress Variable || Flame Surface Density : \n"
@@ -1794,7 +1793,6 @@ inline LESPremixed2D_pState LESPremixed2D_cState::W(const LESPremixed2D_cState &
       Temp.spec[i].gradc = U.rhospec[i].gradc/U.rho;
       Temp.spec[i].diffusion_coef = U.rhospec[i].diffusion_coef/U.rho;
     }   
-
     Temp.p = U.p();
     if(nscal) for(int i=0; i<nscal; ++i) Temp.scalar[i] = U.rhoscalar[i]/U.rho;
     
diff --git a/src_2D/LESPremixed2D/LESPremixed2DdRdU.cc b/src_2D/LESPremixed2D/LESPremixed2DdRdU.cc
index 7fa558b10fbab09700d1ad8e984e8441aacf2d86..b062e5bd160d36592eb37385e81b6f5de5a2b14c 100644
--- a/src_2D/LESPremixed2D/LESPremixed2DdRdU.cc
+++ b/src_2D/LESPremixed2D/LESPremixed2DdRdU.cc
@@ -62,9 +62,9 @@ void SemiImplicitBlockJacobi(DenseMatrix &dSdU,
   
   if( (SolnBlk.Axisymmetric && SolnBlk.Flow_Type != FLOWTYPE_INVISCID) ||
       SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_TF_K ||
-      SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K) { 
+      SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K) { 
 
 #ifdef THICKENED_FLAME_ON
     int NUM_VAR_LESPREMIXED2D =  SolnBlk.NumVar()-3; 
@@ -72,11 +72,12 @@ void SemiImplicitBlockJacobi(DenseMatrix &dSdU,
     int NUM_VAR_LESPREMIXED2D =  SolnBlk.NumVar()-1;
 #endif
 
-    if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-         SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-         SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ){
-    NUM_VAR_LESPREMIXED2D =  SolnBlk.NumVar()-SolnBlk.W[0][0].ns;
+    if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+         SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+         SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ){
+      NUM_VAR_LESPREMIXED2D =  SolnBlk.NumVar()-SolnBlk.W[0][0].ns;
     }
+
     DenseMatrix dRdW(NUM_VAR_LESPREMIXED2D,NUM_VAR_LESPREMIXED2D,ZERO);  
     
     // Add Source Jacobians (viscous axisymmetric, turbulence)
@@ -84,12 +85,13 @@ void SemiImplicitBlockJacobi(DenseMatrix &dSdU,
     
     DenseMatrix dWdU(NUM_VAR_LESPREMIXED2D,NUM_VAR_LESPREMIXED2D,ZERO);     
     // Transformation Jacobian 
-    SolnBlk.W[ii][jj].dWdU(dWdU, SolnBlk.Flow_Type); 
-    //    SolnBlk.Uo[ii][jj].W().dWdU(dWdU, SolnBlk.Flow_Type); 
+    SolnBlk.Uo[ii][jj].W().dWdU(dWdU, SolnBlk.Flow_Type); 
     dSdU += dRdW*dWdU;
   }
+
   // Add Source Jacobians (inviscid axisymmetric, chemistry, gravity)
   SemiImplicitBlockJacobi_dSdU(dSdU,SolnBlk,EXPLICIT,ii,jj);                 
+
 }
 
 void SemiImplicitBlockJacobi_dSdW(DenseMatrix &dSdW,
@@ -118,9 +120,9 @@ void SemiImplicitBlockJacobi_dSdW(DenseMatrix &dSdW,
   //
   ////////////////////////////////////////////////////////////////
 
-   if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ||
-      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ){    
+   if(SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ||
+      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY ||
+      SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ){    
      dS_tdW(dSdW,SolnBlk, d_dWdx_dW_C, d_dWdy_dW_C, ii,jj);
    }
   
@@ -148,9 +150,9 @@ void SemiImplicitBlockJacobi_dSdU(DenseMatrix &dSdU,
   
   //Add Jacobian for finite-rate chemistry source terms  
   if (SolnBlk.W[ii][jj].React.reactset_flag != NO_REACTIONS &&
-      SolnBlk.Flow_Type != FLOWTYPE_LAMINAR_FSD &&
-      SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY &&
-      SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_FSD_K){    
+      SolnBlk.Flow_Type != FLOWTYPE_LAMINAR_C_FSD &&
+      SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY &&
+      SolnBlk.Flow_Type != FLOWTYPE_TURBULENT_LES_C_FSD_K){    
     SolnBlk.W[ii][jj].dSwdU(dSdU, SolnBlk.Flow_Type,solver_type);
   }  
 
@@ -1673,11 +1675,29 @@ void d_dWd_dW_Center(double &d_dWdx_dW_C, double &d_dWdy_dW_C,
 int dS_tdW(DenseMatrix &dStdW,  LESPremixed2D_Quad_Block &SolnBlk,
 	   double &d_dWdx_dW_C, double &d_dWdy_dW_C,
 	   const int &ii, const int &jj){
+  dStdW.zero();
   if ( SolnBlk.W[ii][jj].scalar[0]<0.99 && SolnBlk.W[ii][jj].scalar[0]>0.01 &&  
        SolnBlk.dWdx[ii][jj].scalar[0] !=ZERO && SolnBlk.dWdy[ii][jj].scalar[0] != ZERO ) {
 
-  if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_FSD ){
+  if ( SolnBlk.Flow_Type == FLOWTYPE_LAMINAR_C_FSD ){
+    
+    double t3,t4,t5,t6,t7,t9,t12,t13,t16,t18;
+    double tau_fsd = SolnBlk.W[ii][jj].HeatRelease_Parameter();
+
+      t3 = SolnBlk.W[ii][jj].reactants_den*SolnBlk.W[ii][jj].laminar_speed*(1.0+tau_fsd);
+      t4 = SolnBlk.dWdx[ii][jj].scalar[0];//cx(c);
+      t5 = t4*t4;
+      t6 = SolnBlk.dWdy[ii][jj].scalar[0];//cy(c);
+      t7 = t6*t6;
+      t9 = sqrt(t5+t7);
+      t12 = 1.0+tau_fsd*SolnBlk.W[ii][jj].scalar[0];//c;
+      t13 = t12*t12;
+      t16 = d_dWdx_dW_C;//diff(cx(c),c);
+      t18 = d_dWdy_dW_C;//diff(cy(c),c);
 
+      dStdW(4,4) = t3/t9/t13*(t4*t16+t6*t18)-2.0*t3*t9/t13/t12*tau_fsd;
+  
+      /*
     //counter-gradient in C
     double t1,t3,t4,t6,t7;
     double t11,t12,t13,t14,t19;
@@ -1756,10 +1776,97 @@ t59*t123-t64*t127)-t56*(-t27*t58*t123+t12*t134*t123*t100-t28*t58*t127+t13*t134*
 t127*t100)-t3*SolnBlk.W[ii][jj].rho*SolnBlk.W[ii][jj].scalar[1]*(-2.0*t59*t27+t34*t134*t100-2.0*t64*t28+t35*t134*t100);
       dStdW(5,5) = t52*SolnBlk.W[ii][jj].rho-t56*(-t59*(t163*SolnBlk.W[ii][jj].rho+t19)-t64*(t167*SolnBlk.W[ii][jj].rho+t20))-t3*SolnBlk.W[ii][jj].rho
 *t73;
+*/
+  }else if ( SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_SMAGORINSKY  ) {
+
+    double t1,t4,t5,t6,t7,t8,t9;
+    double t10,t12,t14,t15,t17,t18,t19;
+    double t20,t21,t25,t26,t28;
+    double t32,t33,t34,t35,t36,t37;
+    double t41,t42,t43,t49;
+    double t52,t55,t56,t57;
+    double t60,t61,t63,t64,t69;
+    double t71,t77;
+    double t80,t85,t86,t88,t89;
+    double t92,t94,t95,t98;
+    double t101,t122,t124,t127,t129;
+    double t136,t163,t165,t171,t175;
 
-  }else if ( SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_SMAGORINSKY ||
-             SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K  ) {
+    double tau_fsd = SolnBlk.W[ii][jj].HeatRelease_Parameter();
+    //    double k_fsd = SolnBlk.W[ii][jj].SFS_Kinetic_Energy_Fsd(SolnBlk.dWdx[ii][jj],SolnBlk.dWdy[ii][jj],SolnBlk.Flow_Type,SolnBlk.Grid.Cell[ii][jj].A);
+    double filter = SolnBlk.W[ii][jj].filter_width;
+    double kappa_fsd = SolnBlk.W[ii][jj].Efficiency_Function_Fsd(SolnBlk.dWdx[ii][jj],SolnBlk.dWdy[ii][jj],SolnBlk.Flow_Type,SolnBlk.Grid.Cell[ii][jj].A); 
+    double beta_fsd=1.0;
 
+      t1 = SolnBlk.W[ii][jj].reactants_den*SolnBlk.W[ii][jj].laminar_speed;
+      t4 = SolnBlk.dWdx[ii][jj].scalar[0];//cx(c);
+      t5 = t4*t4;
+      t6 = SolnBlk.dWdy[ii][jj].scalar[0];//cy(c);
+      t7 = t6*t6;
+      t8 = t5+t7;
+      t9 = 1/t8;
+      t10 = t5*t9;
+      t12 = t7*t9;
+      t14 = 2.0/3.0-2.0/3.0*t10+t12/3.0;
+      t15 = SolnBlk.dWdx[ii][jj].v.x;//Ux(U);
+      t17 = t4*t9;
+      t18 = SolnBlk.dWdy[ii][jj].v.x;//Uy(U);
+      t19 = SolnBlk.dWdx[ii][jj].v.y;//Vx(V);
+      t20 = t18+t19;
+      t21 = t6*t20;
+      t25 = 2.0/3.0-2.0/3.0*t12+t10/3.0;
+      t26 = SolnBlk.dWdy[ii][jj].v.y;//Vy(V);
+      t28 = t14*t15-t17*t21+t25*t26;
+      t32 = SolnBlk.W[ii][jj].laminar_speed*(1.0+tau_fsd*SolnBlk.W[ii][jj].scalar[0]);//c);
+      t33 = sqrt(t8);
+      t34 = 1/t33;
+      t35 = t4*t34;
+      t36 = SolnBlk.dWdx[ii][jj].scalar[1];//Fsdx(Fsd);
+      t37 = d_dWdx_dW_C;//diff(rhox(rho),rho);
+      t41 = t6*t34;
+      t42 = SolnBlk.dWdy[ii][jj].scalar[1];//Fsdy(Fsd);
+      t43 = d_dWdy_dW_C;//diff(rhoy(rho),rho);
+      t49 = SolnBlk.W[ii][jj].laminar_speed*tau_fsd;
+      t52 = -t5*t34-t7*t34;
+      t55 = sqrt(SolnBlk.W[ii][jj].k());
+      t56 = kappa_fsd*t55;
+      t57 = 1/filter;
+      t60 = beta_fsd*SolnBlk.W[ii][jj].laminar_speed;
+      t61 = SolnBlk.W[ii][jj].scalar[1]*SolnBlk.W[ii][jj].scalar[1];//Fsd*Fsd;
+      t63 = 1.0-SolnBlk.W[ii][jj].scalar[0];//c;
+      t64 = 1/t63;
+      t69 = d_dWdx_dW_C;//diff(Ux(U),U);
+      t71 = d_dWdy_dW_C;//diff(Uy(U),U);
+      t77 = d_dWdx_dW_C;//diff(Vx(V),V);
+      t80 = d_dWdy_dW_C;//diff(Vy(V),V);
+      t85 = d_dWdx_dW_C;//diff(cx(c),c);
+      t86 = t17*t85;
+      t88 = t8*t8;
+      t89 = 1/t88;
+      t92 = d_dWdy_dW_C;//diff(cy(c),c);
+      t94 = t4*t85+t6*t92;
+      t95 = 2.0*t5*t89*t94;
+      t98 = t6*t9*t92;
+      t101 = 2.0*t7*t89*t94;
+      t122 = SolnBlk.dWdx[ii][jj].rho;//rhox(rho);
+      t124 = t36*SolnBlk.W[ii][jj].rho+t122*SolnBlk.W[ii][jj].scalar[1];
+      t127 = SolnBlk.dWdy[ii][jj].rho;//rhoy(rho);
+      t129 = t42*SolnBlk.W[ii][jj].rho+t127*SolnBlk.W[ii][jj].scalar[1];
+      t136 = 1/t33/t8;
+      t163 = SolnBlk.W[ii][jj].rho*SolnBlk.W[ii][jj].rho;
+      t165 = t63*t63;
+      t171 = d_dWdx_dW_C;//diff(Fsdx(Fsd),Fsd);
+      t175 = d_dWdy_dW_C;//diff(Fsdy(Fsd),Fsd);
+      dStdW(4,0) = t1*SolnBlk.W[ii][jj].scalar[1];
+      dStdW(4,5) = t1*SolnBlk.W[ii][jj].rho;
+      dStdW(5,0) = t28*SolnBlk.W[ii][jj].scalar[1]-t32*(-t35*(t36+t37*SolnBlk.W[ii][jj].scalar[1])-t41*(t42+t43*SolnBlk.W[ii][jj].scalar[1]))-t49*SolnBlk.W[ii][jj].scalar[1]*t52+t56*SolnBlk.W[ii][jj].scalar[1]*t57-2.0*t60*t61*SolnBlk.W[ii][jj].rho*t64;
+      dStdW(5,1) = (t14*t69-t17*t6*t71)*SolnBlk.W[ii][jj].scalar[1]*SolnBlk.W[ii][jj].rho;
+      dStdW(5,2) = (-t17*t6*t77+t25*t80)*SolnBlk.W[ii][jj].scalar[1]*SolnBlk.W[ii][jj].rho;
+      dStdW(5,4) = ((-4.0/3.0*t86+2.0/3.0*t95+2.0/3.0*t98-t101/3.0)*t15-t85*t9
+*t21+2.0*t4*t89*t21*t94-t17*t92*t20+(-4.0/3.0*t98+2.0/3.0*t101+2.0/3.0*t86-t95/3.0)*t26)*SolnBlk.W[ii][jj].scalar[1]*SolnBlk.W[ii][jj].rho-t49*(-t35*t124-t41*t129)-t32*(-t85*t34*t124+t4*t136*t124*t94-t92*t34*t129+t6*t136*t129*t94)-t49*SolnBlk.W[ii][jj].rho*SolnBlk.W[ii][jj].scalar[1]*(-2.0*t35*t85+t5*t136*t94-2.0*t41*t92+t7*t136*t94)-t60*t61*t163/t165;
+      dStdW(5,5) = t28*SolnBlk.W[ii][jj].rho-t32*(-t35*(t171*SolnBlk.W[ii][jj].rho+t122)-t41*(t175*SolnBlk.W[ii][jj].rho+t127))-t49*SolnBlk.W[ii][jj].rho*t52+t56*SolnBlk.W[ii][jj].rho*t57-2.0*t60*SolnBlk.W[ii][jj].scalar[1]*t163*t64;
+
+  /*
     //counter-gradient in C
     double t1,t3,t4,t6,t7;
     double t11,t12,t13,t14,t19;
@@ -1779,7 +1886,7 @@ t127*t100)-t3*SolnBlk.W[ii][jj].rho*SolnBlk.W[ii][jj].scalar[1]*(-2.0*t59*t27+t3
     double tau_fsd = SolnBlk.W[ii][jj].HeatRelease_Parameter();
     double lam_speed_fsd = SolnBlk.W[ii][jj].laminar_speed;
     double rho_r = SolnBlk.W[ii][jj].reactants_den;
-    double k_fsd = SolnBlk.W[ii][jj].SFS_Kinetic_Energy_Fsd(SolnBlk.dWdx[ii][jj],SolnBlk.dWdy[ii][jj],SolnBlk.Flow_Type);
+    //    double k_fsd = SolnBlk.W[ii][jj].SFS_Kinetic_Energy_Fsd(SolnBlk.dWdx[ii][jj],SolnBlk.dWdy[ii][jj],SolnBlk.Flow_Type);
     double filter = SolnBlk.W[ii][jj].filter_width;
     double kappa_fsd = SolnBlk.W[ii][jj].Efficiency_Function_Fsd(SolnBlk.dWdx[ii][jj],SolnBlk.dWdy[ii][jj],SolnBlk.Flow_Type); 
     double beta_fsd=1.0;
@@ -1822,7 +1929,7 @@ t127*t100)-t3*SolnBlk.W[ii][jj].rho*SolnBlk.W[ii][jj].scalar[1]*(-2.0*t59*t27+t3
       t68 = t13*t62;
       t69 = SolnBlk.dWdy[ii][jj].scalar[1];//Fsdy(Fsd);
       t77 = -t34*t62-t35*t62;
-      t80 = sqrt(k_fsd);
+      t80 = sqrt(SolnBlk.W[ii][jj].k());
       t81 = kappa_fsd*t80;
       t82 = 1/filter;
       t85 = beta_fsd*lam_speed_fsd;
@@ -1860,8 +1967,8 @@ t109-t117/3.0)*t54)*SolnBlk.W[ii][jj].scalar[1]*SolnBlk.W[ii][jj].rho-t3*(-t63*t
 t116-2.0*t68*t28+t35*t156*t116)-t85*t86*t183/t185;
       dStdW(5,5) = t56*SolnBlk.W[ii][jj].rho-t60*(-t63*(t191*SolnBlk.W[ii][jj].rho+t19)-t68*(t195*SolnBlk.W[ii][jj].rho+t20))-t3*SolnBlk.W[ii][jj].rho
 *t77+t81*SolnBlk.W[ii][jj].rho*t82-2.0*t85*SolnBlk.W[ii][jj].scalar[1]*t183*t88;
-
-  }else if ( SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_FSD_K ) {
+*/
+  }else if ( SolnBlk.Flow_Type == FLOWTYPE_TURBULENT_LES_C_FSD_K ) {
 
     //Simplified M with rho
  
@@ -1880,7 +1987,7 @@ t116-2.0*t68*t28+t35*t156*t116)-t85*t86*t183/t185;
     double t206,t211,t214,t216,t219,t225,t226,t236,t255,t258,t264;
 
     double tau_fsd = SolnBlk.W[ii][jj].HeatRelease_Parameter();
-    double k_fsd = SolnBlk.W[ii][jj].SFS_Kinetic_Energy_Fsd(SolnBlk.dWdx[ii][jj],SolnBlk.dWdy[ii][jj],SolnBlk.Flow_Type);
+    //    double k_fsd = SolnBlk.W[ii][jj].SFS_Kinetic_Energy_Fsd(SolnBlk.dWdx[ii][jj],SolnBlk.dWdy[ii][jj],SolnBlk.Flow_Type);
     double filter = SolnBlk.W[ii][jj].filter_width;
     double kappa_fsd = SolnBlk.W[ii][jj].Efficiency_Function_Fsd(SolnBlk.dWdx[ii][jj],SolnBlk.dWdy[ii][jj],SolnBlk.Flow_Type); 
     double beta_fsd=1.0;
diff --git a/src_2D/LESPremixed2D/Scalars.h b/src_2D/LESPremixed2D/Scalars.h
index d7c79b32eea17c29cd462b09118e114181e147c4..64c07879a33d57f09801855128f21474c876ce93 100644
--- a/src_2D/LESPremixed2D/Scalars.h
+++ b/src_2D/LESPremixed2D/Scalars.h
@@ -18,8 +18,9 @@ using namespace std;
 
 /* Define some constants */
 enum { NO_SCALARS, 
-       LES_FSD_C, 
-       LES_FSD_C_K, 
+       LES_C, 
+       LES_C_FSD, 
+       LES_C_FSD_K, 
        LES_TF, 
        LES_TF_K };
 
@@ -71,9 +72,18 @@ inline void Set_scalar::scalar_set(string &scal_sys) {
     scalars = NULL;
   }
 
-  // FSD & Progress variable  model
-  else if( Scalar_system == "LES_FSD_C"){
-    scalar_flag = LES_FSD_C;
+  // Progress variable model
+  else if( Scalar_system == "LES_C"){
+    scalar_flag = LES_C;
+    num_scalars = 1;
+    // set up scalar list
+    scalars = new string[num_scalars];
+    scalars[0] = "C";
+  }
+
+  // FSD & Progress variable model
+  else if( Scalar_system == "LES_C_FSD"){
+    scalar_flag = LES_C_FSD;
     num_scalars = 2;
     // set up scalar list
     scalars = new string[num_scalars];
@@ -81,18 +91,18 @@ inline void Set_scalar::scalar_set(string &scal_sys) {
     scalars[1] = "FSD/rho";
   }
 
-  // FSD & Progress variable with SGS k  model
-  else if( Scalar_system == "LES_FSD_C_K"){
-    scalar_flag = LES_FSD_C_K ;
+  // FSD & Progress variable with SFS k model
+  else if( Scalar_system == "LES_C_FSD_K"){
+    scalar_flag = LES_C_FSD_K ;
     num_scalars = 3;
     // set up scalar list
     scalars = new string[num_scalars];
-    scalars[0] = "K";
-    scalars[1] = "C";
-    scalars[2] = "FSD/rho";
+    scalars[0] = "C";
+    scalars[1] = "FSD/rho";
+    scalars[2] = "k";
   }
 
-  // Thickened flame  model
+  // Thickened flame model
   else if( Scalar_system == "LES_TF"){
     scalar_flag = LES_TF;
     num_scalars = 0;
@@ -100,7 +110,7 @@ inline void Set_scalar::scalar_set(string &scal_sys) {
     scalars = NULL;   
   }
 
-  // Thickened flame with SGS k  model
+  // Thickened flame with SFS k model
   else if( Scalar_system == "LES_TF_K"){
     scalar_flag = LES_TF_K;
     num_scalars = 1;
diff --git a/src_2D/makefile.def b/src_2D/makefile.def
index acdc6d340f0d26e74a90c4b568b6c50bc3123dda..f86cfe61e3a4cd8e909de0737d3aa77d5b74428d 100644
--- a/src_2D/makefile.def
+++ b/src_2D/makefile.def
@@ -9,13 +9,13 @@
 PLATFORM = generic
 
 # NoMPI, MPICH, MPICH2, MPT (SG)
-MPI_VERSION = NoMPI
+MPI_VERSION = MPICH
 
 # NoICEMCFD, V41, V42. V43, V50, V10, V11
 ICEMCFD_VERSION = NoICEMCFD
 
 # Version V296, V3+, ICC
-GCC_VERSION = V3+
+GCC_VERSION = ICC
 
 # NoCANTERA, V70
 CANTERA_VERSION = NoCANTERA
-- 
1.5.2.1

