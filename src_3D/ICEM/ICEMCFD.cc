/* ICEMCFD.cc: Subroutines for Reading CFD Mesh Generated by ICEMCFD. */

/************************************************************************
 *                                                                      *
 *                         Written by Ming Yao Ding                     *
 *                      email: mingyao.ding@utoronto.ca                 *
 *                     Modified & written by Stefan Neata               *
 *                      email: stefan.neata@utoronto.ca                 *
 *         University of Toronto Institute for Aerospace Studies        *
 *                           Summers 2002 & 2003                        *
 *                                                                      * 
 ************************************************************************/

/* Include ICEMCFD header file. */

#ifndef _ICEMCFD_INCLUDED
#include "ICEMCFD.h"
#endif // _ICEMCFD_INCLUDED

/****************************************************
ICEMCFD_error
****************************************************/
void ICEMCFD_error(){

#ifdef _ICEMCFD_VERSION
  cout << "\n ICEMCFD ERROR: " << df_get_error() << "\n";
  cout.flush();
#endif

}

/****************************************************
ICEMCFD_get_filenames
****************************************************/
char **ICEMCFD_get_filenames() {

  int i;
  char **icemcfd_file_names;

  icemcfd_file_names = new char*[3];
  for ( i = 0 ; i < 3 ; i++ ) {
     icemcfd_file_names[i] = new char[20];
  } /* endfor */

#ifdef _ICEMCFD_V41
  strcpy(icemcfd_file_names[0],"topo_mulcad_out");
  strcpy(icemcfd_file_names[1],"family_boco");
  strcpy(icemcfd_file_names[2],"family_topo");
#else // V42, V43, V50
  strcpy(icemcfd_file_names[0],"topo_mulcad_out.top");
  strcpy(icemcfd_file_names[1],"family_boco.fbc");
  strcpy(icemcfd_file_names[2],"family_topo.fto");
 
#endif

  return(icemcfd_file_names);

}

/****************************************************
ICEMCFD_get_boco is a function that compares the family name
of an edges to the predefined values for boundary 
conditions and returns that value.
In other words, the boundary conditions of an edges is 
set by grouping the edge into a family with one of the
following names.  BC_NONE is the default boundary type.
****************************************************/
int ICEMCFD_get_boco(char *file_read){

  if      (strcmp(file_read, "BC_NONE")==0) return (BC_NONE);
  else if (strcmp(file_read, "BC_FIXED")==0) return (BC_FIXED);
  else if (strcmp(file_read, "BC_CONSTANT_EXTRAPOLATION")==0) return (BC_CONSTANT_EXTRAPOLATION);
  else if (strcmp(file_read, "BC_LINEAR_EXTRAPOLATION")==0) return (BC_LINEAR_EXTRAPOLATION);
  else if (strcmp(file_read, "BC_REFLECTION")==0) return (BC_REFLECTION);
  else if (strcmp(file_read, "BC_PERIODIC")==0) return (BC_PERIODIC);
  else if (strcmp(file_read, "BC_CHARACTERISTIC")==0) return (BC_CHARACTERISTIC);
  else if (strcmp(file_read, "BC_OPEN_END")==0) return (BC_OPEN_END);
  else if (strcmp(file_read, "BC_DIRICHLET")==0) return (BC_DIRICHLET);
  else if (strcmp(file_read, "BC_NEUMANN")==0) return (BC_NEUMANN);
  else if (strcmp(file_read, "BC_ROBIN")==0) return (BC_ROBIN);
  else if (strcmp(file_read, "BC_NO_SLIP")==0) return (BC_NO_SLIP);
  else if (strcmp(file_read, "BC_WALL_VISCOUS_ISOTHERMAL")==0) return (BC_WALL_VISCOUS_ISOTHERMAL);
  else if (strcmp(file_read, "BC_WALL_VISCOUS_HEATFLUX")==0) return (BC_WALL_VISCOUS_HEATFLUX);
  else if (strcmp(file_read, "BC_MOVING_WALL")==0) return (BC_MOVING_WALL);
  else if (strcmp(file_read, "BC_MOVING_WALL_ISOTHERMAL")==0) return (BC_MOVING_WALL_ISOTHERMAL);
  else if (strcmp(file_read, "BC_MOVING_WALL_HEATFLUX")==0) return (BC_MOVING_WALL_HEATFLUX);
  else if (strcmp(file_read, "BC_FIXED_TEMP_WALL")==0) return (BC_FIXED_TEMP_WALL);
  else if (strcmp(file_read, "BC_ADIABATIC_WALL")==0) return (BC_ADIABATIC_WALL);
  else if (strcmp(file_read, "BC_FIXED_TEMP")==0) return (BC_FIXED_TEMP);
  else if (strcmp(file_read, "LEFT_END_BOUNDARY")==0) return (LEFT_END_BOUNDARY);
  else if (strcmp(file_read, "RIGHT_END_BOUNDARY")==0) return (RIGHT_END_BOUNDARY);
  else if (strcmp(file_read, "BC_FIXED_HEATFLUX")==0) return (BC_FIXED_HEATFLUX);
  else if (strcmp(file_read, "BC_BURNING_SURFACE")==0) return (BC_BURNING_SURFACE);
  else if (strcmp(file_read, "BC_ABSORPTION")==0) return (BC_ABSORPTION);

  return (BC_NONE);

}

/************
 * 3D STUFF *
/************/

void ICEMCFD_get_layout(int ***layout, 
                        int x, 
                        int y, 
                        int z, 
                        int &expdom, 
                        int &smallest, 
                        int &smallindex){

#ifdef _ICEMCFD_VERSION
  int ier;//return value of functions
  int ndomad;//number of adjacent domains
  int domad_record[5];//array holding information regarding block connectivity

  expdom=expdom+1;
  ndomad= tp_ndom_nsub_ad(layout[x][y][z]);

  /*for each adjacent domain, there is a connecting face.  The orientation
    of the face can be deduced from the face index which is stored in
    domad_record[0].  
    1 - West
    2 - East
    3 - South
    4 - North
    5 - Bottom
    6 - Top
  */

  for(int i = 1; i<=ndomad; i++){ 
    ier=tp_domad_record( layout[x][y][z], i, domad_record);
      if(domad_record[0] == 5 && (z-1)>=0 && layout[x][y][z-1]==0 ){
	layout[x][y][z-1]=domad_record[1];
	if(layout[x][y][z-1]==(smallest+1))
	  smallest++;
	if(layout[x][y][z-1]>smallindex)
	  smallindex=layout[x][y][z-1];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y, z-1,expdom, smallest, smallindex);
      }
      
      if(domad_record[0] == 6 && layout[x][y][z+1]==0 ){
	layout[x][y][z+1]=domad_record[1];
	if(layout[x][y][z+1]==(smallest+1))
	  smallest++;
	if(layout[x][y][z+1]>smallindex)
	  smallindex=layout[x][y][z+1];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y, z+1,expdom, smallest, smallindex);
      } 

      if(domad_record[0] == 1 && (x-1)>=0 && layout[x-1][y][z]==0 ){
	layout[x-1][y][z]=domad_record[1];
	if(layout[x-1][y][z]==(smallest+1))
	  smallest++;
	if(layout[x-1][y][z]>smallindex)
	  smallindex=layout[x-1][y][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x-1, y, z, expdom, smallest, smallindex);
      }

      if(domad_record[0] == 2 && layout[x+1][y][z]==0 ){
	layout[x+1][y][z]=domad_record[1];
	if(layout[x+1][y][z]==(smallest+1))
	  smallest++;
	if(layout[x+1][y][z]>smallindex)
	  smallindex=layout[x+1][y][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x+1, y, z, expdom, smallest, smallindex);
      }

      if(domad_record[0] == 3 && (y-1)>=0 && layout[x][y-1][z]==0 ){
	layout[x][y-1][z]=domad_record[1];
	if(layout[x][y-1][z]==(smallest+1))
	  smallest++;
	if(layout[x][y-1][z]>smallindex)
	  smallindex=layout[x][y-1][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y-1, z,expdom, smallest, smallindex);
      }

      if(domad_record[0] == 4 && layout[x][y+1][z]==0 ){
	layout[x][y+1][z]=domad_record[1];
	if(layout[x][y+1][z]==(smallest+1))
	  smallest++;
	if(layout[x][y+1][z]>smallindex)
	  smallindex=layout[x][y+1][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y+1, z, expdom, smallest, smallindex);
      }
  }
#endif
}

/********************************************************
ICEMCFD_Read reads the data in the domain files from ICEMCFD
and stores the data in a 3D hexahedral multiblock grid 
structure defined by Grid3D_Hexa_Block class. The Boundary 
condtions are gathered from the toplogy and boundary 
conditions files.
                
filenames should have 3 strings including
file name for the topology information,
by default the filename is "topo_mulcad_out".
the two boundary condition files which in ICEMCFD
v4.1 by default the names are "family_boco" and "family_topo"
respectively.

domx_buf, domy_buf and domz_buf are variables to hold the number of 
domains in the x,y, and z directions.
********************************************************/

Grid3D_Hexa_Block*** ICEMCFD_Read(char **filenames,
                                  Grid3D_Hexa_Block ***Grid_ptr,
                                  int *domx_buf, 
                                  int *domy_buf,
			 	  int *domz_buf){

#ifdef _ICEMCFD_VERSION
  // CFD Variables
  int Ni, Nj, Nk;
  int i,j,k,x,y,z;
  int spline_type;
  int domxx,domyy, domzz;
  int Nghost = 2;//initializing number of nghost cells

  // ICEM Variables
  int file_no,mode,type, ier;
  int coord, n_domain,n_nodes;
  char sub_name[200];
  int imin[3],imax[3];
  int jmin[3],jmax[3];
  double *node_pnts;

  // Get domain layout in a multi grid environment
  char dom_name[20];
  char temp[20];

  //*************** Topology and Boundary conditions
  int ndom,nsfac,nar,nvert,nedges;
  int edges[4],tempedges[4];
  int UNDEFINED_EDGE_NUMBER = -1000;

  // boundary conditions library variables
  int ibc;
  char **values;
  char bc_temp[40];

  values = new char*[2];
  for (i=0; i<2; i++) values[i] = new char[20];

  tp_init(filenames[0]);//opens, reads, and closes the topology file.  Information is stored in memory.
  ndom=tp_ndom();
  nsfac=tp_nsfac();
  nar=tp_nar();
  nvert=tp_nvert();

  /********* Initializing Boundary conditions Library**********/
  ier = bc_init_both(filenames[1], filenames[2] ,ndom, nsfac,nar,nvert,0,0,0);  
  
  /*********getting layout without input**********************/
  /**calls the recursive ICEMCFD_get_layout function until all the domains have been entered into matrix****/
  int smallest=1;
  int expdom=0;
  int ***layout;
  int xcor=0;
  int ycor=0;
  int zcor=0;
  int smallindex=0;
  int count=0;

  //create 3D array to store domain connectivity information
  layout = new int**[ndom+1];
  for(int i=0; i<(ndom+1);i++){
    layout[i]=new int*[ndom+1];
    for(int j=0; j<(ndom+1); j++){
      layout[i][j]=new int[ndom+1];
    }
  }
  //call the recursive function until the number of explored domains equals the number of domains
  while(expdom != ndom){
    //clear 3D array
    for(int i = 0; i <(ndom+1);i++){
      for(int j = 0 ; j<(ndom+1); j++){
	for(int k = 0 ; k<(ndom+1); k++) {
	  layout[i][j][k]=0;
	}
      }
    }
    expdom=0;
    //search for the first array location with a domain*/
    if(smallest==ndom && smallest!=1){
      count = 0 ;
      smallest = 1;
      if(xcor!=ndom && ycor==0 && zcor ==0)
	xcor = xcor +1;
      else if(ycor!=ndom && zcor==0)
	ycor = ycor +1;
      else if(zcor !=ndom)
	zcor = zcor +1;
    }
    
    if(count==0)
      layout[xcor][ycor][zcor]=smallest;
    else{
      smallest=smallest+1;
      layout[xcor][ycor][zcor]=smallest;
    }
    ICEMCFD_get_layout(layout, xcor, ycor, zcor, expdom, smallest, smallindex);
    count=count+1;
  }

  /*reduce the array to proper size*/
  int flagx, flagy, flagz;
  domxx=ndom;
  domyy=ndom;
  domzz=ndom;

  for(int k = 0; k <domzz ; k++){
    flagz=0;
    for(int j = 0; j < domyy ; j++){
      for(int i =0 ; i < domxx ; i++) {
	if(layout[i][j][k]!=0)
	  flagz=-1;
      }
    }
    if(flagz==0)
      domzz=k;
  }

  for(int j = 0; j <domyy ; j++){
    flagy=0;
    for(int k = 0; k < domzz ; k++){
      for(int i =0 ; i < domxx ; i++) {
	if(layout[i][j][k]!=0)
	  flagy=-1;
      }
    }
    if(flagy==0)
      domyy=j;
  }

  for(int i = 0; i <domxx ; i++){
    flagx=0;
    for(int j = 0; j < domyy ; j++){
      for(int k =0 ; k < domzz ; k++) {
	if(layout[i][j][k]!=0)
	  flagx=-1;
      }
    }
    if(flagx==0)
      domxx=i;
  }
  
  //for(int k=0; k < domzz; k++){
  //  for(int j=0; j < domyy; j++){
  //    for(int i=0; i < domxx; i++){
  //	cout<<layout[i][j][k]<<" ";
  //    }
  //  }
  //}
  
  if (domxx <= 0 || domyy <= 0 || domzz <= 0) return(NULL);

  /******* Allocating memory for Multi block grid ********/
  Grid_ptr = Allocate_Multi_Block_Grid(Grid_ptr, domxx, domyy, domzz);  

  for(int z =0; z < domzz; z++){
    for (int y = 0; y < domyy; y++) {
      for (int x = 0; x < domxx; x++) {
	
	/****** Ignore if domain number is 0 *******/
	if (layout[x][y][z]!=0){

	sprintf(dom_name,"domain.%d",layout[x][y][z]);
	
        // *********** ICEM PART
	mode=MODE_READ;
	type=STRUCTURED_DOMAIN;

	// OPEN the domain file 
	file_no=df_open(dom_name, mode, type);
	if (file_no<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */
      
	// GET the number of subdomains
	ier = df_n_domain(file_no,&n_domain);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	// Get node range
	ier = df_struct_domain_range(file_no,n_domain-1,imin,imax);
	if (ier<0) {
           ICEMCFD_error(); 
           return (NULL);
        } /* endif */

	Ni=imax[0];
	Nj=imax[1];
	Nk=imax[2];
      
	
	n_nodes=Ni*Nj*Nk*3;

	// READ all the nodes from ICEM domain file
	node_pnts=(double *)malloc(n_nodes*sizeof(double));

	ier=df_struct_read_nodes(file_no, n_domain-1, imin,imax, node_pnts);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	// CLOSE the domain file
	ier=df_close(file_no);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	
	//****** Allocate memory for current domain *********/	
	Grid_ptr[x][y][z].allocate(Ni-1,Nj-1,Nk-1,Nghost);

	// Convert 1D array of nodes into a 3D array
	for ( int k = Grid_ptr[x][y][z].KNl; k <= Grid_ptr[x][y][z].KNu; k++) {
	  for (int j =  Grid_ptr[x][y][z].JNl; j <= Grid_ptr[x][y][z].JNu; j++) {
	    for (int i = Grid_ptr[x][y][z].INl; i <= Grid_ptr[x][y][z].INu; i++) {
	      Grid_ptr[x][y][z].Node[i][j][k].X.x = node_pnts[3*(i-Grid_ptr[x][y][z].INl+
								 Ni*(j-Grid_ptr[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_ptr[x][y][z].KNl))+0];
	      Grid_ptr[x][y][z].Node[i][j][k].X.y = node_pnts[3*(i-Grid_ptr[x][y][z].INl+
								 Ni*(j-Grid_ptr[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_ptr[x][y][z].KNl))+1];
	      Grid_ptr[x][y][z].Node[i][j][k].X.z = node_pnts[3*(i-Grid_ptr[x][y][z].INl+
								 Ni*(j-Grid_ptr[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_ptr[x][y][z].KNl))+2];
	    } /* endfor */
	  } /* endfor */
	}/* endfor */
	
	
	
	/****** Process the Grid *******/
	Update_Cells(Grid_ptr[x][y][z]);
	
	} /* endif */
      } /* endfor */
    } /* endfor */
  } /* endor */  
    
  /***** Return the domain layout of the mesh ******/
  *domx_buf = domxx;
  *domy_buf = domyy;
  *domz_buf = domzz;
#endif
  
  return (Grid_ptr);
  
}
