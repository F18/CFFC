
/* ICEMCFD.cc: Subroutines for Reading CFD Mesh Generated by ICEMCFD. */

/************************************************************************
 *                                                                      *
 *                         Written by Ming Yao Ding                     *
 *                      email: mingyao.ding@utoronto.ca                 *
 *                     Modified & written by Stefan Neata               *
 *                      email: stefan.neata@utoronto.ca                 *
 *                   Additional Modifications by Tim Blair              *
 *                      email: tjblair@interchange.ubc.ca               *
 *                   Additional Modifications by Eska Ko                *
 *                      email:???                                       *    
 *         University of Toronto Institute for Aerospace Studies        *
 *                       Summers 2002, 2003, 2004, & 2007               *
 *                                                                      * 
 ************************************************************************/

/* Include ICEMCFD header file. */

#ifndef _ICEMCFD_INCLUDED
#include "ICEMCFD.h"
#endif // _ICEMCFD_INCLUDED

/* Boundary Condition functions at end of file*/
int ICEMCFD_get_boco(int boco);
int ICEMCFD_get_bocoData(char *DataType);
void ICEMCFD_set_boco3D(int edge_no, BCinfoCGNS &BCs);

/****************************************************
ICEMCFD_error
****************************************************/
void ICEMCFD_error(){

#ifdef _ICEMCFD_VERSION
  cout << "\n ICEMCFD ERROR: " << df_get_error() << "\n";
  cout.flush();
#endif

}

/****************************************************
ICEMCFD_get_filenames
****************************************************/
char **ICEMCFD_get_filenames() {

  int i;
  char **icemcfd_file_names;

  icemcfd_file_names = new char*[3];
  for ( i = 0 ; i < 3 ; i++ ) {
     icemcfd_file_names[i] = new char[20];
  } /* endfor */


#ifdef _ICEMCFD_V41
  strcpy(icemcfd_file_names[0],"topo_mulcad_out");
  strcpy(icemcfd_file_names[1],"family_boco");
  strcpy(icemcfd_file_names[2],"family_topo");
#else // V42, V43, V50, V10, V11
  strcpy(icemcfd_file_names[0],"topo_mulcad_out.top");
  strcpy(icemcfd_file_names[1],"family_boco.fbc");
  strcpy(icemcfd_file_names[2],"family_topo.fto");
#endif

  return(icemcfd_file_names);
}

/************
 * 3D STUFF *
 ************/
void ICEMCFD_get_layout(int ***layout, 
                        int x, 
                        int y, 
                        int z, 
                        int &expdom, 
                        int &smallest, 
                        int &smallindex){

#ifdef _ICEMCFD_VERSION
  int ier;//return value of functions
  int ndomad;//number of adjacent domains
  int domad_record[5];//array holding information regarding block connectivity

  expdom=expdom+1;
  ndomad= tp_ndom_nsub_ad(layout[x][y][z]);

  /*for each adjacent domain, there is a connecting face.  The orientation
    of the face can be deduced from the face index which is stored in
    domad_record[0].  
    1 - West
    2 - East
    3 - South
    4 - North
    5 - Bottom
    6 - Top
  */

  for(int i = 1; i<=ndomad; i++){ 
    ier=tp_domad_record( layout[x][y][z], i, domad_record);
      if(domad_record[0] == 5 && (z-1)>=0 && layout[x][y][z-1]==0 ){
	layout[x][y][z-1]=domad_record[1];
	if(layout[x][y][z-1]==(smallest+1))
	  smallest++;
	if(layout[x][y][z-1]>smallindex)
	  smallindex=layout[x][y][z-1];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y, z-1,expdom, smallest, smallindex);
      }
      
      if(domad_record[0] == 6 && layout[x][y][z+1]==0 ){
	layout[x][y][z+1]=domad_record[1];
	if(layout[x][y][z+1]==(smallest+1))
	  smallest++;
	if(layout[x][y][z+1]>smallindex)
	  smallindex=layout[x][y][z+1];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y, z+1,expdom, smallest, smallindex);
      } 

      if(domad_record[0] == 1 && (x-1)>=0 && layout[x-1][y][z]==0 ){
	layout[x-1][y][z]=domad_record[1];
	if(layout[x-1][y][z]==(smallest+1))
	  smallest++;
	if(layout[x-1][y][z]>smallindex)
	  smallindex=layout[x-1][y][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x-1, y, z, expdom, smallest, smallindex);
      }

      if(domad_record[0] == 2 && layout[x+1][y][z]==0 ){
	layout[x+1][y][z]=domad_record[1];
	if(layout[x+1][y][z]==(smallest+1))
	  smallest++;
	if(layout[x+1][y][z]>smallindex)
	  smallindex=layout[x+1][y][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x+1, y, z, expdom, smallest, smallindex);
      }

      if(domad_record[0] == 3 && (y-1)>=0 && layout[x][y-1][z]==0 ){
	layout[x][y-1][z]=domad_record[1];
	if(layout[x][y-1][z]==(smallest+1))
	  smallest++;
	if(layout[x][y-1][z]>smallindex)
	  smallindex=layout[x][y-1][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y-1, z,expdom, smallest, smallindex);
      }

      if(domad_record[0] == 4 && layout[x][y+1][z]==0 ){
	layout[x][y+1][z]=domad_record[1];
	if(layout[x][y+1][z]==(smallest+1))
	  smallest++;
	if(layout[x][y+1][z]>smallindex)
	  smallindex=layout[x][y+1][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y+1, z, expdom, smallest, smallindex);
      }
  }
#endif
}

/***********************************
 *  Grid_ICEMCFD                   *
 ***********************************/
Grid3D_Hexa_Block ***Grid_ICEMCFD(Grid3D_Hexa_Block ***Grid_Blks, char **filenames,
                                  int &domx_buf, int &domy_buf, int &domz_buf){


#ifdef _ICEMCFD_VERSION
  int Ni, Nj, Nk;
  int domxx,domyy, domzz;

  // ICEM Variables
  int file_no,mode,type, ier;
  int n_domain,n_nodes;
  int imin[3],imax[3];
  int jmin[3],jmax[3];
  double *node_pnts;
  int Nghost = 2;

  // Get domain layout in a multi grid environment
  char dom_name[20];

 //*************** Topology and Boundary conditions
  int ndom,nsfac,nar,nvert,nedges;
  int subfaces[6];
  int UNDEFINED_FACE_NUMBER = -1000;

  tp_init(filenames[0]);//opens, reads, and closes the topology file.  Information is stored in memory.
  ndom=tp_ndom();
  nsfac=tp_nsfac();

  /*********getting layout without input**********************/
  /**calls the recursive ICEMCFD_get_layout function until all the domains have been entered into matrix****/
  int smallest=1;
  int expdom=0;
  int ***layout;
  int xcor=0;
  int ycor=0;
  int zcor=0;
  int smallindex=0;
  int count=0;

  /********* Initializing Boundary conditions Library**********/
  ier = bc_init_both(filenames[1],filenames[2] ,ndom, nsfac,nar,nvert,0,0,0);  

  //create 3D array to store domain connectivity information
  layout = new int**[ndom+1];
  for(int i=0; i<(ndom+1);i++){
   layout[i]=new int*[ndom+1];
    for(int j=0; j<(ndom+1); j++){
      layout[i][j]=new int[ndom+1];
    }
  }
  //call the recursive function until the number of explored domains equals the number of domains
  while(expdom != ndom){
    //clear 3D array
    for(int i = 0; i <(ndom+1);i++){
      for(int j = 0 ; j<(ndom+1); j++){
	for(int k = 0 ; k<(ndom+1); k++) {
	  layout[i][j][k]=0;
	}
      }
    }

    expdom=0;
    //search for the first array location with a domain*/
    if(smallest==ndom && smallest!=1){
      count = 0 ;
      smallest = 1;
      if(xcor!=ndom && ycor==0 && zcor ==0)
	xcor = xcor +1;
      else if(ycor!=ndom && zcor==0)
	ycor = ycor +1;
      else if(zcor !=ndom)
	zcor = zcor +1;
    }
    
    if(count==0)
      layout[xcor][ycor][zcor]=smallest;
    else{
      smallest=smallest+1;
      layout[xcor][ycor][zcor]=smallest;
    }

    ICEMCFD_get_layout(layout, xcor, ycor, zcor, expdom, smallest, smallindex);
    count=count+1;
  }

  /*reduce the array to proper size*/
  int flagx, flagy, flagz;
  domxx=ndom;
  domyy=ndom;
  domzz=ndom;

  for(int k = 0; k <domzz ; k++){
    flagz=0;
    for(int j = 0; j < domyy ; j++){
      for(int i =0 ; i < domxx ; i++) {
	if(layout[i][j][k]!=0)
	  flagz=-1;
      }
    }
    if(flagz==0)
      domzz=k;
  }

  for(int j = 0; j <domyy ; j++){
    flagy=0;
    for(int k = 0; k < domzz ; k++){
      for(int i =0 ; i < domxx ; i++) {
	if(layout[i][j][k]!=0)
	  flagy=-1;
      }
    }
    if(flagy==0)
      domyy=j;
  }

  for(int i = 0; i <domxx ; i++){
    flagx=0;
    for(int j = 0; j < domyy ; j++){
      for(int k =0 ; k < domzz ; k++) {
	if(layout[i][j][k]!=0)
	  flagx=-1;
      }
    }
    if(flagx==0)
      domxx=i;
  }

  if (domxx <= 0 || domyy <= 0 || domzz <= 0) return (NULL);
 
  Grid_Blks = new Grid3D_Hexa_Block**[domxx];
  for (int i = 0 ; i < domxx ; ++i ) {
      Grid_Blks[i] = new Grid3D_Hexa_Block*[domyy];
      for (int j = 0 ; j <domyy ; ++j ) {
         Grid_Blks[i][j] = new Grid3D_Hexa_Block[domzz];
      }  /* endfor */
  }/* endfor */ 

  /***** Return the domain layout of the mesh ******/
  domx_buf = domxx;
  domy_buf = domyy;
  domz_buf = domzz;

  for(int z =0; z < domzz; z++){
    for (int y = 0; y < domyy; y++) {
      for (int x = 0; x < domxx; x++) {

      //cout <<"\n x, y, z = "<<x<<", "<<y<<", "<<z; cout.flush();
      //cout <<"\n layout [x][y][z] = " <<layout [x][y][z]; cout.flush();
	
	/****** Ignore if domain number is 0 *******/
	if (layout[x][y][z]!=0){

	sprintf(dom_name,"domain.%d",layout[x][y][z]);

        // *********** ICEM PART
	mode=MODE_READ;
	type=STRUCTURED_DOMAIN;

	// OPEN the domain file 
	file_no=df_open(dom_name, mode, type);
	if (file_no<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */
      
	// GET the number of subdomains
	ier = df_n_domain(file_no,&n_domain);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	// Get node range
	ier = df_struct_domain_range(file_no,n_domain-1,imin,imax);
	if (ier<0) {
           ICEMCFD_error(); 
           return (NULL);
        } /* endif */

	Ni=imax[0];
	Nj=imax[1];
	Nk=imax[2];

	n_nodes=Ni*Nj*Nk*3;

	// READ all the nodes from ICEM domain file
	node_pnts=(double *)malloc(n_nodes*sizeof(double));

	ier=df_struct_read_nodes(file_no, n_domain-1, imin,imax, node_pnts);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	// CLOSE the domain file
	ier=df_close(file_no);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	//****** Allocate memory for current domain *********/	
	//Grid_Blks[x][y][z].allocate(Ni-1,Nj-1,Nk-1,Nghost);
	//Grid_ptr[x][y][z] = new Grid3D_Hexa_Block(Ni-1, Nj-1, Nk-1, Nghost);
        Grid_Blks[x][y][z].allocate(Ni-1, Nj-1, Nk-1, Nghost);

	// Convert 1D array of nodes into a 3D array
	for ( int k = Grid_Blks[x][y][z].KNl; k <= Grid_Blks[x][y][z].KNu; k++) {
	  for (int j =  Grid_Blks[x][y][z].JNl; j <= Grid_Blks[x][y][z].JNu; j++) {
	    for (int i = Grid_Blks[x][y][z].INl; i <= Grid_Blks[x][y][z].INu; i++) {

	      Grid_Blks[x][y][z].Node[i][j][k].X.x = node_pnts[3*(i-Grid_Blks[x][y][z].INl+
								 Ni*(j-Grid_Blks[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_Blks[x][y][z].KNl))+0];
	      Grid_Blks[x][y][z].Node[i][j][k].X.y = node_pnts[3*(i-Grid_Blks[x][y][z].INl+
								 Ni*(j-Grid_Blks[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_Blks[x][y][z].KNl))+1];
	      Grid_Blks[x][y][z].Node[i][j][k].X.z = node_pnts[3*(i-Grid_Blks[x][y][z].INl+
								 Ni*(j-Grid_Blks[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_Blks[x][y][z].KNl))+2];

	    } /* endfor */
	  } /* endfor */
	}/* endfor */
	
// 	  for (i=0; i<6; i++) {
// 	    subfaces[i] = UNDEFINED_FACE_NUMBER;
// 	  } // endfor
// 	  for (i=1; i<5; i++) {
// 	    ier = tp_subface_range(layout[x][y][z], i, jmin, jmax);

// 	    if (ier<0) {
// 	      cout << "\nError reading face info\n";
// 	      ICEMCFD_error();
// 	      return (NULL);
// 	    } // endif 
// 	    // NOTE the following has not been tested, 
// 	    //I think it's based on a cube with origin at (1,1,1), and side lengths undetermined (ie dx,dy,dz) 
// 	    //  therefore 'jmax[0]!=1' means the maximum x value is at 1+dx
// 	    if     (jmin[0]==1 && jmin[1]==1 && jmin[2]==1 && jmax[0]!=1 && jmax[1]==1 && jmax[2]!=1) 
// 	      subfaces[0]=i; //south
// 	    else if(jmin[0]==1 && jmin[1]==1 && jmin[2]==1 && jmax[0]==1 && jmax[1]!=1 && jmax[2]!=1) 
// 	      subfaces[1]=i; //west
// 	    else if(jmin[0]==1 && jmin[1]!=1 && jmin[2]==1 && jmax[0]!=1 && jmax[1]!=1 && jmax[2]!=1) 
// 	      subfaces[2]=i; //north
// 	    else if(jmin[0]!=1 && jmin[1]==1 && jmin[2]==1 && jmax[0]!=1 && jmax[1]!=1 && jmax[2]!=1) 
// 	      subfaces[3]=i; //east
// 	    else if(jmin[0]==1 && jmin[1]==1 && jmin[2]!=1 && jmax[0]!=1 && jmax[1]!=1 && jmax[2]!=1) 
// 	      subfaces[4]=i; //Top
// 	    else if(jmin[0]==1 && jmin[1]==1 && jmin[2]==1 && jmax[0]!=1 && jmax[1]!=1 && jmax[2]==1) 
// 	      subfaces[5]=i; //Bottom
// 	    else {
// 	      //printf("***ERROR: Can;t figure out the boundary subfaces!!!");
// 	    }
// 	  } // endfor 

  
	  
// 	  //******* Assign boundary conditions for the north and south edge ********  
// 	  ICEMCFD_set_boco3D(subfaces[2],Grid_Blks[x][y][z].BCs_N);  
// 	  ICEMCFD_set_boco3D(subfaces[0],Grid_Blks[x][y][z].BCs_S);

//           for (int  k =  Grid_Blks[x][y][z].KCl - Nghost ; 
//                     k <=  Grid_Blks[x][y][z].KCu + Nghost ; ++k) 
//               for ( int i =  Grid_Blks[x][y][z].ICl - Nghost ; 
//                         i <=  Grid_Blks[x][y][z].ICu + Nghost ; ++i){

// 	      Grid_Blks[x][y][z].BCtypeN[i][k]=Grid_Blks[x][y][z].BCs_N.Type;
// 	      Grid_Blks[x][y][z].BCtypeS[i][k]=Grid_Blks[x][y][z].BCs_S.Type;
//	    }

// 	  //******* Assign boundary conditions for the east and west edge ********
// 	  ICEMCFD_set_boco3D(subfaces[3],Grid_Blks[x][y][z].BCs_E);
// 	  ICEMCFD_set_boco3D(subfaces[1],Grid_Blks[x][y][z].BCs_W);

//           for ( int k =  Grid_Blks[x][y][z].KCl - Nghost ; 
//                      k <=  Grid_Blks[x][y][z].KCu + Nghost ; ++k) 
//               for ( int j =  Grid_Blks[x][y][z].JCl - Nghost ; 
//                         j <=  Grid_Blks[x][y][z].JCu + Nghost ; ++j){

// 	      Grid_Blks[x][y][z].BCtypeE[j][k]=Grid_Blks[x][y][z].BCs_E.Type;
// 	      Grid_Blks[x][y][z].BCtypeW[j][k]=Grid_Blks[x][y][z].BCs_W.Type;
// 	    }
	  
// 	  //******* Assign boundary conditions for the top and bottom edge ********
// 	  ICEMCFD_set_boco3D(subfaces[4],Grid_Blks[x][y][z].BCs_T);
// 	  ICEMCFD_set_boco3D(subfaces[5],Grid_Blks[x][y][z].BCs_B);
//           for (int  j =  Grid_Blks[x][y][z].JCl- Nghost ; 
//                     j <=  Grid_Blks[x][y][z].JCu+Nghost ; ++j) 
//              for (int  i =  Grid_Blks[x][y][z].ICl- Nghost ; 
//                        i <=  Grid_Blks[x][y][z].ICu+ Nghost ; ++i) {

// 	      Grid_Blks[x][y][z].BCtypeT[i][j]=Grid_Blks[x][y][z].BCs_T.Type;
// 	      Grid_Blks[x][y][z].BCtypeB[i][j]=Grid_Blks[x][y][z].BCs_B.Type;
//          }


        /****** Process the Grid *******/
  	Grid_Blks[x][y][z].Update_Cells();

      }else{
//        Grid_Blks[x][y][z].Node = NULL;	  
      }/* endif */
     } /* endfor */
    } /* endfor */
  } /* endfor */  

#endif

   return (Grid_Blks);  
}


/**************************************************************************
ICEMCFD_get_boco is a function that compares the family name
of an edges to the predefined values for boundary 
conditions and returns that value.
In other words, the boundary conditions of an edges is 
set by grouping the edge into a family with one of the
following names.  BC_NONE is the default boundary type.

This function is only used in the following ICEMCFD_set_boco() function

THIS ENTIRE FUNCTION HAS CHANGED FROM ITS ORIGINAL FORM -Tim Blair May 2004
****************************************************************************/
int ICEMCFD_get_boco(int boco){
  switch (boco){
  case 1: return BC_NULL;
  case 2: return BC_AXISYMMETRIC_WEDGE;
  case 3: return BC_DEGENERATE_LINE;
  case 4: return BC_DEGENERATE_POINT;
  case 5: return BC_DIRICHLET;
  case 6: return BC_EXTRAPOLATE;
  case 7: return BC_FARFIELD;
  case 8: return BC_GENERAL;
  case 9: return BC_INFLOW;
  case 10: return BC_INFLOW_SUBSONIC;
  case 11: return BC_INFLOW_SUPERSONIC;
  case 12: return BC_NEUMANN;
  case 13: return BC_OUTFLOW;
  case 14: return BC_OUTFLOW_SUBSONIC;
  case 15: return BC_OUTFLOW_SUPERSONIC;
  case 16: return BC_SYMMETRY_PLANE;
  case 17: return BC_SYMMETRY_POLAR;
  case 18: return BC_TUNNEL_INFLOW;
  case 19: return BC_TUNNEL_OUTFLOW;
  case 20: return BC_WALL ;
  case 21: return BC_WALL_INVISCID;
  case 22: return BC_WALL_VISCOUS;
  case 23: return BC_WALL_VISCOUS_HEATFLUX;
  case 24: return BC_WALL_VISCOUS_ISOTHERMAL;
  default: return BC_NULL;
  }
}


/***********************************
 *  ICEMCFD_get_bocoData           *
 ***********************************/

int ICEMCFD_get_bocoData(char *DataType){
  
  if (strcmp(DataType, "Potential") == 0) return BC_DATA_POTENTIAL;
  if (strcmp(DataType, "StreamFunction") == 0) return BC_DATA_STREAMFUNCTION;
  if (strcmp(DataType, "Density") == 0) return BC_DATA_DENSITY;
  if (strcmp(DataType, "Pressure") == 0) return BC_DATA_PRESSURE;
  if (strcmp(DataType, "Temperature") == 0) return BC_DATA_TEMPERATURE;
  if (strcmp(DataType, "EnergyInternal") == 0) return BC_DATA_ENERGYINTERNAL;
  if (strcmp(DataType, "Enthalpy") == 0) return BC_DATA_ENTHALPY;
  if (strcmp(DataType, "Entropy") == 0) return BC_DATA_ENTROPY;
  if (strcmp(DataType, "EntropyApprox") == 0) return BC_DATA_ENTROPYAPPROX;
  if (strcmp(DataType, "DensityStagnation") == 0) return BC_DATA_DENSITYSTAGNATION;
  if (strcmp(DataType, "PressureStagnation") == 0) return BC_DATA_PRESSURESTAGNATION;
  if (strcmp(DataType, "TemperatureStagnation") == 0) return BC_DATA_TEMPERATURESTAGNATION;
  if (strcmp(DataType, "EnergyStagnation") == 0) return BC_DATA_ENERGYSTAGNATION;
  if (strcmp(DataType, "EnthalpyStagnation") == 0) return BC_DATA_ENTHALPYSTAGNATION;
  if (strcmp(DataType, "EnergyStagnationDensity") == 0) return BC_DATA_ENERGYSTAGNATIONDENSITY;
  if (strcmp(DataType, "VelocityX") == 0) return BC_DATA_VELOCITYX;
  if (strcmp(DataType, "VelocityY") == 0) return BC_DATA_VELOCITYY;
  if (strcmp(DataType, "VelocityZ") == 0) return BC_DATA_VELOCITYZ;
  if (strcmp(DataType, "VelocityR") == 0) return BC_DATA_VELOCITYR;
  if (strcmp(DataType, "VelocityTheta") == 0) return BC_DATA_VELOCITYTHETA;
  if (strcmp(DataType, "VelocityPhi") == 0) return BC_DATA_VELOCITYPHI;
  if (strcmp(DataType, "VelocityMagnitude") == 0) return BC_DATA_VELOCITYMAGNITUDE;
  if (strcmp(DataType, "VelocityNormal") == 0) return BC_DATA_VELOCITYNORMAL;
  if (strcmp(DataType, "VelocityTangential") == 0) return BC_DATA_VELOCITYTANGENTIAL;
  if (strcmp(DataType, "VelocitySound") == 0) return BC_DATA_VELOCITYSOUND;
  if (strcmp(DataType, "VelocitySoundStagnation") == 0) return BC_DATA_VELOCITYSOUNDSTAGNATION;
  if (strcmp(DataType, "MomentumX") == 0) return BC_DATA_MOMENTUMX;
  if (strcmp(DataType, "MomentumY") == 0) return BC_DATA_MOMENTUMY;
  if (strcmp(DataType, "MomentumZ") == 0) return BC_DATA_MOMENTUMZ;
  if (strcmp(DataType, "MomentumMagnitude") == 0) return BC_DATA_MOMENTUMMAGNITUDE;
  if (strcmp(DataType, "EnergyKinetic") == 0) return BC_DATA_ENERGYKINETIC;
  if (strcmp(DataType, "PressureDynamic") == 0) return BC_DATA_PRESSUREDYNAMIC;
  if (strcmp(DataType, "VorticityX") == 0) return BC_DATA_VORTICITYX;
  if (strcmp(DataType, "VorticityY") == 0) return BC_DATA_VORTICITYY;
  if (strcmp(DataType, "VorticityZ") == 0) return BC_DATA_VORTICITYZ;
  if (strcmp(DataType, "VorticityMagnitude") == 0) return BC_DATA_VORTICITYMAGNITUDE;
  if (strcmp(DataType, "SkinFrictionX") == 0) return BC_DATA_SKINFRICTIONX;
  if (strcmp(DataType, "SkinFrictionY") == 0) return BC_DATA_SKINFRICTIONY;
  if (strcmp(DataType, "SkinFrictionZ") == 0) return BC_DATA_SKINFRICTIONZ;
  if (strcmp(DataType, "SkinFrictionMagnitude") == 0) return BC_DATA_SKINFRICTIONMAGNITUDE;
  if (strcmp(DataType, "VelocityAngleX") == 0) return BC_DATA_VELOCITYANGLEX;
  if (strcmp(DataType, "VelocityAngleY") == 0) return BC_DATA_VELOCITYANGLEY;
  if (strcmp(DataType, "VelocityAngleZ") == 0) return BC_DATA_VELOCITYANGLEZ;
  if (strcmp(DataType, "VelocityUnitVectorX") == 0) return BC_DATA_VELOCITYUNITVECTORX;
  if (strcmp(DataType, "VelocityUnitVectorY") == 0) return BC_DATA_VELOCITYUNITVECTORY;
  if (strcmp(DataType, "VelocityUnitVectorZ") == 0) return BC_DATA_VELOCITYUNITVECTORZ;
  if (strcmp(DataType, "MassFlow") == 0) return BC_DATA_MASSFLOW;
  if (strcmp(DataType, "ViscosityKinematic") == 0) return BC_DATA_VISCOSITYKINEMATIC;
  if (strcmp(DataType, "ViscosityMolecular") == 0) return BC_DATA_VISCOSITYMOLECULAR;
  if (strcmp(DataType, "ViscosityEddyKinematic") == 0) return BC_DATA_VISCOSITYEDDYKINEMATIC;
  if (strcmp(DataType, "ViscosityEddy") == 0) return BC_DATA_VISCOSITYEDDY;
  if (strcmp(DataType, "ThermalConductivity") == 0) return BC_DATA_THERMALCONDUCTIVITY;
  if (strcmp(DataType, "PowerLawExponent") == 0) return BC_DATA_POWERLAWEXPONENT;
  if (strcmp(DataType, "SutherlandLawConstant") == 0) return BC_DATA_SUTHERLANDLAWCONSTANT;
  if (strcmp(DataType, "TemperatureReference") == 0) return BC_DATA_TEMPERATUREREFERENCE;
  if (strcmp(DataType, "ViscosityMolecularReference") == 0) return BC_DATA_VISCOSITYMOLECULARREFERENCE;
  if (strcmp(DataType, "ThermalConductivityReference") == 0) return BC_DATA_THERMALCONDUCTIVITYREFERENCE;
  if (strcmp(DataType, "IdealGasConstant") == 0) return BC_DATA_IDEALGASCONSTANT;
  if (strcmp(DataType, "SpecificHeatPressure") == 0) return BC_DATA_SPECIFICHEATPRESSURE;
  if (strcmp(DataType, "SpecificHeatVolume") == 0) return BC_DATA_SPECIFICHEATVOLUME;
  if (strcmp(DataType, "ReynoldsStressXX") == 0) return BC_DATA_REYNOLDSSTRESSXX;
  if (strcmp(DataType, "ReynoldsStressXY") == 0) return BC_DATA_REYNOLDSSTRESSXY;
  if (strcmp(DataType, "ReynoldsStressXZ") == 0) return BC_DATA_REYNOLDSSTRESSXZ;
  if (strcmp(DataType, "ReynoldsStressYY") == 0) return BC_DATA_REYNOLDSSTRESSYY;
  if (strcmp(DataType, "ReynoldsStressYZ") == 0) return BC_DATA_REYNOLDSSTRESSYZ;
  if (strcmp(DataType, "ReynoldsStressZZ") == 0) return BC_DATA_REYNOLDSSTRESSZZ;
  if (strcmp(DataType, "LengthReference") == 0) return BC_DATA_LENGTHREFERENCE;
  if (strcmp(DataType, "Undefined") == 0) return BC_DATA_UNDEFINED;
}


/***********************************
 *  ICEMCFD_set_boco3D             *
 ***********************************/

void ICEMCFD_set_boco3D(int subface_no, BCinfoCGNS &BCs){
#ifdef _ICEMCFD_VERSION

  void **values = NULL ;
  int *types = NULL; 
  int boco = BC_NULL;  
  int flag = bc_get_data(2/*domain subfaces only*/,subface_no,2,&types,&values);

  if(flag >0){
    if(!strcmp((char*)values[0],"TYPE")) {
      boco = ICEMCFD_get_boco(int(*((float*)values[1])));
      }
    else if (!strcmp((char*)values[0],"BCDataSet")){
      boco = ICEMCFD_get_boco(int(*((float*)values[6])));
      for(int i=0; i<5; i++){
	  BCs.DataType[i] = ICEMCFD_get_bocoData((char*)values[i+1]);
	  BCs.DataValue[i] = *((float*)values[i+9]);
      }
    }else {
      boco = BC_NULL;
      printf("***ERROR: NOT CGNS STANDARD***");}
  }
  else boco = BC_NULL;
  BCs.Type = (boco);
#endif
}













