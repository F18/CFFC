/*! \file Euler2DQuad_HighOrder.cc
  @brief High-order Subroutines for 2D Euler Equations Quadrilateral Mesh Solution Classes. */

/* Include required C++ libraries. */
// None

/* Using std namespace functions */
// None

/* Include CFFC header files */
#include "Euler2DQuad.h"	// Euler2D_Quad_Block class

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the nodes of the defined region of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 *
 * \param StartI_CellIndex index of the first cell in i-direction used to output the solution
 * \param EndI_CellIndex index of the last cell in i-direction used to output the solution
 * \param StartJ_CellIndex index of the first cell in j-direction used to output the solution
 * \param EndJ_CellIndex index of the last cell in j-direction used to output the solution
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 */
void Euler2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							const double &Time,
							const int &Block_Number,
							const int &Output_Title,
							ostream &Out_File,
							const int & StartI_CellIndex,
							const int & EndI_CellIndex,
							const int & StartJ_CellIndex,
							const int & EndJ_CellIndex,
							const int &IndexHO) {

    int i, j, nRow, nLoop;
    Euler2D_pState W_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("Euler2D_Quad_Block::Output_Nodes_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output node solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Euler Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"rho\" \\ \n"
	       << "\"u\" \\ \n"
	       << "\"v\" \\ \n"
	       << "\"p\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "\"T\" \n"
		 << "\"M\" \n"
		 << "\"H\" \n"
		 << "\"s\" \n";
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "\"ValISrho\" \\ \n"
		 << "\"ISrho\" \\ \n"
		 << "\"ValISu\" \\ \n"
		 << "\"ISu\" \\ \n"
		 << "\"ValISv\" \\ \n"
		 << "\"ISv\" \\ \n"
		 << "\"ValISp\" \\ \n"
		 << "\"ISp\" \\ \n";

	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln_rho\" \\ \n"
		   << "\"ExactSoln_u\" \\ \n"
		   << "\"ExactSoln_v\" \\ \n"
		   << "\"ExactSoln_p\" \\ \n";
	}
      }

      // Add more variables for the Extended format
      if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	Out_File << "\"ResidualRho\" \\ \n"
		 << "\"ResidualDvX\" \\ \n"
		 << "\"ResidualDvY\" \\ \n"
		 << "\"ResidualE\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (EndI_CellIndex - StartI_CellIndex + 1)*3  << " \\ \n"
	       << "J = " << (EndJ_CellIndex - StartJ_CellIndex + 1)*3 << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (EndI_CellIndex - StartI_CellIndex + 1)*3  << " \\ \n"
	       << "J = " << (EndJ_CellIndex - StartJ_CellIndex + 1)*3 << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT ";

	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
	}
      }

      // Extended format
      if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for ( j  = StartJ_CellIndex ; j <= EndJ_CellIndex ; ++j ) {	// for every j Cell
      for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
	for ( i = StartI_CellIndex ; i <= EndI_CellIndex ; ++i ) { // for every i Cell
	  for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	    // Get the node location
	    switch(nRow){
	    case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeSW(i,j)
		Node = Grid.nodeSW(i,j).X;
		break;
	      case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCl && Grid.BndSouthSplineInfo != NULL){
		  Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceS(i,j);
		}
		break;
	      case 3:		// output NodeSE(i,j)
		Node = Grid.nodeSE(i,j).X;
		break;
	      }
	      break;

	    case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	      switch(nLoop){
	      case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICl && Grid.BndWestSplineInfo != NULL){
		  Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceW(i,j);
		}
		break;
	      case 2:		// output Grid.CellCentroid(i,j)
		Node = Grid.CellCentroid(i,j);
		break;
	      case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICu && Grid.BndEastSplineInfo != NULL){
		  Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceE(i,j);
		}
		break;
	      }
	      break;

	    case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeNW(i,j)
		Node = Grid.nodeNW(i,j).X;
		break;
	      case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCu && Grid.BndNorthSplineInfo != NULL){
		  Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceN(i,j);
		}
		break;
	      case 3:		// output NodeNE(i,j)
		Node = Grid.nodeNE(i,j).X;
		break;
	      }
	      break;
	    } // endswitch

	    // Output Brief format
	    W_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << W_node;

	    
	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File.setf(ios::scientific);
	      Out_File << " " << W_node.T()
		       << " " << W_node.v.abs()/W_node.a() 
		       << " " << W_node.H()
		       << " " << W_node.s();
	      Out_File.unsetf(ios::scientific);
	    }


	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,2)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,2)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,3)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,3)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,4)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,4);
	      Out_File.unsetf(ios::scientific);
	      if (ExactSoln->IsExactSolutionSet()){
		Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	      }
	    }


	    // Add more variables for the Extended format
	    if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	      Out_File << " " << dUdt[i][j][0];
	    }

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);

	  }
	} /* endfor */
      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the interior nodes of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 *
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void Euler2D_Quad_Block::Output_Tecplot_HighOrder(const int &Number_of_Time_Steps,
						  const double &Time,
						  const int &Block_Number,
						  const int &Output_Title,
						  ostream &Out_File,
						  const int &IndexHO) {

  return Output_Nodes_Tecplot_HighOrder(Number_of_Time_Steps,
					Time,
					Block_Number,
					Output_Title,
					Out_File,
					ICl, ICu, JCl, JCu,
					IndexHO);
}

/*!
 * Writes the solution values at the interior nodes of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note This subroutine is only used for debugging!
 */
void Euler2D_Quad_Block::Output_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
							     const Euler2D_Input_Parameters &IP,
							     const int &Block_Number,
							     const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  
  /* Open the output data file. */
  
  output_file.open(output_file_name, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }
  
  try {
    Output_Tecplot_HighOrder(0,0,
			     Block_Number,
			     1,
			     output_file,
			     IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }

  /* Close the output data file. */
  output_file.close();

  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all nodes (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 */
void Euler2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							const double &Time,
							const int &Block_Number,
							const int &Output_Title,
							ostream &Out_File,
							const int &IndexHO) {

  return Output_Nodes_Tecplot_HighOrder(Number_of_Time_Steps,
					Time,
					Block_Number,
					Output_Title,
					Out_File,
					ICl - HighOrderVariable(IndexHO).NghostHO(),
					ICu + HighOrderVariable(IndexHO).NghostHO(),
					JCl - HighOrderVariable(IndexHO).NghostHO(),
					JCu + HighOrderVariable(IndexHO).NghostHO(),
					IndexHO);
}

/*!
 * Writes the solution values at the nodes (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void Euler2D_Quad_Block::Output_Nodes_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								   const Euler2D_Input_Parameters &IP,
								   const int &Block_Number,
								   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_nodes_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Nodes_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Nodes_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all cells (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void Euler2D_Quad_Block::Output_Cells_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							const double &Time,
							const int &Block_Number,
							const int &Output_Title,
							ostream &Out_File,
							const int &IndexHO) {


    int i, j;
    Euler2D_pState W_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("Euler2D_Quad_Block::Output_Cells_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output cell centroid solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"rho\" \\ \n"
	       << "\"u\" \\ \n"
	       << "\"v\" \\ \n"
	       << "\"p\" \\ \n";
      
      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"rhoAvg\" \\ \n"
		  << "\"uAvg\" \\ \n"
		  << "\"vAvg\" \\ \n"
		  << "\"pAvg\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln_rho\" \\ \n"
		   << "\"ExactSoln_u\" \\ \n"
		   << "\"ExactSoln_v\" \\ \n"
		   << "\"ExactSoln_p\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){

	Out_File << "\"ValISrho\" \\ \n"
		 << "\"ISrho\" \\ \n"
		 << "\"ValISu\" \\ \n"
		 << "\"ISu\" \\ \n"
		 << "\"ValISv\" \\ \n"
		 << "\"ISv\" \\ \n"
		 << "\"ValISp\" \\ \n"
		 << "\"ISp\" \\ \n"
		 << "\"ResidualRho\" \\ \n"
		 << "\"ResidualDvX\" \\ \n"
		 << "\"ResidualDvY\" \\ \n"
		 << "\"ResidualE\" \\ \n"
		 << "\"dt\" \\ \n";
      }
      
      // Add more variables for the Extended format
      if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	switch(HighOrderVariable(IndexHO).RecOrder()){
	case 4:	  // 4th-order derivatives
	  Out_File << "\"dxxxxrho\" \\ \n"
		   << "\"dxxxxu\" \\ \n"
		   << "\"dxxxxv\" \\ \n"
		   << "\"dxxxxp\" \\ \n"
		   << "\"dxxxyrho\" \\ \n"
		   << "\"dxxxyu\" \\ \n"
		   << "\"dxxxyv\" \\ \n"
		   << "\"dxxxyp\" \\ \n"
		   << "\"dxxyyrho\" \\ \n"
		   << "\"dxxyyu\" \\ \n"
		   << "\"dxxyyv\" \\ \n"
		   << "\"dxxyyp\" \\ \n"
		   << "\"dxyyyrho\" \\ \n"
		   << "\"dxyyyu\" \\ \n"
		   << "\"dxyyyv\" \\ \n"
		   << "\"dxyyyp\" \\ \n"
		   << "\"dyyyyrho\" \\ \n"
		   << "\"dyyyyu\" \\ \n"
		   << "\"dyyyyv\" \\ \n"
		   << "\"dyyyyp\" \\ \n";
	  
	case 3:   // 3rd-order derivatives
	  Out_File << "\"dxxxrho\" \\ \n"
		   << "\"dxxxu\" \\ \n"
		   << "\"dxxxv\" \\ \n"
		   << "\"dxxxp\" \\ \n"
		   << "\"dxxyrho\" \\ \n"
		   << "\"dxxyu\" \\ \n"
		   << "\"dxxyv\" \\ \n"
		   << "\"dxxyp\" \\ \n"
		   << "\"dxyyrho\" \\ \n"
		   << "\"dxyyu\" \\ \n"
		   << "\"dxyyv\" \\ \n"
		   << "\"dxyyp\" \\ \n"
		   << "\"dyyyrho\" \\ \n"
		   << "\"dyyyu\" \\ \n"
		   << "\"dyyyv\" \\ \n"
		   << "\"dyyyp\" \\ \n";

	case 2: 	 // 2nd-order derivatives
	  Out_File << "\"dxxrho\" \\ \n"
		   << "\"dxxu\" \\ \n"
		   << "\"dxxv\" \\ \n"
		   << "\"dxxp\" \\ \n"
		   << "\"dxyrho\" \\ \n"
		   << "\"dxyu\" \\ \n"
		   << "\"dxyv\" \\ \n"
		   << "\"dxyp\" \\ \n"
		   << "\"dyyrho\" \\ \n"
		   << "\"dyyu\" \\ \n"
		   << "\"dyyv\" \\ \n"
		   << "\"dyyp\" \\ \n";
	case 1:   // 1st-order derivatives
	  Out_File << "\"dxrho\" \\ \n"
		   << "\"dxu\" \\ \n"
		   << "\"dxv\" \\ \n"
		   << "\"dxp\" \\ \n"
		   << "\"dyrho\" \\ \n"
		   << "\"dyu\" \\ \n"
		   << "\"dyv\" \\ \n"
		   << "\"dyp\" \\ \n"
		   << "\"phirho\" \\ \n"
		   << "\"phiu\" \\ \n"
		   << "\"phiv\" \\ \n"
		   << "\"phip\" \\ \n";
	} // endswitch

	Out_File << "\"T\"  \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";
      }

      // Extended format
      if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	switch(HighOrderVariable(IndexHO).RecOrder()){
	case 4:	  // 4th-order derivatives
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		   << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

	case 3:   // 3rd-order derivatives
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		   << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

	case 2: 	 // 2nd-order derivatives
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		   << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

	case 1:   // 1st-order derivatives
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		   << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";	  
	  
	}

	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for (j = JCl-Nghost; j <= JCu+Nghost; ++j) {// for every j Cell
      for (i = ICl-Nghost; i <= ICu+Nghost; ++i) {// for every i Cell

	// Set the location
	Node = Grid.CellCentroid(i,j);

	if (i < ICl-HighOrderVariable(IndexHO).NghostHO() || 
	    i > ICu+HighOrderVariable(IndexHO).NghostHO() || 
	    j < JCl-HighOrderVariable(IndexHO).NghostHO() ||
	    j > JCu+HighOrderVariable(IndexHO).NghostHO()  ) {

	  // No high-order interpolant is calculated for this cells.
	  // The average solution is plotted at the centers of these cells.
	  
	  // Output Brief format
	  Out_File << " "  << Node 
		   << " "  << CellSolution(i,j);

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File.setf(ios::scientific);
	    Out_File << " " << 1.0E8
		     << " " << 0
		     << " " << 1.0E8
		     << " " << 0
		     << " " << 1.0E8
		     << " " << 0
		     << " " << 1.0E8
		     << " " << 0;
	    Out_File.unsetf(ios::scientific);	    
	    Out_File << " " << dUdt[i][j][0]
		     << " " << dt[i][j];
	  }

	  // Add more variables for the Extended format
	  if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	    switch(HighOrderVariable(IndexHO).RecOrder()){
	    case 4:    // 4th-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,4,0) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,1) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,2) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,3) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,4);

	    case 3:   // 3rd-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,0)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,1)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,2)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,3);

	    case 2:    // 2nd-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,0)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,1)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,2);

	    case 1:	    
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,0) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,1) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDeriv(i,j).Limiter();
	    }
	    
	    Out_File << " " << 0.0;
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} else {

	  // Use the high-order interpolant to calculate the solution at the cell centroids.
	  
	  // Output Brief format
	  W_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	  Out_File << " "  << Node 
		   << " "  << W_node;

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File.setf(ios::scientific);
	    Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1)
		     << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,2)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,2)
		     << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,3)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,3)
		     << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,4)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,4);
	    Out_File.unsetf(ios::scientific);
	    Out_File << " " << dUdt[i][j][0]
		     << " " << dt[i][j];
	  }

	  // Add more variables for the Extended format
	  if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	    switch(HighOrderVariable(IndexHO).RecOrder()){
	    case 4:    // 4th-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,4,0) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,1) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,2) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,3) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,4);
	      
	    case 3:   // 3rd-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,0)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,1)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,2)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,3);
	      
	    case 2:    // 2nd-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,0)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,1)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,2);

	    case 1:	    
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,0) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,1) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDeriv(i,j).Limiter();
	    }
	    
	    Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,0).T();
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} // endif

      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the centroids (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost cells for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void Euler2D_Quad_Block::Output_Cells_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								   const Euler2D_Input_Parameters &IP,
								   const int &Block_Number,
								   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cells_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Cells_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Cells_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}
