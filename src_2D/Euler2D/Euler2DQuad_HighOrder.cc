/*! \file Euler2DQuad_HighOrder.cc
  @brief High-order Subroutines for 2D Euler Equations Quadrilateral Mesh Solution Classes. */

/* Include required C++ libraries. */
// None

/* Using std namespace functions */
// None

/* Include CFFC header files */
#include "Euler2DQuad.h"	// Euler2D_Quad_Block class

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the nodes of the defined region of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 *
 * \param StartI_CellIndex index of the first cell in i-direction used to output the solution
 * \param EndI_CellIndex index of the last cell in i-direction used to output the solution
 * \param StartJ_CellIndex index of the first cell in j-direction used to output the solution
 * \param EndJ_CellIndex index of the last cell in j-direction used to output the solution
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 */
void Euler2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							const double &Time,
							const int &Block_Number,
							const int &Output_Title,
							ostream &Out_File,
							const int & StartI_CellIndex,
							const int & EndI_CellIndex,
							const int & StartJ_CellIndex,
							const int & EndJ_CellIndex,
							const int &IndexHO) {

    int i, j, nRow, nLoop;
    Euler2D_pState W_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("Euler2D_Quad_Block::Output_Nodes_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output node solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Euler Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"rho\" \\ \n"
	       << "\"u\" \\ \n"
	       << "\"v\" \\ \n"
	       << "\"p\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "\"T\" \n"
		 << "\"M\" \n"
		 << "\"H\" \n"
		 << "\"s\" \n";
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "\"ValISrho\" \\ \n"
		 << "\"ISrho\" \\ \n"
		 << "\"ValISu\" \\ \n"
		 << "\"ISu\" \\ \n"
		 << "\"ValISv\" \\ \n"
		 << "\"ISv\" \\ \n"
		 << "\"ValISp\" \\ \n"
		 << "\"ISp\" \\ \n";

	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln_rho\" \\ \n"
		   << "\"ExactSoln_u\" \\ \n"
		   << "\"ExactSoln_v\" \\ \n"
		   << "\"ExactSoln_p\" \\ \n";
	}
      }

      // Add more variables for the Extended format
      if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	Out_File << "\"ResidualRho\" \\ \n"
		 << "\"ResidualDvX\" \\ \n"
		 << "\"ResidualDvY\" \\ \n"
		 << "\"ResidualE\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (EndI_CellIndex - StartI_CellIndex + 1)*3  << " \\ \n"
	       << "J = " << (EndJ_CellIndex - StartJ_CellIndex + 1)*3 << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (EndI_CellIndex - StartI_CellIndex + 1)*3  << " \\ \n"
	       << "J = " << (EndJ_CellIndex - StartJ_CellIndex + 1)*3 << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT ";

	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
	}
      }

      // Extended format
      if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for ( j  = StartJ_CellIndex ; j <= EndJ_CellIndex ; ++j ) {	// for every j Cell
      for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
	for ( i = StartI_CellIndex ; i <= EndI_CellIndex ; ++i ) { // for every i Cell
	  for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	    // Get the node location
	    switch(nRow){
	    case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeSW(i,j)
		Node = Grid.nodeSW(i,j).X;
		break;
	      case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCl && Grid.BndSouthSplineInfo != NULL){
		  Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceS(i,j);
		}
		break;
	      case 3:		// output NodeSE(i,j)
		Node = Grid.nodeSE(i,j).X;
		break;
	      }
	      break;

	    case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	      switch(nLoop){
	      case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICl && Grid.BndWestSplineInfo != NULL){
		  Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceW(i,j);
		}
		break;
	      case 2:		// output Grid.CellCentroid(i,j)
		Node = Grid.CellCentroid(i,j);
		break;
	      case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICu && Grid.BndEastSplineInfo != NULL){
		  Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceE(i,j);
		}
		break;
	      }
	      break;

	    case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeNW(i,j)
		Node = Grid.nodeNW(i,j).X;
		break;
	      case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCu && Grid.BndNorthSplineInfo != NULL){
		  Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceN(i,j);
		}
		break;
	      case 3:		// output NodeNE(i,j)
		Node = Grid.nodeNE(i,j).X;
		break;
	      }
	      break;
	    } // endswitch

	    // Output Brief format
	    W_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << W_node;

	    
	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File.setf(ios::scientific);
	      Out_File << " " << W_node.T()
		       << " " << W_node.v.abs()/W_node.a() 
		       << " " << W_node.H()
		       << " " << W_node.s();
	      Out_File.unsetf(ios::scientific);
	    }


	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,2)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,2)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,3)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,3)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,4)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,4);
	      Out_File.unsetf(ios::scientific);
	      if (ExactSoln->IsExactSolutionSet()){
		Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	      }
	    }


	    // Add more variables for the Extended format
	    if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	      Out_File << " " << dUdt[i][j][0];
	    }

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);

	  }
	} /* endfor */
      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the interior nodes of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 *
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void Euler2D_Quad_Block::Output_Tecplot_HighOrder(const int &Number_of_Time_Steps,
						  const double &Time,
						  const int &Block_Number,
						  const int &Output_Title,
						  ostream &Out_File,
						  const int &IndexHO) {

  return Output_Nodes_Tecplot_HighOrder(Number_of_Time_Steps,
					Time,
					Block_Number,
					Output_Title,
					Out_File,
					ICl, ICu, JCl, JCu,
					IndexHO);
}

/*!
 * Writes the solution values at the interior nodes of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note This subroutine is only used for debugging!
 */
void Euler2D_Quad_Block::Output_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
							     const Euler2D_Input_Parameters &IP,
							     const int &Block_Number,
							     const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  
  /* Open the output data file. */
  
  output_file.open(output_file_name, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }
  
  try {
    Output_Tecplot_HighOrder(0,0,
			     Block_Number,
			     1,
			     output_file,
			     IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }

  /* Close the output data file. */
  output_file.close();

  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all nodes (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 */
void Euler2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							const double &Time,
							const int &Block_Number,
							const int &Output_Title,
							ostream &Out_File,
							const int &IndexHO) {

  return Output_Nodes_Tecplot_HighOrder(Number_of_Time_Steps,
					Time,
					Block_Number,
					Output_Title,
					Out_File,
					ICl - HighOrderVariable(IndexHO).NghostHO(),
					ICu + HighOrderVariable(IndexHO).NghostHO(),
					JCl - HighOrderVariable(IndexHO).NghostHO(),
					JCu + HighOrderVariable(IndexHO).NghostHO(),
					IndexHO);
}

/*!
 * Writes the solution values at the nodes (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void Euler2D_Quad_Block::Output_Nodes_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								   const Euler2D_Input_Parameters &IP,
								   const int &Block_Number,
								   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_nodes_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Nodes_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Nodes_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all cells (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void Euler2D_Quad_Block::Output_Cells_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							const double &Time,
							const int &Block_Number,
							const int &Output_Title,
							ostream &Out_File,
							const int &IndexHO) {


    int i, j;
    Euler2D_pState W_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("Euler2D_Quad_Block::Output_Cells_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output cell centroid solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Euler Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"rho\" \\ \n"
	       << "\"u\" \\ \n"
	       << "\"v\" \\ \n"
	       << "\"p\" \\ \n";
      
      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"rhoAvg\" \\ \n"
		  << "\"uAvg\" \\ \n"
		  << "\"vAvg\" \\ \n"
		  << "\"pAvg\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln_rho\" \\ \n"
		   << "\"ExactSoln_u\" \\ \n"
		   << "\"ExactSoln_v\" \\ \n"
		   << "\"ExactSoln_p\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){

	Out_File << "\"ValISrho\" \\ \n"
		 << "\"ISrho\" \\ \n"
		 << "\"ValISu\" \\ \n"
		 << "\"ISu\" \\ \n"
		 << "\"ValISv\" \\ \n"
		 << "\"ISv\" \\ \n"
		 << "\"ValISp\" \\ \n"
		 << "\"ISp\" \\ \n"
		 << "\"ResidualRho\" \\ \n"
		 << "\"ResidualDvX\" \\ \n"
		 << "\"ResidualDvY\" \\ \n"
		 << "\"ResidualE\" \\ \n"
		 << "\"dt\" \\ \n";
      }
      
      // Add more variables for the Extended format
      if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	switch(HighOrderVariable(IndexHO).RecOrder()){
	case 4:	  // 4th-order derivatives
	  Out_File << "\"dxxxxrho\" \\ \n"
		   << "\"dxxxxu\" \\ \n"
		   << "\"dxxxxv\" \\ \n"
		   << "\"dxxxxp\" \\ \n"
		   << "\"dxxxyrho\" \\ \n"
		   << "\"dxxxyu\" \\ \n"
		   << "\"dxxxyv\" \\ \n"
		   << "\"dxxxyp\" \\ \n"
		   << "\"dxxyyrho\" \\ \n"
		   << "\"dxxyyu\" \\ \n"
		   << "\"dxxyyv\" \\ \n"
		   << "\"dxxyyp\" \\ \n"
		   << "\"dxyyyrho\" \\ \n"
		   << "\"dxyyyu\" \\ \n"
		   << "\"dxyyyv\" \\ \n"
		   << "\"dxyyyp\" \\ \n"
		   << "\"dyyyyrho\" \\ \n"
		   << "\"dyyyyu\" \\ \n"
		   << "\"dyyyyv\" \\ \n"
		   << "\"dyyyyp\" \\ \n";
	  
	case 3:   // 3rd-order derivatives
	  Out_File << "\"dxxxrho\" \\ \n"
		   << "\"dxxxu\" \\ \n"
		   << "\"dxxxv\" \\ \n"
		   << "\"dxxxp\" \\ \n"
		   << "\"dxxyrho\" \\ \n"
		   << "\"dxxyu\" \\ \n"
		   << "\"dxxyv\" \\ \n"
		   << "\"dxxyp\" \\ \n"
		   << "\"dxyyrho\" \\ \n"
		   << "\"dxyyu\" \\ \n"
		   << "\"dxyyv\" \\ \n"
		   << "\"dxyyp\" \\ \n"
		   << "\"dyyyrho\" \\ \n"
		   << "\"dyyyu\" \\ \n"
		   << "\"dyyyv\" \\ \n"
		   << "\"dyyyp\" \\ \n";

	case 2: 	 // 2nd-order derivatives
	  Out_File << "\"dxxrho\" \\ \n"
		   << "\"dxxu\" \\ \n"
		   << "\"dxxv\" \\ \n"
		   << "\"dxxp\" \\ \n"
		   << "\"dxyrho\" \\ \n"
		   << "\"dxyu\" \\ \n"
		   << "\"dxyv\" \\ \n"
		   << "\"dxyp\" \\ \n"
		   << "\"dyyrho\" \\ \n"
		   << "\"dyyu\" \\ \n"
		   << "\"dyyv\" \\ \n"
		   << "\"dyyp\" \\ \n";
	case 1:   // 1st-order derivatives
	  Out_File << "\"dxrho\" \\ \n"
		   << "\"dxu\" \\ \n"
		   << "\"dxv\" \\ \n"
		   << "\"dxp\" \\ \n"
		   << "\"dyrho\" \\ \n"
		   << "\"dyu\" \\ \n"
		   << "\"dyv\" \\ \n"
		   << "\"dyp\" \\ \n"
		   << "\"phirho\" \\ \n"
		   << "\"phiu\" \\ \n"
		   << "\"phiv\" \\ \n"
		   << "\"phip\" \\ \n";
	} // endswitch

	Out_File << "\"T\"  \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";
      }

      // Extended format
      if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	switch(HighOrderVariable(IndexHO).RecOrder()){
	case 4:	  // 4th-order derivatives
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		   << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

	case 3:   // 3rd-order derivatives
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		   << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

	case 2: 	 // 2nd-order derivatives
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		   << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

	case 1:   // 1st-order derivatives
	  Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		   << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";	  
	  
	}

	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for (j = JCl-Nghost; j <= JCu+Nghost; ++j) {// for every j Cell
      for (i = ICl-Nghost; i <= ICu+Nghost; ++i) {// for every i Cell

	// Set the location
	Node = Grid.CellCentroid(i,j);

	if (i < ICl-HighOrderVariable(IndexHO).NghostHO() || 
	    i > ICu+HighOrderVariable(IndexHO).NghostHO() || 
	    j < JCl-HighOrderVariable(IndexHO).NghostHO() ||
	    j > JCu+HighOrderVariable(IndexHO).NghostHO()  ) {

	  // No high-order interpolant is calculated for this cells.
	  // The average solution is plotted at the centers of these cells.
	  
	  // Output Brief format
	  Out_File << " "  << Node 
		   << " "  << CellSolution(i,j);

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File.setf(ios::scientific);
	    Out_File << " " << 1.0E8
		     << " " << 0
		     << " " << 1.0E8
		     << " " << 0
		     << " " << 1.0E8
		     << " " << 0
		     << " " << 1.0E8
		     << " " << 0;
	    Out_File.unsetf(ios::scientific);	    
	    Out_File << " " << dUdt[i][j][0]
		     << " " << dt[i][j];
	  }

	  // Add more variables for the Extended format
	  if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	    switch(HighOrderVariable(IndexHO).RecOrder()){
	    case 4:    // 4th-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,4,0) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,1) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,2) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,3) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,4);

	    case 3:   // 3rd-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,0)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,1)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,2)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,3);

	    case 2:    // 2nd-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,0)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,1)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,2);

	    case 1:	    
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,0) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,1) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDeriv(i,j).Limiter();
	    }
	    
	    Out_File << " " << 0.0;
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} else {

	  // Use the high-order interpolant to calculate the solution at the cell centroids.
	  
	  // Output Brief format
	  W_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	  Out_File << " "  << Node 
		   << " "  << W_node;

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File.setf(ios::scientific);
	    Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1)
		     << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,2)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,2)
		     << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,3)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,3)
		     << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,4)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,4);
	    Out_File.unsetf(ios::scientific);
	    Out_File << " " << dUdt[i][j][0]
		     << " " << dt[i][j];
	  }

	  // Add more variables for the Extended format
	  if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	    switch(HighOrderVariable(IndexHO).RecOrder()){
	    case 4:    // 4th-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,4,0) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,1) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,2) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,3) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,4);
	      
	    case 3:   // 3rd-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,0)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,1)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,2)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,3);
	      
	    case 2:    // 2nd-order derivatives
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,0)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,1)
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,2);

	    case 1:	    
	      Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,0) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,1) 
		       << " " << HighOrderVariable(IndexHO).CellTaylorDeriv(i,j).Limiter();
	    }
	    
	    Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,0).T();
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} // endif

      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the centroids (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost cells for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void Euler2D_Quad_Block::Output_Cells_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								   const Euler2D_Input_Parameters &IP,
								   const int &Block_Number,
								   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cells_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Cells_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Cells_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Evaluate the residual for the solution block 
 * using the high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 * The residual is stored in dUdt[][][k_residual].
 *
 * \param IP  input parameters object
 * \param Pos index to identify the high-order variable used to calculate the residual
 * \param k_residual index to identify the residual storage location
 *
 */
int Euler2D_Quad_Block::dUdt_Residual_HighOrder(const Euler2D_Input_Parameters &IP,
						const int & k_residual,
						const bool & UseTimeStep,
						const unsigned short int Pos){

  // SET VARIABLES USED IN THE RESIDUAL CALCULATION PROCESS

  int i, j, GQPoint, Position, SplineSegment;
  bool IsNonSmoothHighOrderReconstruction;
  Euler2D_pState Wl, Wr, W_face;
  Euler2D_cState Flux, FaceFlux;
  int NumGQP(Grid.getNumGQP());	  // Number of Gauss quadrature points per face used to compute the flux integral

  Vector2D *GaussQuadPoints = new Vector2D [NumGQP]; // the GQPs at which a Riemann-like problem is solved
  double * GaussQuadWeights = new double [NumGQP];   // the Gauss integration weights for each Gauss quadrature

  /* Set the GaussQuadWeights. */
  GaussQuadratureData::getGaussQuadWeights(GaussQuadWeights, NumGQP);

  /* Evaluate the solution residual 
     and write it to dUdt[][][k_residual]. */

  /***************************************************************************************
   *                 EVALUATE THE HIGH-ORDER SOLUTION RESIDUALS                          *
   *                                                                                     *
   * Algorithm Purpose: To evaluate solution residuals for solution blocks               *
   *                    characterized by a broad range of options.                       *
   *                                                                                     *
   * Important options to consider:                                                      *
   *         --> Geometry treatment: high-order or low-order                             *
   *         --> Spatial accuracy:   order of accuracy for flux calculation              *
   *         --> Boundary flux calculation: 'Riemann' problem or reconstruction based    *
   *                                                                                     *
   * In order to respond easier to all these parameter variations, the following         *
   * algorithm is adopted to sweep through the cell interfaces:                          *
   *         --> Compute all fluxes at interior inter-cellular faces.                    *
   *         --> Compute fluxes for North, South, East and West block boundary faces.    *
   *                                                                                     *
   ***************************************************************************************/

  /* Evaluate the time rate of change of the solution
     (i.e., the solution residuals) using a high-order
     CENO upwind finite-volume scheme. */

  /* Perform the high-order CENO reconstruction within
     each cell of the computational grid for this stage.
     NOTE: This solution reconstruction enforces monotonicity if required so!
  */

  HighOrderVariable(Pos).ComputeHighOrderSolutionReconstruction(*this,
								IP.Limiter());

  // ** Step 1. Compute interior fluxes and any source contributions for cells between (ICl,JCl)-->(ICu,JCu) **
  // **********************************************************************************************************
  for ( j = JCl ; j <= JCu ; ++j ){
    for ( i = ICl ; i <= ICu ; ++i ) {

      if ( i != ICu) { 		// (i == ICu) corresponds to the East block boundary which will be considered separately!
	
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (i,j) & West Flux for cell (i+1,j) ) */
	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceE(i,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i  ,j,GaussQuadPoints[GQPoint]);
	  Wr = HighOrderVariable(Pos).SolutionStateAtLocation(i+1,j,GaussQuadPoints[GQPoint]);

	  // Validate the left state
	  Validate_Primitive_SolnState(Wl,i ,j, "East", Pos);
	  // Validate the right state
	  Validate_Primitive_SolnState(Wr,i+1,j, "West", Pos);
	  
	  /* Add the weighted contribution of the current GQP to the total 
	     flux in the normal direction through the face. */
	  Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							    Wl, Wr,
							    Grid.nfaceE(i, j));

	} //endfor (GQPoint)
      
	  /* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[i  ][j][k_residual] -= ( (IP.CFL_Number * dt[i  ][j])*
					Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );
	    
	  dUdt[i+1][j][k_residual] += ( (IP.CFL_Number * dt[i+1][j])*
					Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	} else {
	  dUdt[i  ][j][k_residual] -= ( Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );
	    
	  dUdt[i+1][j][k_residual] += ( Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	}

      }	//endif (i != ICu)


      if ( j != JCu) {		// (j == JCu) corresponds to the North block boundary which will be considered separately!

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,j) & South Flux for cell (i,j+1) ) */
	// Determine the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceN(i,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,j  ,GaussQuadPoints[GQPoint]);
	  Wr = HighOrderVariable(Pos).SolutionStateAtLocation(i,j+1,GaussQuadPoints[GQPoint]);

	  // Validate the left state
	  Validate_Primitive_SolnState(Wl,i ,j  , "North", Pos);
	  // Validate the right state
	  Validate_Primitive_SolnState(Wr,i ,j+1, "South", Pos);	  

	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							    Wl, Wr,
							    Grid.nfaceN(i, j));
	} //endfor (GQPoint)


	  /* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[i][j  ][k_residual] -= ( (IP.CFL_Number * dt[i][j  ])*
					Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );
	    
	  dUdt[i][j+1][k_residual] += ( (IP.CFL_Number * dt[i][j+1])*
					Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	} else {
	  dUdt[i][j  ][k_residual] -= ( Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );
	    
	  dUdt[i][j+1][k_residual] += ( Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	}

      } //endif (j != JCu)

      /* Include axisymmetric source terms as required. */
      if (Axisymmetric) {
	if (UseTimeStep) {
	  dUdt[i][j][k_residual] += ( (IP.CFL_Number*dt[i][j])*
				      S(CellSolution(i,j), Grid.CellCentroid(i,j)) );
	} else {
	  dUdt[i][j][k_residual] += ( S(CellSolution(i,j), Grid.CellCentroid(i,j)) );
	}
      } /* endif */

    } // endfor (i)
  } // endfor (j)

  
#ifdef CHANGE_NUMBER_OF_GQP_AT_BOUNDARY
  delete [] GaussQuadPoints;
  delete [] GaussQuadWeights;

  NumGQP = 3;

  GaussQuadPoints = new Vector2D [NumGQP]; // the GQPs at which a Riemann-like problem is solved
  GaussQuadWeights = new double [NumGQP];   // the Gauss integration weights for each Gauss quadrature

  /* Set the GaussQuadWeights. */
  GaussQuadratureData::getGaussQuadWeights(GaussQuadWeights, NumGQP);
#endif

  // ****** Step 2. Compute fluxes through North block boundary ******
  // *****************************************************************
  // == Check the flux calculation method ==
  if (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
    /* Calculate the flux using information directly from the reconstruction.
       The boundary conditions along this spline has been enforced to the reconstruction procedure.
       If the high-order reconstruction has been detected as non-smooth compute an upwind flux
       with the value provided by the ghost cell reconstruction.
    */
    
    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndNorthSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. North Flux for cell (i,JCu) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCu);

	// Reset North flux for the current cell
	FluxN[i].Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // == Check if the solution reconstruction was detected as non-smooth.
	    if ( IsNonSmoothHighOrderReconstruction ){

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Validate Wl state
	      Validate_Primitive_SolnState(Wl, i, JCu, "North", Pos);
	      
	      // Determine the right interface state at the Gauss calculation point based on BCs
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							       i,JCu,
							       Wl,Wr,
							       Grid.BndNorthSplineInfo[i].GQPoint(Position),
							       Grid.BndNorthSplineInfo[i].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));

	    } else {

	      // Determine the solution state at the Gauss quadrature point for flux calculation
	      // based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Validate W_face state
	      Validate_Primitive_SolnState(W_face, i, JCu, "North", Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));
	    } // endif (IsNonSmoothHighOrderReconstruction)

	  } //endfor (GQPoint)
	
	  // Update North face boundary flux with the contribution of this spline segment
	  FluxN[i] += Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FluxN[i]/Grid.Cell[i][JCu].A );
	} else {
	  dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	}

      } // endfor (i)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. North Flux for cell (i,JCu) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCu);

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	// Reset Flux
	FluxN[i].Vacuum();

	// == Check if the solution reconstruction was detected as non-smooth.
	if ( IsNonSmoothHighOrderReconstruction ){

	  // Calculate total flux through the cell face in the normal direction
	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the low-order reconstruction.
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);
	  
	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, i, JCu, "North", Pos);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							     i,JCu,
							     Wl,Wr,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceN(i,JCu),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.nfaceN(i,JCu));
	  } //endfor (GQPoint)
	
	} else {

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point
	  
	    // Determine the solution state at the Gauss quadrature point for flux calculation
	    // based on constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);

	    // Validate W_face state
	    Validate_Primitive_SolnState(W_face, i, JCu, "North", Pos);
	  
	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the face in the normal direction. */
	    FluxN[i] += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.nfaceN(i,JCu));
	  } //endfor (GQPoint)
	
	} // endif

	// Update North face boundary flux with the contribution of this cell face
	FluxN[i] *= Grid.lfaceN(i,JCu);

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* FluxN[i]/Grid.Cell[i][JCu].A );
	} else {
	  dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	}

      } // endfor (i)

    } // endif (Grid.BndNorthSplineInfo != NULL)


  } else {
    /* Calculate the flux by solving a Riemann problem and ensure
       that boundary conditions for this boundary are correctly enforced. */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndNorthSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */
      
      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. North Flux for cell (i,JCu) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	// Reset North flux for the current cell
	FluxN[i].Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,
								Grid.BndNorthSplineInfo[i].GQPoint(Position));

	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, i, JCu, "North", Pos);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							     i,JCu,
							     Wl,Wr,
							     Grid.BndNorthSplineInfo[i].GQPoint(Position),
							     Grid.BndNorthSplineInfo[i].NormalGQPoint(Position),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the spline segment in the local normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));
	  } //endfor (GQPoint)
	
	  // Update North face boundary flux with the contribution of this spline segment
	  FluxN[i] += Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FluxN[i]/Grid.Cell[i][JCu].A );
	} else {
	  dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	}

      } // endfor (i)
      
    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. North Flux for cell (i,JCu) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	// Reset North flux for the current cell
	FluxN[i].Vacuum();

	// Calculate total flux through the cell face in the normal direction
	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);

	  // Validate Wl state
	  Validate_Primitive_SolnState(Wl, i, JCu, "North", Pos);

	  // Determine right interface state at the Gauss calculation point
	  InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							   i,JCu,
							   Wl,Wr,
							   GaussQuadPoints[GQPoint],
							   Grid.nfaceN(i,JCu),
							   Pos);

	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  FluxN[i] += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.nfaceN(i,JCu));
	} //endfor (GQPoint)
	
	// Update North face boundary flux with the contribution of this cell face
	FluxN[i] *= Grid.lfaceN(i,JCu);

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* FluxN[i]/Grid.Cell[i][JCu].A );
	} else {
	  dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	}

      } // endfor (i)
      
    } // endif (Grid.BndNorthSplineInfo != NULL)
    
  } // endif (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


  // ****** Step 3. Compute fluxes through South block boundary ******
  // *****************************************************************
  // == Check the flux calculation method ==
  if (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
    /* Calculate the flux using information directly from the reconstruction.
       The boundary conditions along this spline has been enforced to the reconstruction procedure.
       If the high-order reconstruction has been detected as non-smooth compute a Riemann flux
       with the value provided by the ghost cell reconstruction.
    */
    
    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndSouthSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. South Flux for cell (i,JCl) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCl);

	// Reset South flux for the current cell
	FluxS[i].Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // == Check if the solution reconstruction was detected as non-smooth.
	    if ( IsNonSmoothHighOrderReconstruction ){

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,Grid.BndSouthSplineInfo[i].GQPoint(Position));
	      
	      // Validate Wl state
	      Validate_Primitive_SolnState(Wl, i, JCl, "South", Pos);	      
	      
	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							       i,JCl,
							       Wl,Wr,
							       Grid.BndSouthSplineInfo[i].GQPoint(Position),
							       Grid.BndSouthSplineInfo[i].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));

	    } else {

	      // Determine the solution state at the Gauss quadrature point for calculation 
	      // based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      // Validate W_face state
	      Validate_Primitive_SolnState(W_face, i, JCl, "South", Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));
	    } // endif (IsNonSmoothHighOrderReconstruction)

	  } //endfor (GQPoint)
	
	  // Update South face boundary flux with the contribution of this spline segment
	  FluxS[i] += Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FluxS[i]/Grid.Cell[i][JCl].A );
	} else {
	  dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	}

      } // endfor (i)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. South Flux for cell (i,JCl) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCl);

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	// Reset Flux
	FluxS[i].Vacuum();

	// == Check if the solution reconstruction was detected as non-smooth.
	if ( IsNonSmoothHighOrderReconstruction ){

	  // Calculate total flux through the cell face in the normal direction
	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the low-order reconstruction.
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);
	    
	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, i, JCl, "South", Pos);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							     i,JCl,
							     Wl,Wr,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceS(i,JCl),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.nfaceS(i,JCl));
	  } //endfor (GQPoint)
	    
	} else {

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for flux calculation 
	    // based on constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);

	    // Validate W_face state
	    Validate_Primitive_SolnState(W_face, i, JCl, "South", Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the face in the normal direction. */
	    FluxS[i] += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.nfaceS(i,JCl));
	  } //endfor (GQPoint)

	} // endif
	
	// Update South face boundary flux with the contribution of this cell face
	FluxS[i] *= Grid.lfaceS(i,JCl);

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* FluxS[i]/Grid.Cell[i][JCl].A );
	} else {
	  dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	}

      } // endfor (i)

    } // endif (Grid.BndSouthSplineInfo != NULL)


  } else {
    /* Calculate the flux by solving a Riemann problem and ensure
       that boundary conditions for this boundary are correctly enforced. */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndSouthSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */
      
      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. South Flux for cell (i,JCl) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	// Reset South flux for the current cell	  
	FluxS[i].Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,
								Grid.BndSouthSplineInfo[i].GQPoint(Position));
	    
	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, i, JCl, "South", Pos);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							     i,JCl,
							     Wl,Wr,
							     Grid.BndSouthSplineInfo[i].GQPoint(Position),
							     Grid.BndSouthSplineInfo[i].NormalGQPoint(Position),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the spline segment in the local normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));
	  } //endfor (GQPoint)
	
	  // Update South face boundary flux with the contribution of this spline segment
	  FluxS[i] += Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FluxS[i]/Grid.Cell[i][JCl].A );
	} else {
	  dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	}

      } // endfor (i)
      
    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. South Flux for cell (i,JCl) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	// Reset Flux
	FluxS[i].Vacuum();

	// Calculate total flux through the cell face in the normal direction
	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);

	  // Validate Wl state
	  Validate_Primitive_SolnState(Wl, i, JCl, "South", Pos);
	  
	  // Determine right interface state at the Gauss calculation point
	  InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							   i,JCl,
							   Wl,Wr,
							   GaussQuadPoints[GQPoint],
							   Grid.nfaceS(i,JCl),
							   Pos);
	  
	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  FluxS[i] += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.nfaceS(i,JCl));
	} //endfor (GQPoint)
	
	// Update South face boundary flux with the contribution of this cell face
	FluxS[i] *= Grid.lfaceS(i,JCl);

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* FluxS[i]/Grid.Cell[i][JCl].A );
	} else {
	  dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	}

      } // endfor (i)
      
    } // endif (Grid.BndSouthSplineInfo != NULL)
    
  } // endif (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


  // ****** Step 4. Compute diffusive fluxes through East block boundary ******
  // **************************************************************************
  // == Check the flux calculation method ==
  if (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
    /* Calculate the flux using information directly from the reconstruction.
       The boundary conditions along this spline has been enforced to the reconstruction procedure.
       If the high-order reconstruction has been detected as non-smooth compute an upwind flux
       with the value provided by the ghost cell reconstruction.
    */
    
    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndEastSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. East Flux for cell (ICu,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICu,j);

	// Reset East flux for the current cell
	FluxE[j].Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // == Check if the solution reconstruction was detected as non-smooth.
	    if ( IsNonSmoothHighOrderReconstruction ){

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Validate Wl state
	      Validate_Primitive_SolnState(Wl, ICu, j, "East", Pos);
	      
	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							       ICu,j,
							       Wl,Wr,
							       Grid.BndEastSplineInfo[j].GQPoint(Position),
							       Grid.BndEastSplineInfo[j].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.BndEastSplineInfo[j].NormalGQPoint(Position));

	    } else {

	      // Determine the solution state at the Gauss quadrature point for flux calculation 
	      // based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Validate W_face state
	      Validate_Primitive_SolnState(W_face, ICu, j, "East", Pos);
	      
	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.BndEastSplineInfo[j].NormalGQPoint(Position));
	    } // endif (IsNonSmoothHighOrderReconstruction)

	  } //endfor (GQPoint)
	
	  // Update East face boundary flux with the contribution of this spline segment
	  FluxE[j] += Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FluxE[j]/Grid.Cell[ICu][j].A );
	} else {
	  dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	}
	  
      } // endfor (j)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. East Flux for cell (ICu,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICu,j);

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	FluxE[j].Vacuum();

	// == Check if the solution reconstruction was detected as non-smooth.
	if ( IsNonSmoothHighOrderReconstruction ){

	  // Calculate total flux through the cell face in the normal direction
	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the low-order reconstruction.
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);
	    
	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							     ICu,j,
							     Wl,Wr,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceE(ICu,j),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.nfaceE(ICu,j));
	  } //endfor (GQPoint)
	    
	} else {

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for flux calculation 
	    // based on the constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);

	    // Validate W_face state
	    Validate_Primitive_SolnState(W_face, ICu, j, "East", Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the face in the normal direction. */
	    FluxE[j] += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.nfaceE(ICu,j));
	  } //endfor (GQPoint)
	
	} // endif	  

	// Update East face boundary flux with the contribution of this cell face
	FluxE[j] *= Grid.lfaceE(ICu,j);

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* FluxE[j]/Grid.Cell[ICu][j].A );
	} else {
	  dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	}

      } // endfor (j)

    } // endif (Grid.BndEastSplineInfo != NULL)


  } else {
    /* Calculate the flux by solving a Riemann problem and ensure 
       that boundary conditions for this boundary are correctly enforced. */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndEastSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */
      
      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. East Flux for cell (ICu,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	// Reset East flux for the current cell
	FluxE[j].Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,
								Grid.BndEastSplineInfo[j].GQPoint(Position));

	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, ICu, j, "East", Pos);
	    
	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							     ICu,j,
							     Wl,Wr,
							     Grid.BndEastSplineInfo[j].GQPoint(Position),
							     Grid.BndEastSplineInfo[j].NormalGQPoint(Position),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the spline segment in the local normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.BndEastSplineInfo[j].NormalGQPoint(Position));
	  } //endfor (GQPoint)
	
	  // Update East face boundary flux with the contribution of this spline segment
	  FluxE[j] += Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FluxE[j]/Grid.Cell[ICu][j].A );
	} else {
	  dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	}

      } // endfor (j)
      
    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. East Flux for cell (ICu,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	FluxE[j].Vacuum();

	// Calculate total flux through the cell face in the normal direction
	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);

	  // Validate Wl state
	  Validate_Primitive_SolnState(Wl, ICu, j, "East", Pos);

	  // Determine right interface state at the Gauss calculation point
	  InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							   ICu,j,
							   Wl,Wr,
							   GaussQuadPoints[GQPoint],
							   Grid.nfaceE(ICu,j),
							   Pos);

	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  FluxE[j] += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.nfaceE(ICu,j));
	} //endfor (GQPoint)
	
	// Update East face boundary flux with the contribution of this cell face
	FluxE[j] *= Grid.lfaceE(ICu,j);

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* FluxE[j]/Grid.Cell[ICu][j].A );
	} else {
	  dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	}

      } // endfor (j)
      
    } // endif (Grid.BndEastSplineInfo != NULL)
    
  } // endif (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


  // ****** Step 5. Compute diffusive fluxes through West block boundary ******
  // **************************************************************************
  // == Check the flux calculation method ==
  if (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
    /* Calculate the flux using information directly from the reconstruction.
       The boundary conditions along this spline has been enforced to the reconstruction procedure.
       If the high-order reconstruction has been detected as non-smooth compute a Riemann flux
       with the value provided by the ghost cell reconstruction.
    */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndWestSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. West Flux for cell (ICl,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICl,j);

	// Reset West flux for the current cell
	FluxW[j].Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // == Check if the solution reconstruction was detected as non-smooth.
	    if ( IsNonSmoothHighOrderReconstruction ){

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Validate Wl state
	      Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);	      

	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							       ICl,j,
							       Wl,Wr,
							       Grid.BndWestSplineInfo[j].GQPoint(Position),
							       Grid.BndWestSplineInfo[j].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.BndWestSplineInfo[j].NormalGQPoint(Position));

	    } else {

	      // Determine the solution state at the Gauss quadrature point for flux calculation 
	      // based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Validate W_face state
	      Validate_Primitive_SolnState(W_face, ICl, j, "West", Pos);
	      
	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.BndWestSplineInfo[j].NormalGQPoint(Position));
	    } // endif (IsNonSmoothHighOrderReconstruction)

	  } //endfor (GQPoint)
	
	  // Update West face boundary flux with the contribution of this spline segment
	  FluxW[j] += Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FluxW[j]/Grid.Cell[ICl][j].A );
	} else {
	  dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	}

      } // endfor (j)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. West Flux for cell (ICl,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICl,j);

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	FluxW[j].Vacuum();

	// == Check if the solution reconstruction was detected as non-smooth.
	if ( IsNonSmoothHighOrderReconstruction ){

	  // Calculate total flux through the cell face in the normal direction
	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the low-order reconstruction.
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);

	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);
	    
	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							     ICl,j,
							     Wl,Wr,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceW(ICl,j),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.nfaceW(ICl,j));
	  } //endfor (GQPoint)
	    
	} else {

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for flux calculation 
	    // based on constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);
	    
	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the face in the normal direction. */
	    FluxW[j] += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.nfaceW(ICl,j));
	  } //endfor (GQPoint)
	
	} // endif

	// Update West face boundary flux with the contribution of this cell face
	FluxW[j] *= Grid.lfaceW(ICl,j);

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* FluxW[j]/Grid.Cell[ICl][j].A );
	} else {
	  dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	}

      } // endfor (j)

    } // endif (Grid.BndWestSplineInfo != NULL)


  } else {
    /* Calculate the flux by solving a Riemann problem and ensure 
       that boundary conditions for this boundary are correctly enforced. */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndWestSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */
      
      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. West Flux for cell (ICl,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	// Reset West flux for the current cell
	FluxW[j].Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,
								Grid.BndWestSplineInfo[j].GQPoint(Position));

	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);
	    
	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							     ICl,j,
							     Wl,Wr,
							     Grid.BndWestSplineInfo[j].GQPoint(Position),
							     Grid.BndWestSplineInfo[j].NormalGQPoint(Position),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the spline segment in the local normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.BndWestSplineInfo[j].NormalGQPoint(Position));
	  } //endfor (GQPoint)
	
	  // Update West face boundary flux with the contribution of this spline segment
	  FluxW[j] += Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FluxW[j]/Grid.Cell[ICl][j].A );
	} else {
	  dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	}

      } // endfor (j)
      
    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. West Flux for cell (ICl,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	FluxW[j].Vacuum();

	// Calculate total flux through the cell face in the normal direction
	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);
	  
	  // Validate Wl state
	  Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);

	  // Determine right interface state at the Gauss calculation point
	  InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							   ICl,j,
							   Wl,Wr,
							   GaussQuadPoints[GQPoint],
							   Grid.nfaceW(ICl,j),
							   Pos);

	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  FluxW[j] += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.nfaceW(ICl,j));
	} //endfor (GQPoint)
	
	// Update West face boundary flux with the contribution of this cell face
	FluxW[j] *= Grid.lfaceW(ICl,j);

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* FluxW[j]/Grid.Cell[ICl][j].A );
	} else {
	  dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	}

      } // endfor (j)
      
    } // endif (Grid.BndWestSplineInfo != NULL)
    
  } // endif (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux)

  // Deallocate memory
  delete [] GaussQuadPoints;
  delete [] GaussQuadWeights;

  /* residual for the stage successfully calculated. */
  return (0);

}

/*!
 * Evaluate the residual for the solution block 
 * using a high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 * The residual is stored in dUdt[][][0].               
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *                                                      
 */
int Euler2D_Quad_Block::dUdt_Residual_Evaluation_HighOrder(const Euler2D_Input_Parameters &IP,
							   const unsigned short int Pos){

  int i,j;
  
  // ************* Step 1. (Re)-Set residual for k_residual=0 to zero in all affected cells **************
  // *****************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ) {
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {
      dUdt[i][j][0].Vacuum();  // set to zero
    } // endfor (i)
  } // endfor (j)

  // ** Step 2. Compute high-order spatial residual and write it to k_residual = 0 **
  // ********************************************************************************
  return dUdt_Residual_HighOrder(IP, 0, false, Pos);
}


/*!
 * This routine determines the solution residuals for a 
 * given stage of a variety of multi-stage explicit     
 * time integration schemes for the solution block.
 * The solution residuals are evaluated  
 * using a high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *
 */
int Euler2D_Quad_Block::dUdt_Multistage_Explicit_HighOrder(const int &i_stage,
							   const Euler2D_Input_Parameters &IP,
							   const unsigned short int Pos) {
  // SET VARIABLES USED IN THE RESIDUAL CALCULATION PROCESS

  int i, j, k_residual;

  /* Evaluate the solution residual for stage 
     i_stage of an N stage scheme. */

  /* Evaluate the time step fraction and residual storage location for the stage. */
  
  switch(IP.i_Time_Integration) {
  case TIME_STEPPING_EXPLICIT_EULER :
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
    k_residual = 0;
    if (IP.N_Stage == 4) {
      if (i_stage == 4) {
	k_residual = 0;
      } else {
	k_residual = i_stage - 1;
      } /* endif */
    } /* endif */
    break;
  case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
    k_residual = 0;
    break;
  default:
    k_residual = 0;
  } /* endswitch */


  // ************* Step 1. (Re)-Set parameters in all affected cells based on the time integration scheme **************
  // *******************************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ){
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {

      if ( i_stage == 1 ){
	Uo[i][j] = U[i][j];
	dUdt[i][j][k_residual].Vacuum();  // set to zero
      } else {
	switch(IP.i_Time_Integration) {
	case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
	  // 
	  break;
	case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
	  if (IP.N_Stage == 2) {
	    // 
	  } else if (IP.N_Stage == 4 && i_stage == 4) {
	    dUdt[i][j][k_residual] = ( dUdt[i][j][0] + 
				       TWO*dUdt[i][j][1] +
				       TWO*dUdt[i][j][2] );
	  } else {
	    dUdt[i][j][k_residual].Vacuum();  // set to zero
	  } /* endif */
	  break;
	case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	default:
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	} /* endswitch */
      }/* endif */

    } // endfor (i)
  } // endfor (j)


  // ** Step 2. Compute high-order spatial residual for the current time step fraction **
  // ************************************************************************************
  return dUdt_Residual_HighOrder(IP, k_residual, true, Pos);
}

/*!
 * Compute the solution state for evaluating the inviscid flux 
 * at a boundary interface such that to satisfy the 
 * required boundary conditions.
 * This routine works in conjunction with the high-order
 * implementation.
 * 
 * \param  BOUNDARY boundary position specifier (i.e. WEST, EAST, SOUTH or NORTH)
 * \param  ii       i-index of the cell in which the calculation is done
 * \param  jj       j-index of the cell in which the calculation is done
 * \param  Wl       the left interface state 
 * \param  Wr       the right interface state 
 * \param CalculationPoint the flux calculation point
 * \param NormalDirection the normal direction at the calculation point
 *
 * \return The solution state which is required to calculate the inviscid flux with 
 *         such that to satisfy the boundary condition.
 */
void Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder(const int &BOUNDARY,
									  const int &ii, const int &jj,
									  Euler2D_pState &Wl,
									  Euler2D_pState &Wr,
									  const Vector2D &CalculationPoint,
									  const Vector2D &NormalDirection,
									  const unsigned short int Pos) const {

  switch(BOUNDARY){

    // *******************************
    // === WEST boundary interface ===
    // *******************************
  case WEST :			
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeW[jj]){

    case BC_NONE :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;

    case BC_FROZEN :
      // Calculate Wr based on the reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;
      
    case BC_DIRICHLET :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_DIRICHLET not implemented yet.");
      break;

    case BC_EXACT_SOLUTION :
      // Calculate W_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Wr = Wl = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
      break;

    case BC_SYMMETRY_PLANE :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_SYMMETRY_PLANE not implemented yet.");
      break;

    case BC_EXTRAPOLATE :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_LINEAR_EXTRAPOLATION not implemented yet.");
      break;

    case BC_OUTFLOW :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;
      
    case BC_FARFIELD :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_FARFIELD not implemented yet.");
      break;

    default:
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such West BCtype!");
    }// endswitch (Grid.BCtypeW[jj])
    break;


    // *******************************
    // === EAST boundary interface ===
    // *******************************
  case EAST :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeE[jj]){

    case BC_NONE :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;
      
    case BC_DIRICHLET :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_DIRICHLET not implemented yet.");
      break;

    case BC_EXACT_SOLUTION :
      // Calculate W_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Wr = Wl = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
      break;

    case BC_SYMMETRY_PLANE :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_SYMMETRY_PLANE not implemented yet.");
      break;

    case BC_EXTRAPOLATE :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_LINEAR_EXTRAPOLATION not implemented yet.");
      break;

    case BC_OUTFLOW :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;
      
    case BC_FARFIELD :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_FARFIELD not implemented yet.");
      break;

    default:
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such East BCtype!");
    }// endswitch (Grid.BCtypeE[jj])
    break;

    // ********************************
    // === SOUTH boundary interface ===
    // ********************************
  case SOUTH :
    // Compute left interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeS[ii]){

    case BC_NONE :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Wr based on the reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;
      
    case BC_DIRICHLET :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_DIRICHLET not implemented yet.");
      break;

    case BC_EXACT_SOLUTION :
      // Calculate W_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Wr = Wl = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
      break;

    case BC_SYMMETRY_PLANE :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_SYMMETRY_PLANE not implemented yet.");
      break;

    case BC_EXTRAPOLATE :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_LINEAR_EXTRAPOLATION not implemented yet.");
      break;

    case BC_OUTFLOW :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;
      
    case BC_FARFIELD :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_FARFIELD not implemented yet.");
      break;

    default:
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such South BCtype!");
    }// endswitch (Grid.BCtypeS[ii])
    break;

    // ********************************
    // === NORTH boundary interface ===
    // ********************************
  case NORTH :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeN[ii]){

    case BC_NONE :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;
      
    case BC_DIRICHLET :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_DIRICHLET not implemented yet.");
      break;

    case BC_EXACT_SOLUTION :
      // Calculate W_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Wr = Wl = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
      break;

    case BC_SYMMETRY_PLANE :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_SYMMETRY_PLANE not implemented yet.");
      break;

    case BC_EXTRAPOLATE :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_LINEAR_EXTRAPOLATION not implemented yet.");
      break;

    case BC_OUTFLOW :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;
      
    case BC_FARFIELD :
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_FARFIELD not implemented yet.");
      break;

    default:
      throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such North BCtype!");
    }// endswitch (Grid.BCtypeN[ii])
    break;

  default:
    throw runtime_error("Euler2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such boundary!");
  }  

}
