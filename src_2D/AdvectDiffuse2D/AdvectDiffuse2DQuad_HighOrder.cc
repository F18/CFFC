/*! \file AdvectDiffuse2DQuad_HighOrder.cc
  @brief High-order Subroutines for 2D Advection Diffusion Equation Quadrilateral Mesh Solution Classes. */

/* Include required C++ libraries. */
// None

/* Using std namespace functions */
// None

/* Include CFFC header files */
#include "AdvectDiffuse2DQuad.h"        // AdvectDiffuse2D_Quad_Block class

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the interior nodes of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 *
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 */
void AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							  const double &Time,
							  const int &Block_Number,
							  const int &Output_Title,
							  ostream &Out_File,
							  const int &IndexHO) {

    int i, j, nRow, nLoop;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output node solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (NCi - 2*Nghost)*3  << " \\ \n"
	       << "J = " << (NCj - 2*Nghost)*3 << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (NCi - 2*Nghost)*3 << " \\ \n"
	       << "J = " << (NCj - 2*Nghost)*3 << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for ( j  = JCl ; j <= JCu ; ++j ) {	// for every j Cell
      for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
	for ( i = ICl ; i <= ICu ; ++i ) { // for every i Cell
	  for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	    // Get the node location
	    switch(nRow){
	    case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeSW(i,j)
		Node = Grid.nodeSW(i,j).X;
		break;
	      case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCl && Grid.BndSouthSplineInfo != NULL){
		  Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceS(i,j);
		}
		break;
	      case 3:		// output NodeSE(i,j)
		Node = Grid.nodeSE(i,j).X;
		break;
	      }
	      break;

	    case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	      switch(nLoop){
	      case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICl && Grid.BndWestSplineInfo != NULL){
		  Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceW(i,j);
		}
		break;
	      case 2:		// output Grid.CellCentroid(i,j)
		Node = Grid.CellCentroid(i,j);
		break;
	      case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICu && Grid.BndEastSplineInfo != NULL){
		  Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceE(i,j);
		}
		break;
	      }
	      break;

	    case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeNW(i,j)
		Node = Grid.nodeNW(i,j).X;
		break;
	      case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCu && Grid.BndNorthSplineInfo != NULL){
		  Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceN(i,j);
		}
		break;
	      case 3:		// output NodeNE(i,j)
		Node = Grid.nodeNE(i,j).X;
		break;
	      }
	      break;
	    } // endswitch

	    // Output Brief format
	    U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << U_node;


	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File << " " << U[i][j].V(Node.x,Node.y)
		       << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		       << " " << source(Node.x,Node.y,U_node);
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	      Out_File.unsetf(ios::scientific);
	      if (ExactSoln->IsExactSolutionSet()){
		Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	      }
	    }

	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File << " " << dUdt[i][j][0];
	    }

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);

	  }
	} /* endfor */
      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the interior nodes of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								     const AdvectDiffuse2D_Input_Parameters &IP,
								     const int &Block_Number,
								     const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  
  /* Open the output data file. */
  
  output_file.open(output_file_name, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }
  
  try {
    Output_Tecplot_HighOrder(0,0,
			     Block_Number,
			     1,
			     output_file,
			     IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }

  /* Close the output data file. */
  output_file.close();

  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all nodes (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 */
void AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
								const double &Time,
								const int &Block_Number,
								const int &Output_Title,
								ostream &Out_File,
								const int &IndexHO) {

    int i, j, nRow, nLoop;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output node solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3  << " \\ \n"
	       << "J = " << ( JCu - JCl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (ICu - ICl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "J = " << (JCu - JCl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for (j=JCl-HighOrderVariable(IndexHO).NghostHO(); j<=JCu+HighOrderVariable(IndexHO).NghostHO(); ++j) {// for every j Cell
      for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
	for (i=ICl-HighOrderVariable(IndexHO).NghostHO(); i<=ICu+HighOrderVariable(IndexHO).NghostHO(); ++i) {// for every i Cell
	  for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	    // Get the node location
	    switch(nRow){
	    case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeSW(i,j)
		Node = Grid.nodeSW(i,j).X;
		break;
	      case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCl && Grid.BndSouthSplineInfo != NULL && i>= ICl && i<= ICu ){
		  Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceS(i,j);
		}
		break;
	      case 3:		// output NodeSE(i,j)
		Node = Grid.nodeSE(i,j).X;
		break;
	      }
	      break;

	    case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	      switch(nLoop){
	      case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICl && Grid.BndWestSplineInfo != NULL && j>=JCl && j<=JCu ){
		  Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceW(i,j);
		}
		break;
	      case 2:		// output Grid.CellCentroid(i,j)
		Node = Grid.CellCentroid(i,j);
		break;
	      case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICu && Grid.BndEastSplineInfo != NULL && j>=JCl && j<=JCu ){
		  Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceE(i,j);
		}
		break;
	      }
	      break;

	    case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeNW(i,j)
		Node = Grid.nodeNW(i,j).X;
		break;
	      case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCu && Grid.BndNorthSplineInfo != NULL && i>= ICl && i<= ICu ){
		  Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceN(i,j);
		}
		break;
	      case 3:		// output NodeNE(i,j)
		Node = Grid.nodeNE(i,j).X;
		break;
	      }
	      break;
	    } // endswitch

	    // Output Brief format
	    U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << U_node;


	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File << " " << U[i][j].V(Node.x,Node.y)
		       << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		       << " " << source(Node.x,Node.y,U_node);
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	      Out_File.unsetf(ios::scientific);
	      if (ExactSoln->IsExactSolutionSet()){
		Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	      }
	    }

	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File << " " << dUdt[i][j][0];
	    }

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);

	  }
	} /* endfor */
      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the nodes (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									   const AdvectDiffuse2D_Input_Parameters &IP,
									   const int &Block_Number,
									   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_nodes_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Nodes_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Nodes_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all cells (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder(const int &Number_of_Time_Steps,
								const double &Time,
								const int &Block_Number,
								const int &Output_Title,
								ostream &Out_File,
								const int &IndexHO) {


    int i, j;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output cell centroid solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"UAvg\" \\ \n"
		  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for (j = JCl-Nghost; j <= JCu+Nghost; ++j) {// for every j Cell
      for (i = ICl-Nghost; i <= ICu+Nghost; ++i) {// for every i Cell

	// Set the location
	Node = Grid.CellCentroid(i,j);

	if (i < ICl-HighOrderVariable(IndexHO).NghostHO() || 
	    i > ICu+HighOrderVariable(IndexHO).NghostHO() || 
	    j < JCl-HighOrderVariable(IndexHO).NghostHO() ||
	    j > JCu+HighOrderVariable(IndexHO).NghostHO()  ) {

	  // No high-order interpolant is calculated for this cells.
	  // The average solution is plotted at the centers of these cells.
	  
	  // Output Brief format
	  Out_File << " "  << Node 
		   << " "  << CellSolution(i,j);

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    Out_File << " " << U[i][j].V(Node.x,Node.y)
		     << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		     << " " << source(Node.x,Node.y,U_node);
	    Out_File.setf(ios::scientific);
	    Out_File << " " << 1.0E8
		     << " " << 0;
	    Out_File.unsetf(ios::scientific);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File << " " << dUdt[i][j][0];
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} else {

	  // Use the high-order interpolant to calculate the solution at the cell centroids.
	  
	  // Output Brief format
	  U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	  Out_File << " "  << Node 
		   << " "  << U_node;

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    Out_File << " " << U[i][j].V(Node.x,Node.y)
		     << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		     << " " << source(Node.x,Node.y,U_node);
	    Out_File.setf(ios::scientific);
	    Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	    Out_File.unsetf(ios::scientific);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File << " " << dUdt[i][j][0];
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} // endif

      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the centroids (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost cells for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									   const AdvectDiffuse2D_Input_Parameters &IP,
									   const int &Block_Number,
									   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cells_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Cells_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Cells_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}
