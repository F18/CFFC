/*! \file AdvectDiffuse2DQuad_HighOrder.cc
  @brief High-order Subroutines for 2D Advection Diffusion Equation Quadrilateral Mesh Solution Classes. */

/* Include required C++ libraries. */
// None

/* Using std namespace functions */
// None

/* Include CFFC header files */
#include "AdvectDiffuse2DQuad.h"        // AdvectDiffuse2D_Quad_Block class

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the interior nodes of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 *
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 */
void AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							  const double &Time,
							  const int &Block_Number,
							  const int &Output_Title,
							  ostream &Out_File,
							  const int &IndexHO) {

    int i, j, nRow, nLoop;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output node solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (NCi - 2*Nghost)*3  << " \\ \n"
	       << "J = " << (NCj - 2*Nghost)*3 << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (NCi - 2*Nghost)*3 << " \\ \n"
	       << "J = " << (NCj - 2*Nghost)*3 << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for ( j  = JCl ; j <= JCu ; ++j ) {	// for every j Cell
      for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
	for ( i = ICl ; i <= ICu ; ++i ) { // for every i Cell
	  for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	    // Get the node location
	    switch(nRow){
	    case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeSW(i,j)
		Node = Grid.nodeSW(i,j).X;
		break;
	      case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCl && Grid.BndSouthSplineInfo != NULL){
		  Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceS(i,j);
		}
		break;
	      case 3:		// output NodeSE(i,j)
		Node = Grid.nodeSE(i,j).X;
		break;
	      }
	      break;

	    case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	      switch(nLoop){
	      case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICl && Grid.BndWestSplineInfo != NULL){
		  Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceW(i,j);
		}
		break;
	      case 2:		// output Grid.CellCentroid(i,j)
		Node = Grid.CellCentroid(i,j);
		break;
	      case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICu && Grid.BndEastSplineInfo != NULL){
		  Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceE(i,j);
		}
		break;
	      }
	      break;

	    case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeNW(i,j)
		Node = Grid.nodeNW(i,j).X;
		break;
	      case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCu && Grid.BndNorthSplineInfo != NULL){
		  Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceN(i,j);
		}
		break;
	      case 3:		// output NodeNE(i,j)
		Node = Grid.nodeNE(i,j).X;
		break;
	      }
	      break;
	    } // endswitch

	    // Output Brief format
	    U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << U_node;


	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File << " " << U[i][j].V(Node.x,Node.y)
		       << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		       << " " << source(Node.x,Node.y,U_node);
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	      Out_File.unsetf(ios::scientific);
	      if (ExactSoln->IsExactSolutionSet()){
		Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	      }
	    }

	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File << " " << dUdt[i][j][0];
	    }

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);

	  }
	} /* endfor */
      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the interior nodes of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								     const AdvectDiffuse2D_Input_Parameters &IP,
								     const int &Block_Number,
								     const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  
  /* Open the output data file. */
  
  output_file.open(output_file_name, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }
  
  try {
    Output_Tecplot_HighOrder(0,0,
			     Block_Number,
			     1,
			     output_file,
			     IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }

  /* Close the output data file. */
  output_file.close();

  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all nodes (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 */
void AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
								const double &Time,
								const int &Block_Number,
								const int &Output_Title,
								ostream &Out_File,
								const int &IndexHO) {

    int i, j, nRow, nLoop;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output node solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3  << " \\ \n"
	       << "J = " << ( JCu - JCl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (ICu - ICl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "J = " << (JCu - JCl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for (j=JCl-HighOrderVariable(IndexHO).NghostHO(); j<=JCu+HighOrderVariable(IndexHO).NghostHO(); ++j) {// for every j Cell
      for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
	for (i=ICl-HighOrderVariable(IndexHO).NghostHO(); i<=ICu+HighOrderVariable(IndexHO).NghostHO(); ++i) {// for every i Cell
	  for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	    // Get the node location
	    switch(nRow){
	    case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeSW(i,j)
		Node = Grid.nodeSW(i,j).X;
		break;
	      case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCl && Grid.BndSouthSplineInfo != NULL && i>= ICl && i<= ICu ){
		  Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceS(i,j);
		}
		break;
	      case 3:		// output NodeSE(i,j)
		Node = Grid.nodeSE(i,j).X;
		break;
	      }
	      break;

	    case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	      switch(nLoop){
	      case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICl && Grid.BndWestSplineInfo != NULL && j>=JCl && j<=JCu ){
		  Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceW(i,j);
		}
		break;
	      case 2:		// output Grid.CellCentroid(i,j)
		Node = Grid.CellCentroid(i,j);
		break;
	      case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICu && Grid.BndEastSplineInfo != NULL && j>=JCl && j<=JCu ){
		  Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceE(i,j);
		}
		break;
	      }
	      break;

	    case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeNW(i,j)
		Node = Grid.nodeNW(i,j).X;
		break;
	      case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCu && Grid.BndNorthSplineInfo != NULL && i>= ICl && i<= ICu ){
		  Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceN(i,j);
		}
		break;
	      case 3:		// output NodeNE(i,j)
		Node = Grid.nodeNE(i,j).X;
		break;
	      }
	      break;
	    } // endswitch

	    // Output Brief format
	    U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << U_node;


	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File << " " << U[i][j].V(Node.x,Node.y)
		       << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		       << " " << source(Node.x,Node.y,U_node);
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	      Out_File.unsetf(ios::scientific);
	      if (ExactSoln->IsExactSolutionSet()){
		Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	      }
	    }

	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File << " " << dUdt[i][j][0];
	    }

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);

	  }
	} /* endfor */
      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the nodes (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									   const AdvectDiffuse2D_Input_Parameters &IP,
									   const int &Block_Number,
									   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_nodes_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Nodes_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Nodes_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all cells (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder(const int &Number_of_Time_Steps,
								const double &Time,
								const int &Block_Number,
								const int &Output_Title,
								ostream &Out_File,
								const int &IndexHO) {


    int i, j;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output cell centroid solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"UAvg\" \\ \n"
		  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for (j = JCl-Nghost; j <= JCu+Nghost; ++j) {// for every j Cell
      for (i = ICl-Nghost; i <= ICu+Nghost; ++i) {// for every i Cell

	// Set the location
	Node = Grid.CellCentroid(i,j);

	if (i < ICl-HighOrderVariable(IndexHO).NghostHO() || 
	    i > ICu+HighOrderVariable(IndexHO).NghostHO() || 
	    j < JCl-HighOrderVariable(IndexHO).NghostHO() ||
	    j > JCu+HighOrderVariable(IndexHO).NghostHO()  ) {

	  // No high-order interpolant is calculated for this cells.
	  // The average solution is plotted at the centers of these cells.
	  
	  // Output Brief format
	  Out_File << " "  << Node 
		   << " "  << CellSolution(i,j);

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    Out_File << " " << U[i][j].V(Node.x,Node.y)
		     << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		     << " " << source(Node.x,Node.y,U_node);
	    Out_File.setf(ios::scientific);
	    Out_File << " " << 1.0E8
		     << " " << 0;
	    Out_File.unsetf(ios::scientific);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File << " " << dUdt[i][j][0];
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} else {

	  // Use the high-order interpolant to calculate the solution at the cell centroids.
	  
	  // Output Brief format
	  U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	  Out_File << " "  << Node 
		   << " "  << U_node;

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    Out_File << " " << U[i][j].V(Node.x,Node.y)
		     << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		     << " " << source(Node.x,Node.y,U_node);
	    Out_File.setf(ios::scientific);
	    Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	    Out_File.unsetf(ios::scientific);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File << " " << dUdt[i][j][0];
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} // endif

      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the centroids (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost cells for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									   const AdvectDiffuse2D_Input_Parameters &IP,
									   const int &Block_Number,
									   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cells_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Cells_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Cells_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Evaluate the residual for the solution block 
 * using the high-order CENO upwind finite-volume 
 * spatial discretization scheme for the  
 * convective flux coupled with a centrally-weighted    
 * high-order finite-volume discretization for the diffusive flux.  
 * The residual is stored in dUdt[][][k_residual].
 *
 * \param IP  input parameters object
 * \param Pos index to identify the high-order variable used to calculate the residual
 * \param k_residual index to identify the residual storage location
 *
 * \todo Optimize the number of high-order evaluations for different boundary conditions!
 */
int AdvectDiffuse2D_Quad_Block::dUdt_Residual_HighOrder(const AdvectDiffuse2D_Input_Parameters &IP,
							const int & k_residual,
							const bool & UseTimeStep,
							const unsigned short int Pos){

  // SET VARIABLES USED IN THE RESIDUAL CALCULATION PROCESS

  int i, j, GQPoint, Position, SplineSegment;
  bool IsNonSmoothHighOrderReconstruction;
  AdvectDiffuse2D_State Ul, Ur, U_face, Flux, FaceFlux;
  Vector2D GradU_face, GradUl, GradUr;		// Solution gradient at the inter-cellular face
  int NumGQP(Grid.getNumGQP());	  // Number of Gauss quadrature points per face used to compute the flux integral

  Vector2D *GaussQuadPoints = new Vector2D [NumGQP]; // the GQPs at which a Riemann-like problem is solved
  double * GaussQuadWeights = new double [NumGQP];   // the Gauss integration weights for each Gauss quadrature


  /* Set the GaussQuadWeights. */
  GaussQuadratureData::getGaussQuadWeights(GaussQuadWeights, NumGQP);

  /* Evaluate the solution residual 
     and write it to dUdt[][][k_residual]. */

  /***************************************************************************************
   *                 EVALUATE THE HIGH-ORDER SOLUTION RESIDUALS                          *
   *                                                                                     *
   * Algorithm Purpose: To evaluate solution residuals for solution blocks               *
   *                    characterized by a broad range of options.                       *
   *                                                                                     *
   * Important options to consider:                                                      *
   *         --> Geometry treatment: high-order or low-order                             *
   *         --> Spatial accuracy:   order of accuracy for flux calculation              *
   *         --> Boundary flux calculation: 'Riemann' problem or reconstruction based    *
   *                                                                                     *
   * In order to respond easier to all these parameter variations, the following         *
   * algorithm is adopted to sweep through the cell interfaces:                          *
   *         --> Compute all fluxes at interior inter-cellular faces.                    *
   *         --> Compute fluxes for North, South, East and West block boundary faces.    *
   *                                                                                     *
   * Note: Two passes are needed to compute both elliptic and hyperbolic terms!          *
   ***************************************************************************************/

  /* Evaluate the time rate of change of the solution
     (i.e., the solution residuals) using a centrally-weighted
     gradient reconstruction for the diffusive fluxes.
     NOTE: Include here the contribution of the elliptic and source terms! */

   
  /* Perform the unlimited high-order reconstruction within 
     each cell of the computational grid for this stage. 
     NOTE: This solution reconstruction IS NOT recommended for computing hyperbolic fluxes!
  */
  HighOrderVariable(Pos).ComputeUnlimitedSolutionReconstruction(*this);

  // ** Step 1. Compute interior diffusive fluxes and any source contributions for cells between (ICl,JCl)-->(ICu,JCu) **
  // ********************************************************************************************************************
  for ( j = JCl ; j <= JCu ; ++j ){
    for ( i = ICl ; i <= ICu ; ++i ) {

      if (Include_Diffusion_Term){
      
	if ( i != ICu) { 		// (i == ICu) corresponds to the East block boundary which will be considered separately!
	
	  /* Evaluate the cell interface i-direction diffusive fluxes.
	     --> ( i.e. East Flux for cell (i,j) & West Flux for cell (i+1,j) ) */
	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(i,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i  ,j,GaussQuadPoints[GQPoint]);
	    Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i+1,j,GaussQuadPoints[GQPoint]);

	    // Determine the solution state at the Gauss quadrature
	    // point for the calculation of the diffusion coefficient
	    U_face = 0.5*(Ul + Ur);

	    // Calculate gradient at the Gauss quadrature point using a centrally-weighted reconstruction.
	    GradU_face = 0.5*Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i  ,j,GaussQuadPoints[GQPoint])[1] + 
				      HighOrderVariable(Pos).XGradientStateAtLocation(i+1,j,GaussQuadPoints[GQPoint])[1] ,
				      HighOrderVariable(Pos).YGradientStateAtLocation(i  ,j,GaussQuadPoints[GQPoint])[1] + 
				      HighOrderVariable(Pos).YGradientStateAtLocation(i+1,j,GaussQuadPoints[GQPoint])[1]);

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceE(i, j));

	  } //endfor (GQPoint)
      
	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[i  ][j][k_residual] -= ( (IP.CFL_Number * dt[i  ][j])*
					  Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );
	    
	    dUdt[i+1][j][k_residual] += ( (IP.CFL_Number * dt[i+1][j])*
					  Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	  } else {
	    dUdt[i  ][j][k_residual] -= ( Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );
	    
	    dUdt[i+1][j][k_residual] += ( Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	  }

	}	//endif (i != ICu)


	if ( j != JCu) {		// (j == JCu) corresponds to the North block boundary which will be considered separately!

	  /* Evaluate the cell interface j-direction diffusive fluxes.
	     --> ( i.e. North Flux for cell (i,j) & South Flux for cell (i,j+1) ) */
	  // Determine the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,j  ,GaussQuadPoints[GQPoint]);
	    Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i,j+1,GaussQuadPoints[GQPoint]);

	    // Determine the solution state at the Gauss quadrature
	    // point for the calculation of the diffusion coefficient
	    U_face = 0.5*(Ul + Ur);

	    // Calculate gradient at the Gauss quadrature point using a centrally-weighted reconstruction.
	    GradU_face = 0.5*Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,j  ,GaussQuadPoints[GQPoint])[1] + 
				      HighOrderVariable(Pos).XGradientStateAtLocation(i,j+1,GaussQuadPoints[GQPoint])[1] ,
				      HighOrderVariable(Pos).YGradientStateAtLocation(i,j  ,GaussQuadPoints[GQPoint])[1] + 
				      HighOrderVariable(Pos).YGradientStateAtLocation(i,j+1,GaussQuadPoints[GQPoint])[1]);

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceN(i, j));
	  } //endfor (GQPoint)


	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[i][j  ][k_residual] -= ( (IP.CFL_Number * dt[i][j  ])*
					  Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );
	    
	    dUdt[i][j+1][k_residual] += ( (IP.CFL_Number * dt[i][j+1])*
					  Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	  } else {
	    dUdt[i][j  ][k_residual] -= ( Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );
	    
	    dUdt[i][j+1][k_residual] += ( Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	  }

	} //endif (j != JCu)

      }	// endif (Include_Diffusion_Term)

      /* Include regular source terms. */
      if (Include_Source_Term) {
	if (UseTimeStep) {
	  dUdt[i][j][k_residual] += (IP.CFL_Number*dt[i][j])*SourceTerm(i,j);
	} else {
	  dUdt[i][j][k_residual] += SourceTerm(i,j);
	}
      }
	
      /* Include axisymmetric source terms as required. */
      if (Axisymmetric) {
	if (UseTimeStep) {
	  dUdt[i][j][k_residual] += ( (IP.CFL_Number*dt[i][j])*
				      AxisymmetricSourceTerm(i,j) );
	} else {
	  dUdt[i][j][k_residual] += ( AxisymmetricSourceTerm(i,j) );
	}
      } /* endif */

    } // endfor (i)
  } // endfor (j)


  if (Include_Diffusion_Term){

    // ****** Step 2. Compute diffusive fluxes through North block boundary ******
    // ***************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure. */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndNorthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
     
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Reset North flux for the current cell
	  FluxN[i].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the diffusion coefficient based on the constrained reconstruction.
	      U_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	      GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu,
										    Grid.BndNorthSplineInfo[i].GQPoint(Position))[1],
				    HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu,
										    Grid.BndNorthSplineInfo[i].GQPoint(Position))[1]);

	      /* Add the weighted contribution of the current GQP to the total 
		 diffusive flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
						     Grid.BndNorthSplineInfo[i].GQPoint(Position), 
						     Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update North face boundary flux with the contribution of this spline segment
	    FluxN[i] += Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FluxN[i]/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxN[i].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of the diffusion coefficient based on the constrained reconstruction.
	    U_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);

	    // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	    GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu,GaussQuadPoints[GQPoint])[1],
				  HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu,GaussQuadPoints[GQPoint])[1]);

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    FluxN[i] += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceN(i,JCu));
	  } //endfor (GQPoint)
	
	  // Update North face boundary flux with the contribution of this cell face
	  FluxN[i] *= Grid.lfaceN(i,JCu);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* FluxN[i]/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)

      } // endif (Grid.BndNorthSplineInfo != NULL)


    } else {
      /* Calculate the flux using the centrally-weighted gradient reconstruction
	 and ensure that boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndNorthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Reset North flux for the current cell
	  FluxN[i].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left and right interface states at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu  ,Grid.BndNorthSplineInfo[i].GQPoint(Position));
	      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu+1,Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Compute left and right interface gradients at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu,
										Grid.BndNorthSplineInfo[i].GQPoint(Position))[1],
				HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu,
										Grid.BndNorthSplineInfo[i].GQPoint(Position))[1]);
	      GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu+1,
										Grid.BndNorthSplineInfo[i].GQPoint(Position))[1] ,
				HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu+1,
										Grid.BndNorthSplineInfo[i].GQPoint(Position))[1]);
	    
	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the diffusion coefficient and the gradient at the interface such that
	      // to satisfy the specified boundary conditions.
	      ViscousFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							      i,JCu,
							      Ul,Ur,
							      U_face,
							      GradUl,GradUr,
							      GradU_face,
							      Grid.BndNorthSplineInfo[i].GQPoint(Position),
							      Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 diffusive flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
						     Grid.BndNorthSplineInfo[i].GQPoint(Position), 
						     Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update North face boundary flux with the contribution of this spline segment
	    FluxN[i] += Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FluxN[i]/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	  // Reset North flux for the current cell
	  FluxN[i].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu  ,GaussQuadPoints[GQPoint]);
	    Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu+1,GaussQuadPoints[GQPoint]);

	    // Compute left and right interface gradients at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu,GaussQuadPoints[GQPoint])[1],
			      HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu,GaussQuadPoints[GQPoint])[1]);
	    GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu+1,GaussQuadPoints[GQPoint])[1] ,
			      HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu+1,GaussQuadPoints[GQPoint])[1]);	

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of the diffusion coefficient and the gradient at the interface such that
	    // to satisfy the specified boundary conditions.
	    ViscousFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							    i,JCu,
							    Ul,Ur,
							    U_face,
							    GradUl,GradUr,
							    GradU_face,
							    GaussQuadPoints[GQPoint],
							    Grid.nfaceN(i,JCu));

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    FluxN[i] += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceN(i,JCu));
	  } //endfor (GQPoint)
	
	  // Update North face boundary flux with the contribution of this cell face
	  FluxN[i] *= Grid.lfaceN(i,JCu);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* FluxN[i]/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)
      
      } // endif (Grid.BndNorthSplineInfo != NULL)
    
    } // endif (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 3. Compute diffusive fluxes through South block boundary ******
    // ***************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure. */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndSouthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
     
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Reset South flux for the current cell
	  FluxS[i].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the diffusion coefficient based on the constrained reconstruction.
	      U_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	      GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl,
										    Grid.BndSouthSplineInfo[i].GQPoint(Position))[1],
				    HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl,
										    Grid.BndSouthSplineInfo[i].GQPoint(Position))[1]);

	      /* Add the weighted contribution of the current GQP to the total 
		 diffusive flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
						     Grid.BndSouthSplineInfo[i].GQPoint(Position), 
						     Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update South face boundary flux with the contribution of this spline segment
	    FluxS[i] += Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FluxS[i]/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxS[i].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of the diffusion coefficient based on the constrained reconstruction.
	    U_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);

	    // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	    GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl,GaussQuadPoints[GQPoint])[1],
				  HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl,GaussQuadPoints[GQPoint])[1]);

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    FluxS[i] += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceS(i,JCl));
	  } //endfor (GQPoint)
	
	  // Update South face boundary flux with the contribution of this cell face
	  FluxS[i] *= Grid.lfaceS(i,JCl);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* FluxS[i]/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)

      } // endif (Grid.BndSouthSplineInfo != NULL)


    } else {
      /* Calculate the flux using the centrally-weighted gradient reconstruction
	 and ensure that boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndSouthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Reset South flux for the current cell	  
	  FluxS[i].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left and right interface states at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl  ,Grid.BndSouthSplineInfo[i].GQPoint(Position));
	      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl-1,Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      // Compute left and right interface gradients at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl,
										Grid.BndSouthSplineInfo[i].GQPoint(Position))[1],
				HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl,
										Grid.BndSouthSplineInfo[i].GQPoint(Position))[1]);
	      GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl-1,
										Grid.BndSouthSplineInfo[i].GQPoint(Position))[1] ,
				HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl-1,
										Grid.BndSouthSplineInfo[i].GQPoint(Position))[1]);
	    
	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the diffusion coefficient and the gradient at the interface such that
	      // to satisfy the specified boundary conditions.
	      ViscousFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							      i,JCl,
							      Ul,Ur,
							      U_face,
							      GradUl,GradUr,
							      GradU_face,
							      Grid.BndSouthSplineInfo[i].GQPoint(Position),
							      Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 diffusive flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
						     Grid.BndSouthSplineInfo[i].GQPoint(Position), 
						     Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update South face boundary flux with the contribution of this spline segment
	    FluxS[i] += Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FluxS[i]/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxS[i].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl  ,GaussQuadPoints[GQPoint]);
	    Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl-1,GaussQuadPoints[GQPoint]);

	    // Compute left and right interface gradients at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl,GaussQuadPoints[GQPoint])[1],
			      HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl,GaussQuadPoints[GQPoint])[1]);
	    GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl-1,GaussQuadPoints[GQPoint])[1] ,
			      HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl-1,GaussQuadPoints[GQPoint])[1]);	

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of the diffusion coefficient and the gradient at the interface such that
	    // to satisfy the specified boundary conditions.
	    ViscousFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							    i,JCl,
							    Ul,Ur,
							    U_face,
							    GradUl,GradUr,
							    GradU_face,
							    GaussQuadPoints[GQPoint],
							    Grid.nfaceS(i,JCl));

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    FluxS[i] += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceS(i,JCl));
	  } //endfor (GQPoint)
	
	  // Update South face boundary flux with the contribution of this cell face
	  FluxS[i] *= Grid.lfaceS(i,JCl);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* FluxS[i]/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)
      
      } // endif (Grid.BndSouthSplineInfo != NULL)
    
    } // endif (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 4. Compute diffusive fluxes through East block boundary ******
    // **************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure. */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndEastSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
     
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Reset East flux for the current cell
	  FluxE[j].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the diffusion coefficient based on the constrained reconstruction.
	      U_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	      GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICu,j,
										    Grid.BndEastSplineInfo[j].GQPoint(Position))[1],
				    HighOrderVariable(Pos).YGradientStateAtLocation(ICu,j,
										    Grid.BndEastSplineInfo[j].GQPoint(Position))[1]);

	      /* Add the weighted contribution of the current GQP to the total 
		 diffusive flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
						     Grid.BndEastSplineInfo[j].GQPoint(Position), 
						     Grid.BndEastSplineInfo[j].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update East face boundary flux with the contribution of this spline segment
	    FluxE[j] += Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FluxE[j]/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	  }
	  
	} // endfor (j)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxE[j].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of the diffusion coefficient based on the constrained reconstruction.
	    U_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);

	    // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	    GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICu,j,GaussQuadPoints[GQPoint])[1],
				  HighOrderVariable(Pos).YGradientStateAtLocation(ICu,j,GaussQuadPoints[GQPoint])[1]);

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    FluxE[j] += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceE(ICu,j));
	  } //endfor (GQPoint)
	
	  // Update East face boundary flux with the contribution of this cell face
	  FluxE[j] *= Grid.lfaceE(ICu,j);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* FluxE[j]/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)

      } // endif (Grid.BndEastSplineInfo != NULL)


    } else {
      /* Calculate the flux using the centrally-weighted gradient reconstruction
	 and ensure that boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndEastSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Reset East flux for the current cell
	  FluxE[j].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left and right interface states at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICu  ,j,Grid.BndEastSplineInfo[j].GQPoint(Position));
	      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ICu+1,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Compute left and right interface gradients at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICu,j,
										Grid.BndEastSplineInfo[j].GQPoint(Position))[1],
				HighOrderVariable(Pos).YGradientStateAtLocation(ICu,j,
										Grid.BndEastSplineInfo[j].GQPoint(Position))[1]);
	      GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICu+1,j,
										Grid.BndEastSplineInfo[j].GQPoint(Position))[1] ,
				HighOrderVariable(Pos).YGradientStateAtLocation(ICu+1,j,
										Grid.BndEastSplineInfo[j].GQPoint(Position))[1]);
	    
	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the diffusion coefficient and the gradient at the interface such that
	      // to satisfy the specified boundary conditions.
	      ViscousFluxStates_AtBoundaryInterface_HighOrder(EAST,
							      ICu,j,
							      Ul,Ur,
							      U_face,
							      GradUl,GradUr,
							      GradU_face,
							      Grid.BndEastSplineInfo[j].GQPoint(Position),
							      Grid.BndEastSplineInfo[j].NormalGQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 diffusive flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
						     Grid.BndEastSplineInfo[j].GQPoint(Position), 
						     Grid.BndEastSplineInfo[j].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update East face boundary flux with the contribution of this spline segment
	    FluxE[j] += Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FluxE[j]/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxE[j].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICu  ,j,GaussQuadPoints[GQPoint]);
	    Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ICu+1,j,GaussQuadPoints[GQPoint]);

	    // Compute left and right interface gradients at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICu  ,j,GaussQuadPoints[GQPoint])[1],
			      HighOrderVariable(Pos).YGradientStateAtLocation(ICu  ,j,GaussQuadPoints[GQPoint])[1]);
	    GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICu+1,j,GaussQuadPoints[GQPoint])[1] ,
			      HighOrderVariable(Pos).YGradientStateAtLocation(ICu+1,j,GaussQuadPoints[GQPoint])[1]);	

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of the diffusion coefficient and the gradient at the interface such that
	    // to satisfy the specified boundary conditions.
	    ViscousFluxStates_AtBoundaryInterface_HighOrder(EAST,
							    ICu,j,
							    Ul,Ur,
							    U_face,
							    GradUl,GradUr,
							    GradU_face,
							    GaussQuadPoints[GQPoint],
							    Grid.nfaceE(ICu,j));

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    FluxE[j] += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceE(ICu,j));
	  } //endfor (GQPoint)
	
	  // Update East face boundary flux with the contribution of this cell face
	  FluxE[j] *= Grid.lfaceE(ICu,j);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* FluxE[j]/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)
      
      } // endif (Grid.BndEastSplineInfo != NULL)
    
    } // endif (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 5. Compute diffusive fluxes through West block boundary ******
    // **************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure. */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndWestSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
     
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Reset West flux for the current cell
	  FluxW[j].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the diffusion coefficient based on the constrained reconstruction.
	      U_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	      GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICl,j,
										    Grid.BndWestSplineInfo[j].GQPoint(Position))[1],
				    HighOrderVariable(Pos).YGradientStateAtLocation(ICl,j,
										    Grid.BndWestSplineInfo[j].GQPoint(Position))[1]);

	      /* Add the weighted contribution of the current GQP to the total 
		 diffusive flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
						     Grid.BndWestSplineInfo[j].GQPoint(Position), 
						     Grid.BndWestSplineInfo[j].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update West face boundary flux with the contribution of this spline segment
	    FluxW[j] += Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FluxW[j]/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxW[j].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of the diffusion coefficient based on the constrained reconstruction.
	    U_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);

	    // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	    GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICl,j,GaussQuadPoints[GQPoint])[1],
				  HighOrderVariable(Pos).YGradientStateAtLocation(ICl,j,GaussQuadPoints[GQPoint])[1]);

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    FluxW[j] += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceW(ICl,j));
	  } //endfor (GQPoint)
	
	  // Update West face boundary flux with the contribution of this cell face
	  FluxW[j] *= Grid.lfaceW(ICl,j);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* FluxW[j]/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)

      } // endif (Grid.BndWestSplineInfo != NULL)


    } else {
      /* Calculate the flux using the centrally-weighted gradient reconstruction
	 and ensure that boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndWestSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Reset West flux for the current cell
	  FluxW[j].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left and right interface states at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICl  ,j,Grid.BndWestSplineInfo[j].GQPoint(Position));
	      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ICl-1,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Compute left and right interface gradients at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICl,j,
										Grid.BndWestSplineInfo[j].GQPoint(Position))[1],
				HighOrderVariable(Pos).YGradientStateAtLocation(ICl,j,
										Grid.BndWestSplineInfo[j].GQPoint(Position))[1]);
	      GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICl-1,j,
										Grid.BndWestSplineInfo[j].GQPoint(Position))[1] ,
				HighOrderVariable(Pos).YGradientStateAtLocation(ICl-1,j,
										Grid.BndWestSplineInfo[j].GQPoint(Position))[1]);
	    
	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the diffusion coefficient and the gradient at the interface such that
	      // to satisfy the specified boundary conditions.
	      ViscousFluxStates_AtBoundaryInterface_HighOrder(WEST,
							      ICl,j,
							      Ul,Ur,
							      U_face,
							      GradUl,GradUr,
							      GradU_face,
							      Grid.BndWestSplineInfo[j].GQPoint(Position),
							      Grid.BndWestSplineInfo[j].NormalGQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 diffusive flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
						     Grid.BndWestSplineInfo[j].GQPoint(Position), 
						     Grid.BndWestSplineInfo[j].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update West face boundary flux with the contribution of this spline segment
	    FluxW[j] += Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FluxW[j]/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxW[j].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICl  ,j,GaussQuadPoints[GQPoint]);
	    Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ICl-1,j,GaussQuadPoints[GQPoint]);

	    // Compute left and right interface gradients at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICl  ,j,GaussQuadPoints[GQPoint])[1],
			      HighOrderVariable(Pos).YGradientStateAtLocation(ICl  ,j,GaussQuadPoints[GQPoint])[1]);
	    GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(ICl-1,j,GaussQuadPoints[GQPoint])[1] ,
			      HighOrderVariable(Pos).YGradientStateAtLocation(ICl-1,j,GaussQuadPoints[GQPoint])[1]);	

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of the diffusion coefficient and the gradient at the interface such that
	    // to satisfy the specified boundary conditions.
	    ViscousFluxStates_AtBoundaryInterface_HighOrder(WEST,
							    ICl,j,
							    Ul,Ur,
							    U_face,
							    GradUl,GradUr,
							    GradU_face,
							    GaussQuadPoints[GQPoint],
							    Grid.nfaceW(ICl,j));

	    /* Add the weighted contribution of the current GQP to the total 
	       diffusive flux through the face in the normal direction. */
	    FluxW[j] += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceW(ICl,j));
	  } //endfor (GQPoint)
	
	  // Update West face boundary flux with the contribution of this cell face
	  FluxW[j] *= Grid.lfaceW(ICl,j);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* FluxW[j]/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)
      
      } // endif (Grid.BndWestSplineInfo != NULL)
    
    } // endif (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux)

  } // endif (Include_Diffusion_Term)

  /*****************************************************************
   * --------------------------------------------------------------*
     Evaluate the time rate of change of the solution 
     (i.e., the solution residuals) using a high-order 
     CENO upwind finite-volume scheme for the convective fluxes.
     NOTE: Include here the contribution of the hyperbolic terms! */

  if (Include_Advection_Term){

    /* Enforce monotonicity to the high-order interpolants detected as 
       non-smooth by the smoothness indicator analysis. 
       NOTE: This solution reconstruction IS recommended for computing hyperbolic fluxes!
    */
    HighOrderVariable(Pos).ComputeSmoothnessIndicator(*this);
    HighOrderVariable(Pos).EnforceMonotonicityToNonSmoothInterpolants(*this, IP.Limiter());


    // ** Step 6. Compute interior convective fluxes for cells between (ICl,JCl)-->(ICu,JCu) **
    // ****************************************************************************************
    for ( j = JCl ; j <= JCu ; ++j ){
      for ( i = ICl ; i <= ICu ; ++i ) {
      
	if ( i != ICu) { 		// (i == ICu) corresponds to the East block boundary which will be considered separately!
	
	  /* Evaluate the cell interface i-direction diffusive fluxes.
	     --> ( i.e. East Flux for cell (i,j) & West Flux for cell (i+1,j) ) */
	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(i,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i  ,j,GaussQuadPoints[GQPoint]);
	    Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i+1,j,GaussQuadPoints[GQPoint]);

	    /* Add the weighted contribution of the current GQP to the total 
	       convective flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceE(i, j));

	  } //endfor (GQPoint)
      
	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i  ][j][k_residual] -= ( (IP.CFL_Number * dt[i  ][j])*
					  Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );

	    dUdt[i+1][j][k_residual] += ( (IP.CFL_Number * dt[i+1][j])*
					  Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	  } else {
	    dUdt[i  ][j][k_residual] -= ( Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );

	    dUdt[i+1][j][k_residual] += ( Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	  }

	} //endif (i != ICu)


	if ( j != JCu) {		// (j == JCu) corresponds to the North block boundary which will be considered separately!

	  /* Evaluate the cell interface j-direction convective fluxes.
	     --> ( i.e. North Flux for cell (i,j) & South Flux for cell (i,j+1) ) */
	  // Determine the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,j  ,GaussQuadPoints[GQPoint]);
	    Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i,j+1,GaussQuadPoints[GQPoint]);

	    /* Add the weighted contribution of the current GQP to the total 
	       convective flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceN(i, j));
	  } //endfor (GQPoint)


	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][j  ][k_residual] -= ( (IP.CFL_Number * dt[i][j  ])*
					  Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );

	    dUdt[i][j+1][k_residual] += ( (IP.CFL_Number * dt[i][j+1])*
					  Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	  } else {
	    dUdt[i][j  ][k_residual] -= ( Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );

	    dUdt[i][j+1][k_residual] += ( Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	  }

	} //endif (j != JCu)

      } // endfor (i)
    } // endfor (j)

 
    // ****** Step 7. Compute convective fluxes through North block boundary ******
    // ***************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure.
	 If the high-order reconstruction has been detected as non-smooth compute an upwind flux
	 with the value provided by the ghost cell reconstruction.
      */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndNorthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
     
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Determine if the solution reconstruction was detected as non-smooth for the current cell.
	  IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCu);

	  // Reset face flux
	  FaceFlux.Vacuum();
	    
	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // == Check if the solution reconstruction was detected as non-smooth.
	      if ( IsNonSmoothHighOrderReconstruction ){

		// Compute left interface state at the current Gauss
		// point location based on the low-order reconstruction.
		Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,Grid.BndNorthSplineInfo[i].GQPoint(Position));
	      
		// Determine right interface state at the Gauss calculation point
		InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
								 i,JCu,
								 Ul,Ur,
								 Grid.BndNorthSplineInfo[i].GQPoint(Position),
								 Grid.BndNorthSplineInfo[i].NormalGQPoint(Position),
								 Pos);

		/* Add the weighted contribution of the current GQP to the total 
		   convective flux in the normal direction through the face. */
		Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur,
						       Grid.BndNorthSplineInfo[i].GQPoint(Position),
						       Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));

	      } else {

		// Determine the solution state at the Gauss quadrature point for the calculation 
		// of the advective flux based on the constrained reconstruction.
		U_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,Grid.BndNorthSplineInfo[i].GQPoint(Position));

		/* Add the weighted contribution of the current GQP to the total 
		   convective flux through the spline segment in the local normal direction. */
		Flux += GaussQuadWeights[GQPoint] * Fa(U_face,
						       Grid.BndNorthSplineInfo[i].GQPoint(Position), 
						       Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));
	      } // endif (IsNonSmoothHighOrderReconstruction)

	    } //endfor (GQPoint)
	
	    // Update FaceFlux with the contribution of this spline segment
	    FaceFlux += Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  // Update North face boundary flux with the contribution of the hyperbolic term
	  FluxN[i] += FaceFlux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FaceFlux/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FaceFlux/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Determine if the solution reconstruction was detected as non-smooth for the current cell.
	  IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCu);

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  // == Check if the solution reconstruction was detected as non-smooth.
	  if ( IsNonSmoothHighOrderReconstruction ){

	    // Calculate total flux through the cell face in the normal direction
	    for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);
	    
	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							       i,JCu,
							       Ul,Ur,
							       GaussQuadPoints[GQPoint],
							       Grid.nfaceN(i,JCu),
							       Pos);
	    
	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceN(i,JCu));
	    } //endfor (GQPoint)
	    
	  } else {

	    // Calculate total flux through the cell face in the normal direction
	    for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the advective flux based on the constrained reconstruction.
	      U_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);
	    
	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux through the face in the normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(U_face, GaussQuadPoints[GQPoint], Grid.nfaceN(i,JCu));
	    } //endfor (GQPoint)

	  } // endif
	
	  // Calculate final flux through the cell face
	  Flux *= Grid.lfaceN(i,JCu);

	  // Update North face boundary flux with the contribution of this cell face
	  FluxN[i] += Flux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* Flux/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( Flux/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)

      } // endif (Grid.BndNorthSplineInfo != NULL)


    } else {

      /* Calculate the flux using an upwind method and ensure that
	 boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndNorthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Reset face flux
	  FaceFlux.Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left interface state at the current Gauss
	      // point location based on the reconstruction
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,
								  Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							       i,JCu,
							       Ul,Ur,
							       Grid.BndNorthSplineInfo[i].GQPoint(Position),
							       Grid.BndNorthSplineInfo[i].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur,
						     Grid.BndNorthSplineInfo[i].GQPoint(Position), 
						     Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update FaceFlux with the contribution of this spline segment
	    FaceFlux += Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  // Update North face boundary flux with the contribution of the hyperbolic term
	  FluxN[i] += FaceFlux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FaceFlux/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FaceFlux/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							     i,JCu,
							     Ul,Ur,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceN(i,JCu),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       convective flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceN(i,JCu));
	  } //endfor (GQPoint)
	
	  // Calculate final flux through the cell face
	  Flux *= Grid.lfaceN(i,JCu);

	  // Update North face boundary flux with the contribution of this cell face
	  FluxN[i] += Flux;

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* Flux/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( Flux/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)
      
      } // endif (Grid.BndNorthSplineInfo != NULL)
    
    } // endif (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 8. Compute convective fluxes through South block boundary ******
    // ***************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure.
	 If the high-order reconstruction has been detected as non-smooth compute an upwind flux
	 with the value provided by the ghost cell reconstruction.
      */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndSouthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
     
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Determine if the solution reconstruction was detected as non-smooth for the current cell.
	  IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCl);

	  // Reset face flux
	  FaceFlux.Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // == Check if the solution reconstruction was detected as non-smooth.
	      if ( IsNonSmoothHighOrderReconstruction ){

		// Compute left interface state at the current Gauss
		// point location based on the low-order reconstruction.
		Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,Grid.BndSouthSplineInfo[i].GQPoint(Position));
	      
		// Determine right interface state at the Gauss calculation point
		InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
								 i,JCl,
								 Ul,Ur,
								 Grid.BndSouthSplineInfo[i].GQPoint(Position),
								 Grid.BndSouthSplineInfo[i].NormalGQPoint(Position),
								 Pos);

		/* Add the weighted contribution of the current GQP to the total 
		   convective flux in the normal direction through the face. */
		Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur,
						       Grid.BndSouthSplineInfo[i].GQPoint(Position),
						       Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));

	      } else {

		// Determine the solution state at the Gauss quadrature point for the calculation 
		// of the advective flux based on the constrained reconstruction.
		U_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,Grid.BndSouthSplineInfo[i].GQPoint(Position));

		/* Add the weighted contribution of the current GQP to the total 
		   convective flux through the spline segment in the local normal direction. */
		Flux += GaussQuadWeights[GQPoint] * Fa(U_face,
						       Grid.BndSouthSplineInfo[i].GQPoint(Position), 
						       Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));
	      } // endif (IsNonSmoothHighOrderReconstruction)

	    } //endfor (GQPoint)
	
	    // Update FaceFlux with the contribution of this spline segment
	    FaceFlux += Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  // Update South face boundary flux with the contribution of the hyperbolic term
	  FluxS[i] += FaceFlux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FaceFlux/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FaceFlux/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Determine if the solution reconstruction was detected as non-smooth for the current cell.
	  IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCl);

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  // == Check if the solution reconstruction was detected as non-smooth.
	  if ( IsNonSmoothHighOrderReconstruction ){

	    // Calculate total flux through the cell face in the normal direction
	    for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);
	    
	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							       i,JCl,
							       Ul,Ur,
							       GaussQuadPoints[GQPoint],
							       Grid.nfaceS(i,JCl),
							       Pos);
	    
	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceS(i,JCl));
	    } //endfor (GQPoint)
	    
	  } else {

	    // Calculate total flux through the cell face in the normal direction
	    for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the advective flux based on the constrained reconstruction.
	      U_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);
	    
	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux through the face in the normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(U_face, GaussQuadPoints[GQPoint], Grid.nfaceS(i,JCl));
	    } //endfor (GQPoint)

	  } // endif
	
	  // Calculate final flux through the cell face
	  Flux *= Grid.lfaceS(i,JCl);

	  // Update South face boundary flux with the contribution of this cell face
	  FluxS[i] += Flux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* Flux/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( Flux/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)

      } // endif (Grid.BndSouthSplineInfo != NULL)


    } else {

      /* Calculate the flux using an upwind method and ensure that
	 boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndSouthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Reset face flux
	  FaceFlux.Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left interface state at the current Gauss
	      // point location based on the reconstruction
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,
								  Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							       i,JCl,
							       Ul,Ur,
							       Grid.BndSouthSplineInfo[i].GQPoint(Position),
							       Grid.BndSouthSplineInfo[i].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur,
						     Grid.BndSouthSplineInfo[i].GQPoint(Position), 
						     Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update FaceFlux with the contribution of this spline segment
	    FaceFlux += Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  // Update South face boundary flux with the contribution of the hyperbolic term
	  FluxS[i] += FaceFlux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FaceFlux/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FaceFlux/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							     i,JCl,
							     Ul,Ur,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceS(i,JCl),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       convective flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceS(i,JCl));
	  } //endfor (GQPoint)
	
	  // Calculate final flux through the cell face
	  Flux *= Grid.lfaceS(i,JCl);

	  // Update South face boundary flux with the contribution of this cell face
	  FluxS[i] += Flux;

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* Flux/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( Flux/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)
      
      } // endif (Grid.BndSouthSplineInfo != NULL)
    
    } // endif (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 9. Compute convective fluxes through East block boundary ******
    // **************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure.
	 If the high-order reconstruction has been detected as non-smooth compute an upwind flux
	 with the value provided by the ghost cell reconstruction.
      */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndEastSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
     
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Determine if the solution reconstruction was detected as non-smooth for the current cell.
	  IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICu,j);

	  // Reset face flux
	  FaceFlux.Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // == Check if the solution reconstruction was detected as non-smooth.
	      if ( IsNonSmoothHighOrderReconstruction ){

		// Compute left interface state at the current Gauss
		// point location based on the low-order reconstruction.
		Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,Grid.BndEastSplineInfo[j].GQPoint(Position));
	      
		// Determine right interface state at the Gauss calculation point
		InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
								 ICu,j,
								 Ul,Ur,
								 Grid.BndEastSplineInfo[j].GQPoint(Position),
								 Grid.BndEastSplineInfo[j].NormalGQPoint(Position),
								 Pos);

		/* Add the weighted contribution of the current GQP to the total 
		   convective flux in the normal direction through the face. */
		Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur,
						       Grid.BndEastSplineInfo[j].GQPoint(Position),
						       Grid.BndEastSplineInfo[j].NormalGQPoint(Position));

	      } else {

		// Determine the solution state at the Gauss quadrature point for the calculation 
		// of the advective flux based on the constrained reconstruction.
		U_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

		/* Add the weighted contribution of the current GQP to the total 
		   convective flux through the spline segment in the local normal direction. */
		Flux += GaussQuadWeights[GQPoint] * Fa(U_face,
						       Grid.BndEastSplineInfo[j].GQPoint(Position), 
						       Grid.BndEastSplineInfo[j].NormalGQPoint(Position));
	      } // endif (IsNonSmoothHighOrderReconstruction)

	    } //endfor (GQPoint)
	
	    // Update FaceFlux with the contribution of this spline segment
	    FaceFlux += Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  // Update East face boundary flux with the contribution of the hyperbolic term
	  FluxE[j] += FaceFlux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FaceFlux/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FaceFlux/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Determine if the solution reconstruction was detected as non-smooth for the current cell.
	  IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICu,j);

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  // == Check if the solution reconstruction was detected as non-smooth.
	  if ( IsNonSmoothHighOrderReconstruction ){

	    // Calculate total flux through the cell face in the normal direction
	    for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);
	    
	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							       ICu,j,
							       Ul,Ur,
							       GaussQuadPoints[GQPoint],
							       Grid.nfaceE(ICu,j),
							       Pos);
	    
	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceE(ICu,j));
	    } //endfor (GQPoint)
	    
	  } else {

	    // Calculate total flux through the cell face in the normal direction
	    for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the advective flux based on the constrained reconstruction.
	      U_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);
	    
	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux through the face in the normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(U_face, GaussQuadPoints[GQPoint], Grid.nfaceE(ICu,j));
	    } //endfor (GQPoint)

	  } // endif
	
	  // Calculate final flux through the cell face
	  Flux *= Grid.lfaceE(ICu,j);

	  // Update East face boundary flux with the contribution of this cell face
	  FluxE[j] += Flux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* Flux/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( Flux/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)

      } // endif (Grid.BndEastSplineInfo != NULL)


    } else {

      /* Calculate the flux using an upwind method and ensure that
	 boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndEastSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Reset face flux
	  FaceFlux.Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left interface state at the current Gauss
	      // point location based on the reconstruction
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,
								  Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							       ICu,j,
							       Ul,Ur,
							       Grid.BndEastSplineInfo[j].GQPoint(Position),
							       Grid.BndEastSplineInfo[j].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur,
						     Grid.BndEastSplineInfo[j].GQPoint(Position), 
						     Grid.BndEastSplineInfo[j].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update FaceFlux with the contribution of this spline segment
	    FaceFlux += Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  // Update East face boundary flux with the contribution of the hyperbolic term
	  FluxE[j] += FaceFlux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FaceFlux/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FaceFlux/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							     ICu,j,
							     Ul,Ur,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceE(ICu,j),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       convective flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceE(ICu,j));
	  } //endfor (GQPoint)
	
	  // Calculate final flux through the cell face
	  Flux *= Grid.lfaceE(ICu,j);

	  // Update East face boundary flux with the contribution of this cell face
	  FluxE[j] += Flux;

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* Flux/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( Flux/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)
      
      } // endif (Grid.BndEastSplineInfo != NULL)
    
    } // endif (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 10. Compute convective fluxes through West block boundary ******
    // **************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure.
	 If the high-order reconstruction has been detected as non-smooth compute an upwind flux
	 with the value provided by the ghost cell reconstruction.
      */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndWestSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
     
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Determine if the solution reconstruction was detected as non-smooth for the current cell.
	  IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICl,j);

	  // Reset face flux
	  FaceFlux.Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // == Check if the solution reconstruction was detected as non-smooth.
	      if ( IsNonSmoothHighOrderReconstruction ){

		// Compute left interface state at the current Gauss
		// point location based on the low-order reconstruction.
		Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,Grid.BndWestSplineInfo[j].GQPoint(Position));
	      
		// Determine right interface state at the Gauss calculation point
		InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
								 ICl,j,
								 Ul,Ur,
								 Grid.BndWestSplineInfo[j].GQPoint(Position),
								 Grid.BndWestSplineInfo[j].NormalGQPoint(Position),
								 Pos);

		/* Add the weighted contribution of the current GQP to the total 
		   convective flux in the normal direction through the face. */
		Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur,
						       Grid.BndWestSplineInfo[j].GQPoint(Position),
						       Grid.BndWestSplineInfo[j].NormalGQPoint(Position));

	      } else {

		// Determine the solution state at the Gauss quadrature point for the calculation 
		// of the advective flux based on the constrained reconstruction.
		U_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

		/* Add the weighted contribution of the current GQP to the total 
		   convective flux through the spline segment in the local normal direction. */
		Flux += GaussQuadWeights[GQPoint] * Fa(U_face,
						       Grid.BndWestSplineInfo[j].GQPoint(Position), 
						       Grid.BndWestSplineInfo[j].NormalGQPoint(Position));
	      } // endif (IsNonSmoothHighOrderReconstruction)

	    } //endfor (GQPoint)
	
	    // Update FaceFlux with the contribution of this spline segment
	    FaceFlux += Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  // Update West face boundary flux with the contribution of the hyperbolic term
	  FluxW[j] += FaceFlux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FaceFlux/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FaceFlux/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Determine if the solution reconstruction was detected as non-smooth for the current cell.
	  IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICl,j);

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  // == Check if the solution reconstruction was detected as non-smooth.
	  if ( IsNonSmoothHighOrderReconstruction ){

	    // Calculate total flux through the cell face in the normal direction
	    for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);
	    
	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							       ICl,j,
							       Ul,Ur,
							       GaussQuadPoints[GQPoint],
							       Grid.nfaceW(ICl,j),
							       Pos);
	    
	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceW(ICl,j));
	    } //endfor (GQPoint)
	    
	  } else {

	    // Calculate total flux through the cell face in the normal direction
	    for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the advective flux based on the constrained reconstruction.
	      U_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);
	    
	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux through the face in the normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(U_face, GaussQuadPoints[GQPoint], Grid.nfaceW(ICl,j));
	    } //endfor (GQPoint)

	  } // endif
	
	  // Calculate final flux through the cell face
	  Flux *= Grid.lfaceW(ICl,j);

	  // Update West face boundary flux with the contribution of this cell face
	  FluxW[j] += Flux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* Flux/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( Flux/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)

      } // endif (Grid.BndWestSplineInfo != NULL)


    } else {

      /* Calculate the flux using an upwind method and ensure that
	 boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndWestSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Reset face flux
	  FaceFlux.Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left interface state at the current Gauss
	      // point location based on the reconstruction
	      Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,
								  Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							       ICl,j,
							       Ul,Ur,
							       Grid.BndWestSplineInfo[j].GQPoint(Position),
							       Grid.BndWestSplineInfo[j].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 convective flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur,
						     Grid.BndWestSplineInfo[j].GQPoint(Position), 
						     Grid.BndWestSplineInfo[j].NormalGQPoint(Position));
	    } //endfor (GQPoint)
	
	    // Update FaceFlux with the contribution of this spline segment
	    FaceFlux += Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  // Update West face boundary flux with the contribution of the hyperbolic term
	  FluxW[j] += FaceFlux;

	  /* Evaluate cell-averaged solution changes due to convective flux. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FaceFlux/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FaceFlux/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the high-order reconstruction
	    Ul = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							     ICl,j,
							     Ul,Ur,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceW(ICl,j),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       convective flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fa(Ul, Ur, GaussQuadPoints[GQPoint], Grid.nfaceW(ICl,j));
	  } //endfor (GQPoint)
	
	  // Calculate final flux through the cell face
	  Flux *= Grid.lfaceW(ICl,j);

	  // Update West face boundary flux with the contribution of this cell face
	  FluxW[j] += Flux;

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* Flux/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( Flux/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)
      
      } // endif (Grid.BndWestSplineInfo != NULL)
    
    } // endif (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux)

  } // endif (Include_Advection_Term)

  // Deallocate memory
  delete [] GaussQuadPoints;
  delete [] GaussQuadWeights;

  /* residual for the stage successfully calculated. */
  return (0);

}

/*!
 * Evaluate the residual for the solution block 
 * using the high-order CENO upwind finite-volume 
 * spatial discretization scheme for the  
 * convective flux coupled with a centrally-weighted    
 * high-order finite-volume discretization for the diffusive flux.  
 * The residual is stored in dUdt[][][0].               
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *                                                      
 */
int AdvectDiffuse2D_Quad_Block::dUdt_Residual_Evaluation_HighOrder(const AdvectDiffuse2D_Input_Parameters &IP,
								   const unsigned short int Pos){

  int i,j;
  
  // ************* Step 1. (Re)-Set residual for k_residual=0 to zero in all affected cells **************
  // *****************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ) {
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {
      dUdt[i][j][0].Vacuum();  // set to zero
    } // endfor (i)
  } // endfor (j)

  // ** Step 2. Compute high-order spatial residual and write it to k_residual = 0 **
  // ********************************************************************************
  return dUdt_Residual_HighOrder(IP, 0, false, Pos);
}


/*!
 * This routine determines the solution residuals for a 
 * given stage of a variety of multi-stage explicit     
 * time integration schemes for the solution block.
 * The solution residuals are evaluated  
 * using the high-order CENO upwind finite-volume 
 * spatial discretization scheme for the convective 
 * flux coupled with a centrally-weighted high-order 
 * finite-volume discretization for the diffusive flux.
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *
 */
int AdvectDiffuse2D_Quad_Block::dUdt_Multistage_Explicit_HighOrder(const int &i_stage,
								   const AdvectDiffuse2D_Input_Parameters &IP,
								   const unsigned short int Pos) {
  // SET VARIABLES USED IN THE RESIDUAL CALCULATION PROCESS

  int i, j, k_residual;

  /* Evaluate the solution residual for stage 
     i_stage of an N stage scheme. */

  /* Evaluate the time step fraction and residual storage location for the stage. */
  
  switch(IP.i_Time_Integration) {
  case TIME_STEPPING_EXPLICIT_EULER :
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
    k_residual = 0;
    if (IP.N_Stage == 4) {
      if (i_stage == 4) {
	k_residual = 0;
      } else {
	k_residual = i_stage - 1;
      } /* endif */
    } /* endif */
    break;
  case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
    k_residual = 0;
    break;
  default:
    k_residual = 0;
  } /* endswitch */


  // ************* Step 1. (Re)-Set parameters in all affected cells based on the time integration scheme **************
  // *******************************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ){
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {

      if ( i_stage == 1 ){
	Uo[i][j] = U[i][j];
	dUdt[i][j][k_residual].Vacuum();  // set to zero
      } else {
	switch(IP.i_Time_Integration) {
	case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
	  // 
	  break;
	case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
	  if (IP.N_Stage == 2) {
	    // 
	  } else if (IP.N_Stage == 4 && i_stage == 4) {
	    dUdt[i][j][k_residual] = ( dUdt[i][j][0] + 
				       TWO*dUdt[i][j][1] +
				       TWO*dUdt[i][j][2] );
	  } else {
	    dUdt[i][j][k_residual].Vacuum();  // set to zero
	  } /* endif */
	  break;
	case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	default:
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	} /* endswitch */
      }/* endif */

    } // endfor (i)
  } // endfor (j)


  // ** Step 2. Compute high-order spatial residual for the current time step fraction **
  // ************************************************************************************
  return dUdt_Residual_HighOrder(IP, k_residual, true, Pos);
}

/*!
 * Compute the solution state used to evaluate the 
 * the diffusion coefficient for the elliptic-flux and
 * the solution gradient at a boundary interface
 * for a variety of boundary conditions.
 * This routine works in conjunction with the high-order
 * implementation.
 * 
 * \param [in]  BOUNDARY boundary position specifier (i.e. WEST, EAST, SOUTH or NORTH)
 * \param [in]  ii       i-index of the cell in which the calculation is done
 * \param [in]  jj       j-index of the cell in which the calculation is done
 * \param [in]  Ul       the left interface state obtained with the high-order interpolant
 * \param [in]  Ur       the right interface state obtained with the high-order interpolant
 * \param [out] U_face   the interface state
 * \param [in]  GradUl   the left interface gradient obtained with the high-order interpolant
 * \param [in]  GradUr   the right interface gradient obtained with the high-order interpolant
 * \param [out] GradU_face solution gradient at the interface
 * \param [in]  CalculationPoint the flux calculation point
 * \param [in]  NormalDirection  the unit normal vector at the flux calculation point
 *
 * \return The solution state and the solution gradient that are used to calculate the elliptic flux.
 *
 * \todo Revisit this routine. Change the BC function calls to boundary reference states.
 */
void AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder(const int &BOUNDARY,
										 const int &ii, const int &jj,
										 const AdvectDiffuse2D_State &Ul,
										 const AdvectDiffuse2D_State &Ur,
										 AdvectDiffuse2D_State &U_face,
										 const Vector2D &GradUl,
										 const Vector2D &GradUr,
										 Vector2D &GradU_face,
										 const Vector2D &CalculationPoint,
										 const Vector2D &NormalDirection) const{

  double Vn;
  AdvectDiffuse2D_State Value;

  switch(BOUNDARY){

    // *******************************
    // === WEST boundary interface ===
    // *******************************
  case WEST :			
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeW[jj]){

    case BC_NONE :
      // Calculate U_face in the same way as for an interior interface
      U_face = 0.5*(Ul + Ur);
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;

    case BC_PERIODIC :
      // Calculate U_face in the same way as for an interior interface
      U_face = 0.5*(Ul + Ur);
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;

    case BC_FROZEN :
      // Calculate U_face based on the unlimited reconstruction in the ghost cell
      U_face = Ur;
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;
      
    case BC_INFLOW :
      // Calculate U_face based on the inflow field
      if (Inflow->IsInflowFieldSet()){
	U_face = Inflow->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no inflow field set for the Inflow BC.");
      }
      // Set GradU_face to the interior value (i.e. left unlimited reconstruction)
      GradU_face = GradUl;
     break;

    case BC_DIRICHLET :
      // Assume that this boundary has a constant value for all flux calculation points along a cell face
      U_face = UoW[jj];
      // Set GradU_face to the interior value (i.e. left unlimited reconstruction)
      GradU_face = GradUl;
      break;

    case BC_EXACT_SOLUTION :
      // Calculate U_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	U_face = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;
      
    case BC_NEUMANN :
      // Calculate U_face based on the interior value (i.e. left unlimited reconstruction)
      U_face = Ul;
      // Assume that this boundary has a constant gradient for all flux calculation points along a cell face
      // Set GradU_face to the value imposed by the user
      GradU_face = UoW[jj].u*NormalDirection;
      break;

    case BC_SYMMETRY_PLANE :
      break;

    case BC_EXTRAPOLATE :
      break;

    case BC_LINEAR_EXTRAPOLATION :
      break;

    case BC_OUTFLOW :
      // Calculate U_face based on the interior value (i.e. left unlimited reconstruction)
      U_face = Ul;
      // Set GradU_face to ZERO
      GradU_face = 0.0;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      break;
      
    case BC_FARFIELD :
      /* Farfield BC is implemented differently for flows that 
	 enter the domain than for flows that leave the domain.
	 Whether the flow enters or leaves the domain is decided based on
	 the normal component of the velocity at the face midpoint.
	 --> If the flow enters the domain then the reference data is used.
	 --> If the flow leaves the domain then the interior value is used. */

      // Compute the normal velocity
      Vn = dot(VelocityAtLocation(CalculationPoint),
	       NormalDirection);
	  
      if (Vn <= ZERO){
	// The flow enters the domain
	// Use the boundary condition value which is assumed to be constant for all flux calculation points along a cell face
	// Set U_face to the value imposed by the user
	U_face = UoW[jj];
	// Calculate GradU_face based on the interior reconstruction
	GradU_face = GradUl;

      } else {
	// The flow leaves the domain
	// Use the interior domain value
	// Calculate U_face based on the interior reconstruction
	U_face = Ul;
	// Calculate GradU_face in the same way as for an interior interface
	GradU_face = 0.5*(GradUl + GradUr);
      }
      break;

    default:
      throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such West BCtype!");
    }// endswitch (Grid.BCtypeW[jj])
    break;


    // *******************************
    // === EAST boundary interface ===
    // *******************************
  case EAST :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeE[jj]){

    case BC_NONE :
      // Calculate U_face in the same way as for an interior interface
      U_face = 0.5*(Ul + Ur);
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;

    case BC_PERIODIC :
      // Calculate U_face in the same way as for an interior interface
      U_face = 0.5*(Ul + Ur);
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;

    case BC_FROZEN :
      // Calculate U_face based on the unlimited reconstruction in the ghost cell
      U_face = Ur;
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;
      
    case BC_INFLOW :
      // Calculate U_face based on the inflow field
      if (Inflow->IsInflowFieldSet()){
	U_face = Inflow->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no inflow field set for the Inflow BC.");
      }
      // Set GradU_face to the interior value (i.e. left unlimited reconstruction)
      GradU_face = GradUl;
      break;

    case BC_DIRICHLET :
      // Assume that this boundary has a constant value for all flux calculation points along a cell face
      U_face = UoE[jj];
      // Set GradU_face to the interior value (i.e. left unlimited reconstruction)
      GradU_face = GradUl;
      break;

    case BC_EXACT_SOLUTION :
      // Calculate U_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	U_face = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;
      
    case BC_NEUMANN : 
      // Calculate U_face based on the interior value (i.e. left unlimited reconstruction)
      U_face = Ul;
      // Assume that this boundary has a constant gradient for all flux calculation points along a cell face
      // Set GradU_face to the value imposed by the user
      GradU_face = UoE[jj].u*NormalDirection;
      break;

    case BC_SYMMETRY_PLANE :
      break;

    case BC_EXTRAPOLATE :
      break;

    case BC_LINEAR_EXTRAPOLATION :
      break;

    case BC_OUTFLOW :
      // Calculate U_face based on the interior value (i.e. left unlimited reconstruction)
      U_face = Ul;
      // Set GradU_face to ZERO
      GradU_face = 0.0;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      break;
      
    case BC_FARFIELD :
      /* Farfield BC is implemented differently for flows that 
	 enter the domain than for flows that leave the domain.
	 Whether the flow enters or leaves the domain is decided based on
	 the normal component of the velocity at the face midpoint.
	 --> If the flow enters the domain then the reference data is used.
	 --> If the flow leaves the domain then the interior value is used. */

      // Compute the normal velocity
      Vn = dot(VelocityAtLocation(CalculationPoint),
	       NormalDirection);
	  
      if (Vn <= ZERO){
	// The flow enters the domain
	// Use the boundary condition value which is assumed to be constant for all flux calculation points along a cell face
	// Set U_face to the value imposed by the user
	U_face = UoE[jj];
	// Calculate GradU_face based on the interior reconstruction
	GradU_face = GradUl;

      } else {
	// The flow leaves the domain
	// Use the interior domain value
	// Calculate U_face based on the interior reconstruction
	U_face = Ul;
	// Calculate GradU_face in the same way as for an interior interface
	GradU_face = 0.5*(GradUl + GradUr);
      }
      break;

    default:
      throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such East BCtype!");
    }// endswitch (Grid.BCtypeE[jj])
    break;

    // ********************************
    // === SOUTH boundary interface ===
    // ********************************
  case SOUTH :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeS[ii]){

    case BC_NONE :
      // Calculate U_face in the same way as for an interior interface
      U_face = 0.5*(Ul + Ur);
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;

    case BC_PERIODIC :
      // Calculate U_face in the same way as for an interior interface
      U_face = 0.5*(Ul + Ur);
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;

    case BC_FROZEN :
      // Calculate U_face based on the unlimited reconstruction in the ghost cell
      U_face = Ur;
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;
      
    case BC_INFLOW :
      // Calculate U_face based on the inflow field
      if (Inflow->IsInflowFieldSet()){
	U_face = Inflow->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no inflow field set for the Inflow BC.");
      }
      // Set GradU_face to the interior value (i.e. left unlimited reconstruction)
      GradU_face = GradUl;
      break;

    case BC_DIRICHLET :
      // Assume that this boundary has a constant value for all flux calculation points along a cell face
      U_face = UoS[ii];
      // Set GradU_face to the interior value (i.e. left unlimited reconstruction)
      GradU_face = GradUl;
      break;

    case BC_EXACT_SOLUTION :
      // Calculate U_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	U_face = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;
      
    case BC_NEUMANN : 
      // Calculate U_face based on the interior value (i.e. left unlimited reconstruction)
      U_face = Ul;
      // Assume that this boundary has a constant gradient for all flux calculation points along a cell face
      // Set GradU_face to the value imposed by the user
      GradU_face = UoS[ii].u*NormalDirection;
      break;

    case BC_SYMMETRY_PLANE :
      break;

    case BC_EXTRAPOLATE :
      break;

    case BC_LINEAR_EXTRAPOLATION :
      break;

    case BC_OUTFLOW :
      // Calculate U_face based on the interior value (i.e. left unlimited reconstruction)
      U_face = Ul;
      // Set GradU_face to ZERO
      GradU_face = 0.0;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      break;
      
    case BC_FARFIELD :
      /* Farfield BC is implemented differently for flows that 
	 enter the domain than for flows that leave the domain.
	 Whether the flow enters or leaves the domain is decided based on
	 the normal component of the velocity at the face midpoint.
	 --> If the flow enters the domain then the reference data is used.
	 --> If the flow leaves the domain then the interior value is used. */

      // Compute the normal velocity
      Vn = dot(VelocityAtLocation(CalculationPoint),
	       NormalDirection);
	  
      if (Vn <= ZERO){
	// The flow enters the domain
	// Use the boundary condition value which is assumed to be constant for all flux calculation points along a cell face
	// Set U_face to the value imposed by the user
	U_face = UoS[ii];
	// Calculate GradU_face based on the interior reconstruction
	GradU_face = GradUl;

      } else {
	// The flow leaves the domain
	// Use the interior domain value
	// Calculate U_face based on the interior reconstruction
	U_face = Ul;
	// Calculate GradU_face in the same way as for an interior interface
	GradU_face = 0.5*(GradUl + GradUr);
      }
      break;

    default:
      throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such South BCtype!");
    }// endswitch (Grid.BCtypeS[ii])
    break;

    // ********************************
    // === NORTH boundary interface ===
    // ********************************
  case NORTH :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeN[ii]){

    case BC_NONE :
      // Calculate U_face in the same way as for an interior interface
      U_face = 0.5*(Ul + Ur);
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;

    case BC_PERIODIC :
      // Calculate U_face in the same way as for an interior interface
      U_face = 0.5*(Ul + Ur);
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;

    case BC_FROZEN :
      // Calculate U_face based on the unlimited reconstruction in the ghost cell
      U_face = Ur;
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;
      
    case BC_INFLOW :
      // Calculate U_face based on the inflow field
      if (Inflow->IsInflowFieldSet()){
	U_face = Inflow->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no inflow field set for the Inflow BC.");
      }
      // Set GradU_face to the interior value (i.e. left unlimited reconstruction)
      GradU_face = GradUl;
      break;

    case BC_DIRICHLET :
      // Assume that this boundary has a constant value for all flux calculation points along a cell face
      U_face = UoN[ii];
      // Set GradU_face to the interior value (i.e. left unlimited reconstruction)
      GradU_face = GradUl;
      break;

    case BC_EXACT_SOLUTION :
      // Calculate U_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	U_face = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      // Calculate GradU_face in the same way as for an interior interface
      GradU_face = 0.5*(GradUl + GradUr);
      break;
      
    case BC_NEUMANN : 
      // Calculate U_face based on the interior value (i.e. left unlimited reconstruction)
      U_face = Ul;
      // Assume that this boundary has a constant gradient for all flux calculation points along a cell face
      // Set GradU_face to the value imposed by the user
      GradU_face = UoN[ii].u*NormalDirection;
      break;

    case BC_SYMMETRY_PLANE :
      break;

    case BC_EXTRAPOLATE :
      break;

    case BC_LINEAR_EXTRAPOLATION :
      break;

    case BC_OUTFLOW :
      // Calculate U_face based on the interior value (i.e. left unlimited reconstruction)
      U_face = Ul;
      // Set GradU_face to ZERO
      GradU_face = 0.0;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      break;
      
    case BC_FARFIELD :
      /* Farfield BC is implemented differently for flows that 
	 enter the domain than for flows that leave the domain.
	 Whether the flow enters or leaves the domain is decided based on
	 the normal component of the velocity at the face midpoint.
	 --> If the flow enters the domain then the reference data is used.
	 --> If the flow leaves the domain then the interior value is used. */

      // Compute the normal velocity
      Vn = dot(VelocityAtLocation(CalculationPoint),
	       NormalDirection);
	  
      if (Vn <= ZERO){
	// The flow enters the domain
	// Use the boundary condition value which is assumed to be constant for all flux calculation points along a cell face
	// Set U_face to the value imposed by the user
	U_face = UoN[ii];
	// Calculate GradU_face based on the interior reconstruction
	GradU_face = GradUl;

      } else {
	// The flow leaves the domain
	// Use the interior domain value
	// Calculate U_face based on the interior reconstruction
	U_face = Ul;
	// Calculate GradU_face in the same way as for an interior interface
	GradU_face = 0.5*(GradUl + GradUr);
      }
      break;

    default:
      throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such North BCtype!");
    }// endswitch (Grid.BCtypeN[ii])
    break;

  default:
    throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such boundary!");
  }

}

/*!
 * Compute the solution state for evaluating the inviscid flux 
 * at a boundary interface such that to satisfy the 
 * required boundary conditions.
 * This routine works in conjunction with the high-order
 * implementation.
 * 
 * \param  BOUNDARY boundary position specifier (i.e. WEST, EAST, SOUTH or NORTH)
 * \param  ii       i-index of the cell in which the calculation is done
 * \param  jj       j-index of the cell in which the calculation is done
 * \param  Ul       the left interface state 
 * \param  Ur       the right interface state 
 * \param CalculationPoint the flux calculation point
 *
 * \return The solution state required to calculate the convective flux with such that to satisfy the boundary conditions.
 */
void AdvectDiffuse2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder(const int &BOUNDARY,
										  const int &ii, const int &jj,
										  AdvectDiffuse2D_State &Ul,
										  AdvectDiffuse2D_State &Ur,
										  const Vector2D &CalculationPoint,
										  const Vector2D &NormalDirection,
										  const unsigned short int Pos) const{

  double Vn;
  AdvectDiffuse2D_State Value;

  switch(BOUNDARY){

    // *******************************
    // === WEST boundary interface ===
    // *******************************
  case WEST :			
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeW[jj]){

    case BC_NONE :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;

    case BC_FROZEN :
      // Calculate Ur based on the reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;
      
    case BC_INFLOW :
      // Calculate Ur based on the inflow field
      if (Inflow->IsInflowFieldSet()){
	Ur = Inflow->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no inflow field set for the Inflow BC.");
      }
      break;

    case BC_DIRICHLET :
      // Assume that this boundary has a constant value for all flux calculation points along a cell face
      Ur = Ul = UoW[jj];
      break;

    case BC_EXACT_SOLUTION :
      // Calculate U_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Ur = Ul = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_SYMMETRY_PLANE :
      break;

    case BC_EXTRAPOLATE :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      break;

    case BC_OUTFLOW :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;
      
    case BC_FARFIELD :
      /* Farfield BC is implemented differently for flows that 
	 enter the domain than for flows that leave the domain.
	 Whether the flow enters or leaves the domain is decided based on
	 the normal component of the velocity at the face midpoint.
	 --> If the flow enters the domain then the reference data is used.
	 --> If the flow leaves the domain then the interior value is used. */

      // Compute the normal velocity
      Vn = dot(VelocityAtLocation(CalculationPoint),
	       NormalDirection);
	  
      if (Vn <= ZERO){
	// The flow enters the domain
	// Use the boundary condition value which is assumed to be constant for all flux calculation points along a cell face
	// Set Ur to the value imposed by the user
	Ur = UoW[jj];

      } else {
	// The flow leaves the domain
	// Use the interior domain value
	// Set Ur to the value of the interior reconstruction
	Ur = Ul;
      }
      break;

    default:
      throw runtime_error("AdvectDiffuse2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such West BCtype!");
    }// endswitch (Grid.BCtypeW[jj])
    break;


    // *******************************
    // === EAST boundary interface ===
    // *******************************
  case EAST :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeE[jj]){

    case BC_NONE :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;
      
    case BC_INFLOW :
      // Calculate Ur based on the inflow field
      if (Inflow->IsInflowFieldSet()){
	Ur = Inflow->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no inflow field set for the Inflow BC.");
      }
      break;

    case BC_DIRICHLET :
      // Assume that this boundary has a constant value for all flux calculation points along a cell face
      Ur = Ul = UoE[jj];
      break;

    case BC_EXACT_SOLUTION :
      // Calculate U_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Ur = Ul = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_SYMMETRY_PLANE :
      break;

    case BC_EXTRAPOLATE :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      break;

    case BC_OUTFLOW :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;
      
    case BC_FARFIELD :
      /* Farfield BC is implemented differently for flows that 
	 enter the domain than for flows that leave the domain.
	 Whether the flow enters or leaves the domain is decided based on
	 the normal component of the velocity at the face midpoint.
	 --> If the flow enters the domain then the reference data is used.
	 --> If the flow leaves the domain then the interior value is used. */

      // Compute the normal velocity
      Vn = dot(VelocityAtLocation(CalculationPoint),
	       NormalDirection);
	  
      if (Vn <= ZERO){
	// The flow enters the domain
	// Use the boundary condition value which is assumed to be constant for all flux calculation points along a cell face
	// Set Ur to the value imposed by the user
	Ur = UoE[jj];

      } else {
	// The flow leaves the domain
	// Use the interior domain value
	// Set Ur to the value of the interior reconstruction
	Ur = Ul;
      }
      break;

    default:
      throw runtime_error("AdvectDiffuse2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such East BCtype!");
    }// endswitch (Grid.BCtypeE[jj])
    break;

    // ********************************
    // === SOUTH boundary interface ===
    // ********************************
  case SOUTH :
    // Compute left interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeS[ii]){

    case BC_NONE :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;
      
    case BC_INFLOW :
      // Calculate Ur based on the inflow field
      if (Inflow->IsInflowFieldSet()){
	Ur = Inflow->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no inflow field set for the Inflow BC.");
      }
      break;

    case BC_DIRICHLET :
      // Assume that this boundary has a constant value for all flux calculation points along a cell face
      Ur = Ul = UoS[ii];
      break;

    case BC_EXACT_SOLUTION :
      // Calculate U_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Ur = Ul = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_SYMMETRY_PLANE :
      break;

    case BC_EXTRAPOLATE :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      break;

    case BC_OUTFLOW :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;
      
    case BC_FARFIELD :
      /* Farfield BC is implemented differently for flows that 
	 enter the domain than for flows that leave the domain.
	 Whether the flow enters or leaves the domain is decided based on
	 the normal component of the velocity at the face midpoint.
	 --> If the flow enters the domain then the reference data is used.
	 --> If the flow leaves the domain then the interior value is used. */

      // Compute the normal velocity
      Vn = dot(VelocityAtLocation(CalculationPoint),
	       NormalDirection);
	  
      if (Vn <= ZERO){
	// The flow enters the domain
	// Use the boundary condition value which is assumed to be constant for all flux calculation points along a cell face
	// Set Ur to the value imposed by the user
	Ur = UoS[ii];

      } else {
	// The flow leaves the domain
	// Use the interior domain value
	// Set Ur to the value of the interior reconstruction
	Ur = Ul;
      }
      break;

    default:
      throw runtime_error("AdvectDiffuse2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such South BCtype!");
    }// endswitch (Grid.BCtypeS[ii])
    break;

    // ********************************
    // === NORTH boundary interface ===
    // ********************************
  case NORTH :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeN[ii]){

    case BC_NONE :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Ur based on the high-order reconstruction in the ghost cell
      Ur = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;
      
    case BC_INFLOW :
      // Calculate Ur based on the inflow field
      if (Inflow->IsInflowFieldSet()){
	Ur = Inflow->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no inflow field set for the Inflow BC.");
      }
      break;

    case BC_DIRICHLET :
      // Assume that this boundary has a constant value for all flux calculation points along a cell face
      Ur = Ul = UoN[ii];
      break;

    case BC_EXACT_SOLUTION :
      // Calculate U_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Ur = Ul = ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_SYMMETRY_PLANE :
      break;

    case BC_EXTRAPOLATE :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      break;

    case BC_OUTFLOW :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Ur equal to the left side value (i.e Ul)
      Ur = Ul;
      break;
      
    case BC_FARFIELD :
      /* Farfield BC is implemented differently for flows that 
	 enter the domain than for flows that leave the domain.
	 Whether the flow enters or leaves the domain is decided based on
	 the normal component of the velocity at the face midpoint.
	 --> If the flow enters the domain then the reference data is used.
	 --> If the flow leaves the domain then the interior value is used. */

      // Compute the normal velocity
      Vn = dot(VelocityAtLocation(CalculationPoint),
	       NormalDirection);
	  
      if (Vn <= ZERO){
	// The flow enters the domain
	// Use the boundary condition value which is assumed to be constant for all flux calculation points along a cell face
	// Set Ur to the value imposed by the user
	Ur = UoN[ii];

      } else {
	// The flow leaves the domain
	// Use the interior domain value
	// Set Ur to the value of the interior reconstruction
	Ur = Ul;
      }
      break;

    default:
      throw runtime_error("AdvectDiffuse2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such North BCtype!");
    }// endswitch (Grid.BCtypeN[ii])
    break;

  default:
    throw runtime_error("AdvectDiffuse2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such boundary!");
  }

}

/*!
 * Determine the cells that influence the high-order 
 * finite-volume discretization of the Laplace operator.
 * In a given cell, this operator is computed based on
 * the gradients at the given cell faces. These gradients
 * are determined from the reconstructions of the given cell
 * and its first degree neighbours. 
 * Therefore, the influence domain is formed by all cells
 * that are part of the reconstruction stencils of these 
 * directly involved cells.
 *
 * \param iCell the i-index of the given cell
 * \param jCell the j-index of the given cell
 * \param Pos the high-order variable index that is used to determine the influence domain.
 *
 * \note The indexes are written in the i_index and j_index class variables.
 */
void AdvectDiffuse2D_Quad_Block::Set_HighOrder_InfluenceDomain_For_LaplacianOperator(const int &iCell, const int &jCell,
										     const unsigned short int Pos){

  // Determine the enlarged supporting reconstruction stencil for cell (iCell,jCell). 
  HighOrderVariable(Pos).getEnlargedReconstructionStencil(iCell, jCell, i_index, j_index);
}

/*!
 * Output the influence domain.
 */
void AdvectDiffuse2D_Quad_Block::Output_HighOrder_InfluenceDomain_For_LaplacianOperator(ostream &os){

  // Output stencil size
  os << "Stencil Size = " << i_index.size() << "\n";

  // Output indexes
  for (int n = 0; n < i_index.size(); ++n){
    os << "i = " << i_index[n] << "\t j = " << j_index[n] << "\n";
  }
}

/*!
 * Calculate the high-order finite-volume discretization of the
 * Laplace operator for a given cell and a high-order object.
 *
 * \param k_residual index to identify the residual storage location
 */
void AdvectDiffuse2D_Quad_Block::Calculate_HighOrder_Discretization_LaplacianOperator(const int &iCell, const int &jCell,
										      const int & k_residual,
										      const unsigned short int Pos){

  // SET VARIABLES USED IN THE RESIDUAL CALCULATION PROCESS

  int  GQPoint, Position, SplineSegment;
  AdvectDiffuse2D_State U_face(1.0), Flux, FaceFlux;
  Vector2D GradU_face, GradUl, GradUr;		// Solution gradient at the inter-cellular face
  int NumGQP(Grid.getNumGQP());	  // Number of Gauss quadrature points per face used to compute the flux integral

  Vector2D *GaussQuadPoints = new Vector2D [NumGQP]; // the GQPs at which a Riemann-like problem is solved
  double * GaussQuadWeights = new double [NumGQP];   // the Gauss integration weights for each Gauss quadrature

  /* Set the GaussQuadWeights. */
  GaussQuadratureData::getGaussQuadWeights(GaussQuadWeights, NumGQP);


  /* Set the diffusion field to Constant_Diffusion. */
  // Change temporary the diffusion field to Laplacian
  DiffusionFields::Change_Temporary_Diffusion_Field_To_Laplacian();
  // Reset solution class pointer to the new diffusion field
  DiffusionFields::Connect_Pointer_To_Diffusion_Field(AdvectDiffuse2D_State::k);


  /* Evaluate the Laplacian and write it to dUdt[iCell][jCell][k_residual]. */
  dUdt[iCell][jCell][k_residual].Vacuum();

  /* Perform the unlimited high-order reconstructions for all 5 cells involved in the calculation. */
  HighOrderVariable(Pos).ComputeUnlimitedSolutionReconstruction(*this,
								iCell  ,jCell  );
  HighOrderVariable(Pos).ComputeUnlimitedSolutionReconstruction(*this,
								iCell-1,jCell  );
  HighOrderVariable(Pos).ComputeUnlimitedSolutionReconstruction(*this,
								iCell+1,jCell  );
  HighOrderVariable(Pos).ComputeUnlimitedSolutionReconstruction(*this,
								iCell  ,jCell-1);
  HighOrderVariable(Pos).ComputeUnlimitedSolutionReconstruction(*this,
								iCell  ,jCell+1);

  
  // ****** Step 1. Compute contribution from the North face to Laplacian *******
  // ****************************************************************************

  // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
  if ( jCell == JCu && Grid.BndNorthSplineInfo != NULL){
    /* High-order boundary representation is required.
       Use all geometric information from the correspondent BndSplineInfo */
      
    // Reset FaceFlux
    FaceFlux.Vacuum();

    for (SplineSegment = 1, Position = 1; 
	 SplineSegment <= Grid.BndNorthSplineInfo[iCell].NumOfSubIntervals();
	 ++SplineSegment){  // for each continuous spline subinterval
	
      // Reset Flux
      Flux.Vacuum();
	
      // Calculate total flux through the spline subinterval
      for (GQPoint = 0;
	   GQPoint < Grid.BndNorthSplineInfo[iCell].GQPointsPerSubInterval();
	   ++GQPoint, ++Position){  // for each Gauss Quadrature point
	  
	// == Check the flux calculation method ==
	if (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){

	  // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	  GradU_face = Vector2D(HighOrderVariable(Pos).
				XGradientStateAtLocation(iCell,jCell,
							 Grid.BndNorthSplineInfo[iCell].GQPoint(Position))[1],
				HighOrderVariable(Pos).
				YGradientStateAtLocation(iCell,jCell,
							 Grid.BndNorthSplineInfo[iCell].GQPoint(Position))[1]);
	} else {

	  // Compute left and right interface gradients at the current Gauss
	  // point location based on the unlimited high-order reconstruction
	  GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,
									    Grid.BndNorthSplineInfo[iCell].GQPoint(Position))[1],
			    HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,
									    Grid.BndNorthSplineInfo[iCell].GQPoint(Position))[1]);
	  GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell+1,
									    Grid.BndNorthSplineInfo[iCell].GQPoint(Position))[1] ,
			    HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell+1,
									    Grid.BndNorthSplineInfo[iCell].GQPoint(Position))[1]);
	  
	  // Compute interface gradient
	  GradU_face = 0.5*(GradUl + GradUr); 
	}
	  
	/* Add the weighted contribution of the current GQP to the total 
	   diffusive flux through the spline segment in the local normal direction. */
	Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
					       Grid.BndNorthSplineInfo[iCell].GQPoint(Position), 
					       Grid.BndNorthSplineInfo[iCell].NormalGQPoint(Position));
      } //endfor (GQPoint)
	
      // Update North face boundary flux with the contribution of this spline segment
      FaceFlux += Flux * Grid.BndNorthSplineInfo[iCell].IntLength(SplineSegment);

    } // endfor (SplineSegment)

    /* Evaluate face contribution to Laplacian. */
    dUdt[iCell][jCell][k_residual] -= FaceFlux/Grid.Cell[iCell][jCell].A;

  } else {
    /* Low-order boundary representation is required.
       Treat the cell faces as straight edges. */

    // Determine the location of the Gauss Quadrature Points
    Grid.getGaussQuadPointsFaceN(iCell,jCell,GaussQuadPoints,NumGQP);
    
    // Reset FaceFlux
    FaceFlux.Vacuum();

    // Calculate total flux through the cell face in the normal direction
    for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

      // == Check the flux calculation method for North block boundary ==
      if ( jCell == JCu && Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){

	// Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1],
			      HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1]);

      } else {

	// Compute left and right interface gradients at the current Gauss
	// point location based on the unlimited high-order reconstruction
	GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1],
			  HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1]);
	GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell+1,GaussQuadPoints[GQPoint])[1] ,
			  HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell+1,GaussQuadPoints[GQPoint])[1]);

	// Compute interface gradient
	GradU_face = 0.5*(GradUl + GradUr);
      }

      /* Add the weighted contribution of the current GQP to the total 
	 diffusive flux through the face in the normal direction. */
      FaceFlux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceN(iCell,jCell));

    } //endfor (GQPoint)
	
    /* Evaluate face contribution to Laplacian. */
    dUdt[iCell][jCell][k_residual] -= FaceFlux*Grid.lfaceN(iCell,jCell)/Grid.Cell[iCell][jCell].A;
    
  } // endif (jCell == JCu && Grid.BndNorthSplineInfo != NULL)


  // ****** Step 2. Compute contribution from the South face to Laplacian *******
  // ****************************************************************************
  // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
  if ( jCell == JCl && Grid.BndSouthSplineInfo != NULL){
    /* High-order boundary representation is required.
       Use all geometric information from the correspondent BndSplineInfo */
      
    // Reset FaceFlux
    FaceFlux.Vacuum();

    for (SplineSegment = 1, Position = 1; 
	 SplineSegment <= Grid.BndSouthSplineInfo[iCell].NumOfSubIntervals();
	 ++SplineSegment){  // for each continuous spline subinterval
	
      // Reset Flux
      Flux.Vacuum();
	
      // Calculate total flux through the spline subinterval
      for (GQPoint = 0;
	   GQPoint < Grid.BndSouthSplineInfo[iCell].GQPointsPerSubInterval();
	   ++GQPoint, ++Position){  // for each Gauss Quadrature point
	  
	// == Check the flux calculation method ==
	if (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){

	  // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	  GradU_face = Vector2D(HighOrderVariable(Pos).
				XGradientStateAtLocation(iCell,jCell,
							 Grid.BndSouthSplineInfo[iCell].GQPoint(Position))[1],
				HighOrderVariable(Pos).
				YGradientStateAtLocation(iCell,jCell,
							 Grid.BndSouthSplineInfo[iCell].GQPoint(Position))[1]);
	} else {

	  // Compute left and right interface gradients at the current Gauss
	  // point location based on the unlimited high-order reconstruction
	  GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,
									    Grid.BndSouthSplineInfo[iCell].GQPoint(Position))[1],
			    HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,
									    Grid.BndSouthSplineInfo[iCell].GQPoint(Position))[1]);
	  GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell-1,
									    Grid.BndSouthSplineInfo[iCell].GQPoint(Position))[1] ,
			    HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell-1,
									    Grid.BndSouthSplineInfo[iCell].GQPoint(Position))[1]);
	  
	  // Compute interface gradient
	  GradU_face = 0.5*(GradUl + GradUr); 
	}
	  
	/* Add the weighted contribution of the current GQP to the total 
	   diffusive flux through the spline segment in the local normal direction. */
	Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
					       Grid.BndSouthSplineInfo[iCell].GQPoint(Position), 
					       Grid.BndSouthSplineInfo[iCell].NormalGQPoint(Position));
      } //endfor (GQPoint)
	
      // Update South face boundary flux with the contribution of this spline segment
      FaceFlux += Flux * Grid.BndSouthSplineInfo[iCell].IntLength(SplineSegment);

    } // endfor (SplineSegment)

    /* Evaluate face contribution to Laplacian. */
    dUdt[iCell][jCell][k_residual] -= FaceFlux/Grid.Cell[iCell][jCell].A;

  } else {
    /* Low-order boundary representation is required.
       Treat the cell faces as straight edges. */

    // Determine the location of the Gauss Quadrature Points
    Grid.getGaussQuadPointsFaceS(iCell,jCell,GaussQuadPoints,NumGQP);
    
    // Reset FaceFlux
    FaceFlux.Vacuum();

    // Calculate total flux through the cell face in the normal direction
    for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

      // == Check the flux calculation method for South block boundary ==
      if ( jCell == JCl && Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){

	// Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1],
			      HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1]);

      } else {

	// Compute left and right interface gradients at the current Gauss
	// point location based on the unlimited high-order reconstruction
	GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1],
			  HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1]);
	GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell-1,GaussQuadPoints[GQPoint])[1] ,
			  HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell-1,GaussQuadPoints[GQPoint])[1]);

	// Compute interface gradient
	GradU_face = 0.5*(GradUl + GradUr);
      }

      /* Add the weighted contribution of the current GQP to the total 
	 diffusive flux through the face in the normal direction. */
      FaceFlux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceS(iCell,jCell));

    } //endfor (GQPoint)
	
    /* Evaluate face contribution to Laplacian. */
    dUdt[iCell][jCell][k_residual] -= FaceFlux*Grid.lfaceS(iCell,jCell)/Grid.Cell[iCell][jCell].A;
    
  } // endif (jCell == JCl && Grid.BndSouthSplineInfo != NULL)


  // ****** Step 3. Compute contribution from the East face to Laplacian *******
  // ***************************************************************************
  // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
  if ( iCell == ICu && Grid.BndEastSplineInfo != NULL){
    /* High-order boundary representation is required.
       Use all geometric information from the correspondent BndSplineInfo */
      
    // Reset FaceFlux
    FaceFlux.Vacuum();

    for (SplineSegment = 1, Position = 1; 
	 SplineSegment <= Grid.BndEastSplineInfo[jCell].NumOfSubIntervals();
	 ++SplineSegment){  // for each continuous spline subinterval
	
      // Reset Flux
      Flux.Vacuum();
	
      // Calculate total flux through the spline subinterval
      for (GQPoint = 0;
	   GQPoint < Grid.BndEastSplineInfo[jCell].GQPointsPerSubInterval();
	   ++GQPoint, ++Position){  // for each Gauss Quadrature point
	  
	// == Check the flux calculation method ==
	if (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux){

	  // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	  GradU_face = Vector2D(HighOrderVariable(Pos).
				XGradientStateAtLocation(iCell,jCell,
							 Grid.BndEastSplineInfo[jCell].GQPoint(Position))[1],
				HighOrderVariable(Pos).
				YGradientStateAtLocation(iCell,jCell,
							 Grid.BndEastSplineInfo[jCell].GQPoint(Position))[1]);
	} else {

	  // Compute left and right interface gradients at the current Gauss
	  // point location based on the unlimited high-order reconstruction
	  GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,
									    Grid.BndEastSplineInfo[jCell].GQPoint(Position))[1],
			    HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,
									    Grid.BndEastSplineInfo[jCell].GQPoint(Position))[1]);
	  GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell+1,jCell,
									    Grid.BndEastSplineInfo[jCell].GQPoint(Position))[1] ,
			    HighOrderVariable(Pos).YGradientStateAtLocation(iCell+1,jCell,
									    Grid.BndEastSplineInfo[jCell].GQPoint(Position))[1]);
	  
	  // Compute interface gradient
	  GradU_face = 0.5*(GradUl + GradUr); 
	}
	  
	/* Add the weighted contribution of the current GQP to the total 
	   diffusive flux through the spline segment in the local normal direction. */
	Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
					       Grid.BndEastSplineInfo[jCell].GQPoint(Position), 
					       Grid.BndEastSplineInfo[jCell].NormalGQPoint(Position));
      } //endfor (GQPoint)
	
      // Update East face boundary flux with the contribution of this spline segment
      FaceFlux += Flux * Grid.BndEastSplineInfo[jCell].IntLength(SplineSegment);

    } // endfor (SplineSegment)

    /* Evaluate face contribution to Laplacian. */
    dUdt[iCell][jCell][k_residual] -= FaceFlux/Grid.Cell[iCell][jCell].A;

  } else {
    /* Low-order boundary representation is required.
       Treat the cell faces as straight edges. */

    // Determine the location of the Gauss Quadrature Points
    Grid.getGaussQuadPointsFaceE(iCell,jCell,GaussQuadPoints,NumGQP);
    
    // Reset FaceFlux
    FaceFlux.Vacuum();

    // Calculate total flux through the cell face in the normal direction
    for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

      // == Check the flux calculation method for East block boundary ==
      if ( iCell == ICu && Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux){

	// Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1],
			      HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1]);

      } else {

	// Compute left and right interface gradients at the current Gauss
	// point location based on the unlimited high-order reconstruction
	GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1],
			  HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1]);
	GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell+1,jCell,GaussQuadPoints[GQPoint])[1] ,
			  HighOrderVariable(Pos).YGradientStateAtLocation(iCell+1,jCell,GaussQuadPoints[GQPoint])[1]);

	// Compute interface gradient
	GradU_face = 0.5*(GradUl + GradUr);
      }

      /* Add the weighted contribution of the current GQP to the total 
	 diffusive flux through the face in the normal direction. */
      FaceFlux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceE(iCell,jCell));

    } //endfor (GQPoint)
	
    /* Evaluate face contribution to Laplacian. */
    dUdt[iCell][jCell][k_residual] -= FaceFlux*Grid.lfaceE(iCell,jCell)/Grid.Cell[iCell][jCell].A;
    
  } // endif (iCell == ICu && Grid.BndEastSplineInfo != NULL)


  // ****** Step 4. Compute contribution from the West face to Laplacian *******
  // ***************************************************************************
  // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
  if ( iCell == ICl && Grid.BndWestSplineInfo != NULL){
    /* High-order boundary representation is required.
       Use all geometric information from the correspondent BndSplineInfo */
      
    // Reset FaceFlux
    FaceFlux.Vacuum();

    for (SplineSegment = 1, Position = 1; 
	 SplineSegment <= Grid.BndWestSplineInfo[jCell].NumOfSubIntervals();
	 ++SplineSegment){  // for each continuous spline subinterval
	
      // Reset Flux
      Flux.Vacuum();
	
      // Calculate total flux through the spline subinterval
      for (GQPoint = 0;
	   GQPoint < Grid.BndWestSplineInfo[jCell].GQPointsPerSubInterval();
	   ++GQPoint, ++Position){  // for each Gauss Quadrature point
	  
	// == Check the flux calculation method ==
	if (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux){

	  // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	  GradU_face = Vector2D(HighOrderVariable(Pos).
				XGradientStateAtLocation(iCell,jCell,
							 Grid.BndWestSplineInfo[jCell].GQPoint(Position))[1],
				HighOrderVariable(Pos).
				YGradientStateAtLocation(iCell,jCell,
							 Grid.BndWestSplineInfo[jCell].GQPoint(Position))[1]);
	} else {

	  // Compute left and right interface gradients at the current Gauss
	  // point location based on the unlimited high-order reconstruction
	  GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,
									    Grid.BndWestSplineInfo[jCell].GQPoint(Position))[1],
			    HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,
									    Grid.BndWestSplineInfo[jCell].GQPoint(Position))[1]);
	  GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell-1,jCell,
									    Grid.BndWestSplineInfo[jCell].GQPoint(Position))[1] ,
			    HighOrderVariable(Pos).YGradientStateAtLocation(iCell-1,jCell,
									    Grid.BndWestSplineInfo[jCell].GQPoint(Position))[1]);
	  
	  // Compute interface gradient
	  GradU_face = 0.5*(GradUl + GradUr); 
	}
	  
	/* Add the weighted contribution of the current GQP to the total 
	   diffusive flux through the spline segment in the local normal direction. */
	Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face,
					       Grid.BndWestSplineInfo[jCell].GQPoint(Position), 
					       Grid.BndWestSplineInfo[jCell].NormalGQPoint(Position));
      } //endfor (GQPoint)
	
      // Update West face boundary flux with the contribution of this spline segment
      FaceFlux += Flux * Grid.BndWestSplineInfo[jCell].IntLength(SplineSegment);

    } // endfor (SplineSegment)

    /* Evaluate face contribution to Laplacian. */
    dUdt[iCell][jCell][k_residual] -= FaceFlux/Grid.Cell[iCell][jCell].A;

  } else {
    /* Low-order boundary representation is required.
       Treat the cell faces as straight edges. */

    // Determine the location of the Gauss Quadrature Points
    Grid.getGaussQuadPointsFaceW(iCell,jCell,GaussQuadPoints,NumGQP);
    
    // Reset FaceFlux
    FaceFlux.Vacuum();

    // Calculate total flux through the cell face in the normal direction
    for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

      // == Check the flux calculation method for West block boundary ==
      if ( iCell == ICl && Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux){

	// Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	GradU_face = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1],
			      HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1]);

      } else {

	// Compute left and right interface gradients at the current Gauss
	// point location based on the unlimited high-order reconstruction
	GradUl = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1],
			  HighOrderVariable(Pos).YGradientStateAtLocation(iCell,jCell,GaussQuadPoints[GQPoint])[1]);
	GradUr = Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(iCell-1,jCell,GaussQuadPoints[GQPoint])[1] ,
			  HighOrderVariable(Pos).YGradientStateAtLocation(iCell-1,jCell,GaussQuadPoints[GQPoint])[1]);

	// Compute interface gradient
	GradU_face = 0.5*(GradUl + GradUr);
      }

      /* Add the weighted contribution of the current GQP to the total 
	 diffusive flux through the face in the normal direction. */
      FaceFlux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceW(iCell,jCell));

    } //endfor (GQPoint)
	
    /* Evaluate face contribution to Laplacian. */
    dUdt[iCell][jCell][k_residual] -= FaceFlux*Grid.lfaceW(iCell,jCell)/Grid.Cell[iCell][jCell].A;
    
  } // endif (iCell == ICl && Grid.BndWestSplineInfo != NULL)

  // Change diffusion field to the original one
  DiffusionFields::Change_Diffusion_Field_To_Original();
  
  // Reset pointer to the original diffusion field
  DiffusionFields::Connect_Pointer_To_Diffusion_Field(AdvectDiffuse2D_State::k);

}
