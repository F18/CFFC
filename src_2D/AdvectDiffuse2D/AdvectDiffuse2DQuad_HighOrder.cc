/*! \file AdvectDiffuse2DQuad_HighOrder.cc
  @brief High-order Subroutines for 2D Advection Diffusion Equation Quadrilateral Mesh Solution Classes. */

/* Include required C++ libraries. */
// None

/* Using std namespace functions */
// None

/* Include CFFC header files */
#include "AdvectDiffuse2DQuad.h"        // AdvectDiffuse2D_Quad_Block class

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the interior nodes of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 *
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 */
void AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							  const double &Time,
							  const int &Block_Number,
							  const int &Output_Title,
							  ostream &Out_File,
							  const int &IndexHO) {

    int i, j, nRow, nLoop;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output node solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (NCi - 2*Nghost)*3  << " \\ \n"
	       << "J = " << (NCj - 2*Nghost)*3 << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (NCi - 2*Nghost)*3 << " \\ \n"
	       << "J = " << (NCj - 2*Nghost)*3 << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for ( j  = JCl ; j <= JCu ; ++j ) {	// for every j Cell
      for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
	for ( i = ICl ; i <= ICu ; ++i ) { // for every i Cell
	  for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	    // Get the node location
	    switch(nRow){
	    case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeSW(i,j)
		Node = Grid.nodeSW(i,j).X;
		break;
	      case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCl && Grid.BndSouthSplineInfo != NULL){
		  Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceS(i,j);
		}
		break;
	      case 3:		// output NodeSE(i,j)
		Node = Grid.nodeSE(i,j).X;
		break;
	      }
	      break;

	    case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	      switch(nLoop){
	      case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICl && Grid.BndWestSplineInfo != NULL){
		  Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceW(i,j);
		}
		break;
	      case 2:		// output Grid.CellCentroid(i,j)
		Node = Grid.CellCentroid(i,j);
		break;
	      case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICu && Grid.BndEastSplineInfo != NULL){
		  Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceE(i,j);
		}
		break;
	      }
	      break;

	    case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeNW(i,j)
		Node = Grid.nodeNW(i,j).X;
		break;
	      case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCu && Grid.BndNorthSplineInfo != NULL){
		  Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceN(i,j);
		}
		break;
	      case 3:		// output NodeNE(i,j)
		Node = Grid.nodeNE(i,j).X;
		break;
	      }
	      break;
	    } // endswitch

	    // Output Brief format
	    U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << U_node;


	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File << " " << U[i][j].V(Node.x,Node.y)
		       << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		       << " " << source(Node.x,Node.y,U_node);
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	      Out_File.unsetf(ios::scientific);
	      if (ExactSoln->IsExactSolutionSet()){
		Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	      }
	    }

	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File << " " << dUdt[i][j][0];
	    }

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);

	  }
	} /* endfor */
      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the interior nodes of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								     const AdvectDiffuse2D_Input_Parameters &IP,
								     const int &Block_Number,
								     const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  
  /* Open the output data file. */
  
  output_file.open(output_file_name, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }
  
  try {
    Output_Tecplot_HighOrder(0,0,
			     Block_Number,
			     1,
			     output_file,
			     IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }

  /* Close the output data file. */
  output_file.close();

  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all nodes (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 */
void AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
								const double &Time,
								const int &Block_Number,
								const int &Output_Title,
								ostream &Out_File,
								const int &IndexHO) {

    int i, j, nRow, nLoop;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output node solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3  << " \\ \n"
	       << "J = " << ( JCu - JCl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << (ICu - ICl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "J = " << (JCu - JCl + 1 + 2*HighOrderVariable(IndexHO).NghostHO() )*3 << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for (j=JCl-HighOrderVariable(IndexHO).NghostHO(); j<=JCu+HighOrderVariable(IndexHO).NghostHO(); ++j) {// for every j Cell
      for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
	for (i=ICl-HighOrderVariable(IndexHO).NghostHO(); i<=ICu+HighOrderVariable(IndexHO).NghostHO(); ++i) {// for every i Cell
	  for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	    // Get the node location
	    switch(nRow){
	    case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeSW(i,j)
		Node = Grid.nodeSW(i,j).X;
		break;
	      case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCl && Grid.BndSouthSplineInfo != NULL && i>= ICl && i<= ICu ){
		  Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceS(i,j);
		}
		break;
	      case 3:		// output NodeSE(i,j)
		Node = Grid.nodeSE(i,j).X;
		break;
	      }
	      break;

	    case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	      switch(nLoop){
	      case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICl && Grid.BndWestSplineInfo != NULL && j>=JCl && j<=JCu ){
		  Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceW(i,j);
		}
		break;
	      case 2:		// output Grid.CellCentroid(i,j)
		Node = Grid.CellCentroid(i,j);
		break;
	      case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(2)
		if (i == ICu && Grid.BndEastSplineInfo != NULL && j>=JCl && j<=JCu ){
		  Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceE(i,j);
		}
		break;
	      }
	      break;

	    case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	      switch(nLoop){
	      case 1:		// output NodeNW(i,j)
		Node = Grid.nodeNW(i,j).X;
		break;
	      case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(2)
		if(j == JCu && Grid.BndNorthSplineInfo != NULL && i>= ICl && i<= ICu ){
		  Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(2);
		} else {
		  Node = Grid.xfaceN(i,j);
		}
		break;
	      case 3:		// output NodeNE(i,j)
		Node = Grid.nodeNE(i,j).X;
		break;
	      }
	      break;
	    } // endswitch

	    // Output Brief format
	    U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << U_node;


	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File << " " << U[i][j].V(Node.x,Node.y)
		       << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		       << " " << source(Node.x,Node.y,U_node);
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	      Out_File.unsetf(ios::scientific);
	      if (ExactSoln->IsExactSolutionSet()){
		Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	      }
	    }

	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File << " " << dUdt[i][j][0];
	    }

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);

	  }
	} /* endfor */
      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the nodes (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Nodes_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									   const AdvectDiffuse2D_Input_Parameters &IP,
									   const int &Block_Number,
									   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_nodes_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Nodes_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Nodes_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all cells (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder(const int &Number_of_Time_Steps,
								const double &Time,
								const int &Block_Number,
								const int &Output_Title,
								ostream &Out_File,
								const int &IndexHO) {


    int i, j;
    AdvectDiffuse2D_State U_node;
    Vector2D Node;

    if (NumberOfHighOrderVariables <= IndexHO){
      throw runtime_error("AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder() ERROR! High-order object index out of range!");
    }

    /* Output cell centroid solution data. */

    Out_File << setprecision(14);
    if (Output_Title) {
      // Set the Brief format
      Out_File << "TITLE = \"" << CFFC_Name() << ": 2D Advection Diffusion Equation Solution, "
	       << "Time Step/Iteration Level = " << Number_of_Time_Steps
	       << ", Time = " << Time
	       << "\"" << "\n"
	       << "VARIABLES = \"x\" \\ \n"
	       << "\"y\" \\ \n"
	       << "\"u\" \\ \n";

      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File  << "\"UAvg\" \\ \n"
		  << "\"Vx\" \\ \n"
		  << "\"Vy\" \\ \n"
		  << "\"k\" \\ \n"
		  << "\"s\" \\ \n"
		  << "\"ValISu\" \\ \n"
		  << "\"ISu\" \\ \n";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "\"ExactSoln\" \\ \n";
	}
      }

      // Add more variables for the Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File  << "\"ResidualU\" \\ \n";
      }

      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } else {
      Out_File << "ZONE T =  \"Block Number = " << Block_Number
	       << "\" \\ \n"
	       << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	       << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	       << "F = POINT \n";
    } /* endif */


    // Set the accuracy properly
    if (Tecplot_Execution_Mode::IsDoublePrecision()){
      Out_File << "DT = (DOUBLE DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE SHORTINT ";
	if (ExactSoln->IsExactSolutionSet()){
	  Out_File << "DOUBLE ";
	}
      }

      // Full format
      if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	Out_File << "DOUBLE ";
      }

      // Close line
      Out_File << " ) \n";
    } // endif (DoublePrecision)


    // Output data
    for (j = JCl-Nghost; j <= JCu+Nghost; ++j) {// for every j Cell
      for (i = ICl-Nghost; i <= ICu+Nghost; ++i) {// for every i Cell

	// Set the location
	Node = Grid.CellCentroid(i,j);

	if (i < ICl-HighOrderVariable(IndexHO).NghostHO() || 
	    i > ICu+HighOrderVariable(IndexHO).NghostHO() || 
	    j < JCl-HighOrderVariable(IndexHO).NghostHO() ||
	    j > JCu+HighOrderVariable(IndexHO).NghostHO()  ) {

	  // No high-order interpolant is calculated for this cells.
	  // The average solution is plotted at the centers of these cells.
	  
	  // Output Brief format
	  Out_File << " "  << Node 
		   << " "  << CellSolution(i,j);

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    Out_File << " " << U[i][j].V(Node.x,Node.y)
		     << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		     << " " << source(Node.x,Node.y,U_node);
	    Out_File.setf(ios::scientific);
	    Out_File << " " << 1.0E8
		     << " " << 0;
	    Out_File.unsetf(ios::scientific);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File << " " << dUdt[i][j][0];
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} else {

	  // Use the high-order interpolant to calculate the solution at the cell centroids.
	  
	  // Output Brief format
	  U_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	  Out_File << " "  << Node 
		   << " "  << U_node;

	  // Add more variables for the Detailed format
	  if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	    Out_File << " " << CellSolution(i,j);
	    Out_File << " " << U[i][j].V(Node.x,Node.y)
		     << " " << U[i][j].k(Node.x,Node.y,U_node[1]) 
		     << " " << source(Node.x,Node.y,U_node);
	    Out_File.setf(ios::scientific);
	    Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1);
	    Out_File.unsetf(ios::scientific);
	    if (ExactSoln->IsExactSolutionSet()){
	      Out_File << " " << ExactSoln->Solution(Node.x,Node.y);
	    }
	  }

	  // Add more variables for the Full format
	  if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	    Out_File << " " << dUdt[i][j][0];
	  }

	  // Close line
	  Out_File << "\n";
	  Out_File.unsetf(ios::scientific);

	} // endif

      }
    } /* endfor */
    Out_File << setprecision(6);
    
}

/*!
 * Writes the solution values at the centroids (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost cells for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void AdvectDiffuse2D_Quad_Block::Output_Cells_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									   const AdvectDiffuse2D_Input_Parameters &IP,
									   const int &Block_Number,
									   const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cells_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Cells_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Cells_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Evaluate the residual for the solution block 
 * using the high-order CENO upwind finite-volume 
 * spatial discretization scheme for the  
 * convective flux coupled with a centrally-weighted    
 * high-order finite-volume discretization for the diffusive flux.  
 * The residual is stored in dUdt[][][0].               
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *                                                      
 */
int AdvectDiffuse2D_Quad_Block::dUdt_Residual_Evaluation_HighOrder(const AdvectDiffuse2D_Input_Parameters &IP,
								   const unsigned short int Pos){



  /* residual evaluation successful. */
  return 0;
}


/*!
 * This routine determines the solution residuals for a 
 * given stage of a variety of multi-stage explicit     
 * time integration schemes for the solution block.
 * The solution residuals are evaluated  
 * using the high-order CENO upwind finite-volume 
 * spatial discretization scheme for the convective 
 * flux coupled with a centrally-weighted high-order 
 * finite-volume discretization for the diffusive flux.
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 */
int AdvectDiffuse2D_Quad_Block::dUdt_Multistage_Explicit_HighOrder(const int &i_stage,
								   const AdvectDiffuse2D_Input_Parameters &IP,
								   const unsigned short int Pos) {

  int i, j, k_residual, GQPoint;
  double omega;
  AdvectDiffuse2D_State Ul, Ur, U_face, Flux;
  Vector2D GradU_face;		// Solution gradient at the inter-cellular face
  int NumGQP(Grid.getNumGQP());	// Number of Gauss quadrature points per face used to compute the flux integral

  Vector2D *GaussQuadPoints = new Vector2D [NumGQP]; // the GQPs at which a Riemann-like problem is solved
  double * GaussQuadWeights = new double [NumGQP];   // the Gauss integration weights for each Gauss quadrature


  /* Set the GaussQuadWeights. */
  GaussQuadratureData::getGaussQuadWeights(GaussQuadWeights, NumGQP);

  /* Evaluate the solution residual for stage 
     i_stage of an N stage scheme. */

  /* Evaluate the time step fraction and residual storage location for the stage. */
  
  switch(IP.i_Time_Integration) {
  case TIME_STEPPING_EXPLICIT_EULER :
    omega = Runge_Kutta(i_stage, IP.N_Stage);
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
    omega = Runge_Kutta(i_stage, IP.N_Stage);
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
    omega = Runge_Kutta(i_stage, IP.N_Stage);
    k_residual = 0;
    if (IP.N_Stage == 4) {
      if (i_stage == 4) {
	k_residual = 0;
      } else {
	k_residual = i_stage - 1;
      } /* endif */
    } /* endif */
    break;
  case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
    omega = MultiStage_Optimally_Smoothing(i_stage, 
					   IP.N_Stage,
					   IP.i_Limiter);
    k_residual = 0;
    break;
  default:
    omega = Runge_Kutta(i_stage, IP.N_Stage);
    k_residual = 0;
    break;
  } /* endswitch */

  /***************************************************************************************
   *                 EVALUATE THE HIGH-ORDER SOLUTION RESIDUALS                          *
   *                                                                                     *
   * Algorithm Purpose: To evaluate solution residuals for solution blocks               *
   *                    characterized by a broad range of options.                       *
   *                                                                                     *
   * Important options to consider:                                                      *
   *         --> Geometry treatment: high-order or low-order                             *
   *         --> Spatial accuracy:   order of accuracy for flux calculation              *
   *         --> Boundary flux calculation: 'Riemann' problem or reconstruction based    *
   *                                                                                     *
   * In order to respond easier to all these parameter variations, the following         *
   * algorithm is adopted to sweep through the cell interfaces:                          *
   *         --> Compute all fluxes at interior inter-cellular faces.                    *
   *         --> Compute fluxes for South and North block boundary faces.                *
   *         --> Compute fluxes for East and West block boundary faces.                  *
   *                                                                                     *
   * Note: Two passes are needed to compute both elliptic and hyperbolic terms!          *
   ***************************************************************************************/

  /* Evaluate the time rate of change of the solution
     (i.e., the solution residuals) using a centrally-weighted
     gradient reconstruction for the diffusive fluxes.
     NOTE: Include here the contribution of the elliptic and source terms! */

   
  /* Perform the unlimited high-order reconstruction within 
     each cell of the computational grid for this stage. 
     NOTE: This solution reconstruction IS NOT recommended for computing hyperbolic fluxes!
  */
  HighOrderVariable(Pos).ComputeUnlimitedSolutionReconstruction(*this);

  // ************* Step 1. (Re)-Set parameters in all cells based on the time integration scheme **************
  // **********************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ){
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {

      if ( i_stage == 1 ){
	Uo[i][j] = U[i][j];
	dUdt[i][j][k_residual].Vacuum();  // set to zero
      } else {
	switch(IP.i_Time_Integration) {
	case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
	  // 
	  break;
	case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
	  if (IP.N_Stage == 2) {
	    // 
	  } else if (IP.N_Stage == 4 && i_stage == 4) {
	    dUdt[i][j][k_residual] = ( dUdt[i][j][0] + 
				       TWO*dUdt[i][j][1] +
				       TWO*dUdt[i][j][2] );
	  } else {
	    dUdt[i][j][k_residual].Vacuum();  // set to zero
	  } /* endif */
	  break;
	case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	default:
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	} /* endswitch */
      }/* endif */

    } // endfor (i)
  } // endfor (j)


  // ** Step 2. Compute interior diffusive fluxes and any source contributions for cells between (ICl,JCl)-->(ICu,JCu) **
  // ********************************************************************************************************************
  for ( j = JCl ; j <= JCu ; ++j ){
    for ( i = ICl ; i <= ICu ; ++i ) {
      
      if ( i != ICu) { 		// (i == ICu) corresponds to the East block boundary which will be considered separately!
	
	/* Evaluate the cell interface i-direction diffusive fluxes.
	   --> ( i.e. East Flux for cell (i,j) & West Flux for cell (i+1,j) ) */
	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceE(i,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the unlimited high-order reconstruction
	  Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i  ,j,GaussQuadPoints[GQPoint]);
	  Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i+1,j,GaussQuadPoints[GQPoint]);

	  // Determine the solution state at the Gauss quadrature
	  // point for the calculation of the diffusion coefficient
	  U_face = 0.5*(Ul + Ur);

	  // Calculate gradient at the Gauss quadrature point using a centrally-weighted reconstruction.
	  GradU_face = 0.5*Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i  ,j,GaussQuadPoints[GQPoint])[1] + 
				    HighOrderVariable(Pos).XGradientStateAtLocation(i+1,j,GaussQuadPoints[GQPoint])[1] ,
				    HighOrderVariable(Pos).YGradientStateAtLocation(i  ,j,GaussQuadPoints[GQPoint])[1] + 
				    HighOrderVariable(Pos).YGradientStateAtLocation(i+1,j,GaussQuadPoints[GQPoint])[1]);

	  /* Add the weighted contribution of the current GQP to the total 
	     diffusive flux in the normal direction through the face. */
	  Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceE(i, j));

	} //endfor (GQPoint)
      
	/* Evaluate cell-averaged solution changes. */
	dUdt[i  ][j][k_residual] -= ( (IP.CFL_Number * dt[i  ][j])*
				      Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );

	dUdt[i+1][j][k_residual] += ( (IP.CFL_Number * dt[i+1][j])*
				      Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );

      }	//endif (i != ICu)


      if ( j != JCu) {		// (j == JCu) corresponds to the North block boundary which will be considered separately!

	/* Evaluate the cell interface j-direction diffusive fluxes.
	   --> ( i.e. North Flux for cell (i,j) & South Flux for cell (i,j+1) ) */
	// Determine the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceN(i,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the unlimited high-order reconstruction
	  Ul = HighOrderVariable(Pos).SolutionStateAtLocation(i,j  ,GaussQuadPoints[GQPoint]);
	  Ur = HighOrderVariable(Pos).SolutionStateAtLocation(i,j+1,GaussQuadPoints[GQPoint]);

	  // Determine the solution state at the Gauss quadrature
	  // point for the calculation of the diffusion coefficient
	  U_face = 0.5*(Ul + Ur);

	  // Calculate gradient at the Gauss quadrature point using a centrally-weighted reconstruction.
	  GradU_face = 0.5*Vector2D(HighOrderVariable(Pos).XGradientStateAtLocation(i,j  ,GaussQuadPoints[GQPoint])[1] + 
				    HighOrderVariable(Pos).XGradientStateAtLocation(i,j+1,GaussQuadPoints[GQPoint])[1] ,
				    HighOrderVariable(Pos).YGradientStateAtLocation(i,j  ,GaussQuadPoints[GQPoint])[1] + 
				    HighOrderVariable(Pos).YGradientStateAtLocation(i,j+1,GaussQuadPoints[GQPoint])[1]);

	  /* Add the weighted contribution of the current GQP to the total 
	     diffusive flux through the face in the normal direction. */
	  Flux += GaussQuadWeights[GQPoint] * Fd(U_face, GradU_face, GaussQuadPoints[GQPoint], Grid.nfaceN(i, j));
	} //endfor (GQPoint)


	/* Evaluate cell-averaged solution changes. */
	dUdt[i][j  ][k_residual] -= ( (IP.CFL_Number * dt[i][j  ])*
				      Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );

	dUdt[i][j+1][k_residual] += ( (IP.CFL_Number * dt[i][j+1])*
				      Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );

      } //endif (j != JCu)

      /* Include regular source terms. */
      dUdt[i][j][k_residual] += (IP.CFL_Number*dt[i][j])*SourceTerm(i,j);
	
      /* Include axisymmetric source terms as required. */
      if (Axisymmetric) {
	dUdt[i][j][k_residual] += ( (IP.CFL_Number*dt[i][j])*
				    AxisymmetricSourceTerm(i,j) );
      } /* endif */

    } // endfor (i)
  } // endfor (j)




  /* Evaluate the time rate of change of the solution
     (i.e., the solution residuals) using a high-order 
     CENO upwind finite-volume scheme for the convective fluxes.
     NOTE: Include here the contribution of the hyperbolic terms! */


  /* Enforce monotonicity to the high-order interpolants detected as 
     non-smooth by the smoothness indicator analysis. 
     NOTE: This solution reconstruction IS recommended for computing hyperbolic fluxes!
  */
  HighOrderVariable(Pos).ComputeSmoothnessIndicator(*this);
  HighOrderVariable(Pos).EnforceMonotonicityToNonSmoothInterpolants(*this, IP.Limiter());





  // Deallocate memory
  delete [] GaussQuadPoints;
  delete [] GaussQuadWeights;

  /* residual for the stage successfully calculated. */
  return (0);
}
