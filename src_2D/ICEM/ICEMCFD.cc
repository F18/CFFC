/*! \file ICEMCFD.cc
  @brief Subroutines for Reading CFD Mesh Generated by ICEMCFD. */

/************************************************************************
 *                                                                      *
 *                         Written by Ming Yao Ding                     *
 *                      email: mingyao.ding@utoronto.ca                 *
 *                     Modified & written by Stefan Neata               *
 *                      email: stefan.neata@utoronto.ca                 *
 *         University of Toronto Institute for Aerospace Studies        *
 *                           Summers 2002 & 2003                        *
 *                                                                      * 
 ************************************************************************/

/* Include ICEMCFD header file. */

#ifndef _ICEMCFD_INCLUDED
#include "ICEMCFD.h"
#endif // _ICEMCFD_INCLUDED

/****************************************************
ICEMCFD_error
****************************************************/
void ICEMCFD_error(){

#ifdef _ICEMCFD_VERSION
  cout << "\n ICEMCFD ERROR: " << df_get_error() << "\n";
  cout.flush();
#endif

}

/****************************************************
ICEMCFD_get_filenames
****************************************************/
char **ICEMCFD_get_filenames() {

  int i;
  char **icemcfd_file_names;

  icemcfd_file_names = new char*[3];
  for ( i = 0 ; i < 3 ; i++ ) {
     icemcfd_file_names[i] = new char[20];
  } /* endfor */

#ifdef _ICEMCFD_V41
  strcpy(icemcfd_file_names[0],"topo_mulcad_out");
  strcpy(icemcfd_file_names[1],"family_boco");
  strcpy(icemcfd_file_names[2],"family_topo");
#else // V42, V43, V50
  strcpy(icemcfd_file_names[0],"topo_mulcad_out.top");
  strcpy(icemcfd_file_names[1],"family_boco.fbc");
  strcpy(icemcfd_file_names[2],"family_topo.fto");
 
#endif

  return(icemcfd_file_names);

}

/****************************************************
ICEMCFD_get_boco is a function that compares the family name
of an edges to the predefined values for boundary 
conditions and returns that value.
In other words, the boundary conditions of an edges is 
set by grouping the edge into a family with one of the
following names.  BC_NONE is the default boundary type.
****************************************************/
int ICEMCFD_get_boco(char *file_read){

  if      (strcmp(file_read, "BC_NONE")==0) return (BC_NONE);
  else if (strcmp(file_read, "BC_FIXED")==0) return (BC_FIXED);
  else if (strcmp(file_read, "BC_CONSTANT_EXTRAPOLATION")==0) return (BC_CONSTANT_EXTRAPOLATION);
  else if (strcmp(file_read, "BC_LINEAR_EXTRAPOLATION")==0) return (BC_LINEAR_EXTRAPOLATION);
  else if (strcmp(file_read, "BC_REFLECTION")==0) return (BC_REFLECTION);
  else if (strcmp(file_read, "BC_PERIODIC")==0) return (BC_PERIODIC);
  else if (strcmp(file_read, "BC_CHARACTERISTIC")==0) return (BC_CHARACTERISTIC);
  else if (strcmp(file_read, "BC_OPEN_END")==0) return (BC_OPEN_END);
  else if (strcmp(file_read, "BC_DIRICHLET")==0) return (BC_DIRICHLET);
  else if (strcmp(file_read, "BC_NEUMANN")==0) return (BC_NEUMANN);
  else if (strcmp(file_read, "BC_ROBIN")==0) return (BC_ROBIN);
  else if (strcmp(file_read, "BC_NO_SLIP")==0) return (BC_NO_SLIP);
  else if (strcmp(file_read, "BC_WALL_VISCOUS_ISOTHERMAL")==0) return (BC_WALL_VISCOUS_ISOTHERMAL);
  else if (strcmp(file_read, "BC_WALL_VISCOUS_HEATFLUX")==0) return (BC_WALL_VISCOUS_HEATFLUX);
  else if (strcmp(file_read, "BC_MOVING_WALL")==0) return (BC_MOVING_WALL);
  else if (strcmp(file_read, "BC_MOVING_WALL_ISOTHERMAL")==0) return (BC_MOVING_WALL_ISOTHERMAL);
  else if (strcmp(file_read, "BC_MOVING_WALL_HEATFLUX")==0) return (BC_MOVING_WALL_HEATFLUX);
  else if (strcmp(file_read, "BC_FIXED_TEMP_WALL")==0) return (BC_FIXED_TEMP_WALL);
  else if (strcmp(file_read, "BC_ADIABATIC_WALL")==0) return (BC_ADIABATIC_WALL);
  else if (strcmp(file_read, "BC_FIXED_TEMP")==0) return (BC_FIXED_TEMP);
  else if (strcmp(file_read, "LEFT_END_BOUNDARY")==0) return (LEFT_END_BOUNDARY);
  else if (strcmp(file_read, "RIGHT_END_BOUNDARY")==0) return (RIGHT_END_BOUNDARY);
  else if (strcmp(file_read, "BC_FIXED_HEATFLUX")==0) return (BC_FIXED_HEATFLUX);
  else if (strcmp(file_read, "BC_BURNING_SURFACE")==0) return (BC_BURNING_SURFACE);
  else if (strcmp(file_read, "BC_ABSORPTION")==0) return (BC_ABSORPTION);

  return (BC_NONE);

}

/************
 * 2D STUFF *
 ************/

/****************************************************
ICEMCFD_get_layout determines the layout of the
multi block grid from which neighbouring information
can be determined.  The subroutine uses a recursive 
procedure to finds all of the domains and store the
layout in a 2D array.
*****************************************************/
void ICEMCFD_get_layout(int **layout, 
                        int x, 
                        int y, 
                        int &expdom, 
                        int &smallest, 
                        int &smallindex){

#ifdef _ICEMCFD_VERSION
  int dimension=2;//dimension of domain
  int adj_domain[4];//list of adjacent domains
  int adj_subface[4];//list of adjacent subfaces
  int edgee[4];//list of shared edge entities
  int edges[4];//stores edges in order: south(0), west(1), north(2), east(3)
  int tempedges[4];//list of edge entities
  int nedgee=0;//number of shared edge entities

  //ICEMCFD variables
  int *value;//
  int subface[4]; 
  int ier;
  int nedges;  
  int jmin[3], jmax[3];
  
  //get edges of domain, and orientation of each edge
  nedges=tp_edges_of_domain(layout[x][y], tempedges);
  for(int j =0; j<4;j++){
    edges[j]=-1;
  }
  for(int i =0; i<4; i++){
    ier=tp_edge_entity_range(layout[x][y], tempedges[i], jmin, jmax);
    if     (jmin[0]==1 && jmin[1]==1 && jmax[0]!=1 && jmax[1]==1)edges[0]=tempedges[i];//south
    else if(jmin[0]==1 && jmin[1]==1 && jmax[0]==1 && jmax[1]!=1)edges[1]=tempedges[i];//west
    else if(jmin[0]==1 && jmin[1]!=1 && jmax[0]!=1 && jmax[1]!=1)edges[2]=tempedges[i];//north 
    else if(jmin[0]!=1 && jmin[1]==1 && jmax[0]!=1 && jmax[1]!=1)edges[3]=tempedges[i];//east
  }

  expdom=expdom+1;
  nedgee=tp_nsubad(layout[x][y], value);
  ier=tp_domad(layout[x][y], dimension, subface, adj_domain, adj_subface, edgee);
  //check to see which edge of the domain has an adjacent domain
  for(int k=0; k<nedgee; k++){
    for(int i=0; i<nedgee; i++){
      if(edges[0]==edgee[i] && (y-1)>=0 && layout[x][y-1]==0 ){
	layout[x][y-1]=adj_domain[i];
	if(layout[x][y-1]==(smallest+1))
	  smallest++;
	if(layout[x][y-1]>smallindex)
	  smallindex=layout[x][y-1];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y-1, expdom, smallest, smallindex);
      }
      
      if(edges[1]==edgee[i] && (x-1)>=0 && layout[x-1][y]==0){
	layout[x-1][y]=adj_domain[i];      
	if(layout[x-1][y]==smallest+1)
	  smallest=smallest+1;
	if(layout[x-1][y]>smallindex)
	  smallindex=layout[x-1][y];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x-1, y, expdom, smallest, smallindex);
      }
      
      if(edges[2]==edgee[i] && layout[x][y+1]==0){
	layout[x][y+1]=adj_domain[i];
	if(layout[x][y+1]==smallest+1)
	smallest=smallest+1;
	if(layout[x][y+1]>smallindex)
	  smallindex=layout[x][y+1];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y+1, expdom, smallest, smallindex);
      }
      
      if((edgee[i]==edges[3]) && (layout[x+1][y]==0)){
	layout[x+1][y]=adj_domain[i];
	if(layout[x+1][y]==smallest+1)
	  smallest=smallest+1;
	if(layout[x+1][y]>smallindex)
	  smallindex=layout[x+1][y];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x+1, y, expdom, smallest, smallindex);
      }
    }
  }
#endif
}

/********************************************************
ICEMCFD_Read reads the data in the domain files from ICEMCFD
and stores the data in a 2D quadrilateral multiblock grid 
structure defined by Grid2D_Quad_Block class. The Boundary 
condtions are gathered from the toplogy and boundary 
conditions files.
                
filenames should have 3 strings including
file name for the topology information,
by default the filename is "topo_mulcad_out".
the two boundary condition files which in ICEMCFD
v4.1 by default the names are "family_boco" and "family_topo"
respectively.

domx_buf and domy_buf are variables to hold  the number of 
domains in the x and y direction.
********************************************************/
Grid2D_Quad_Block** ICEMCFD_Read(char **filenames,
                                 Grid2D_Quad_Block **Grid_ptr,
                                 int *domx_buf, 
                                 int *domy_buf){

#ifdef _ICEMCFD_VERSION
  // CFD Variables
  int Ni, Nj;
  int i,j,k,x,y;
  int spline_type;

  // ICEM Variables
  int file_no,mode,type, ier;
  int coord, n_domain,n_nodes;
  char sub_name[200];
  int imin[3],imax[3];
  int jmin[3],jmax[3];
  double *node_pnts;
  char dom_name[20];

  //*************** Topology and Boundary conditions
  int ndom,nsfac,nar,nvert,nedges;
  int edges[4],tempedges[4];
  int UNDEFINED_EDGE_NUMBER = -1000;

  // boundary conditions library variables
  int ibc;
  char **values;
  char bc_temp[40];

  values = new char*[2];
  for (i=0; i<2; i++) values[i] = new char[20];

  tp_init(filenames[0]);//opens, reads, and closes the topology file.  Information is stored in memory.
  ndom=tp_ndom();
  nsfac=tp_nsfac();
  nar=tp_nar();
  nvert=tp_nvert();

  /********* Initializing Boundary conditions Library**********/
  ier = bc_init_both(filenames[1], filenames[2] ,ndom, nsfac,nar,nvert,0,0,0);  
  
  /*********getting layout of domains**********************/
  /**calls the recursive ICEMCFD_get_layout function until all the domains have been entered into a 2D array****/
  int expdom=0;//keeps track of the number of domains entered into array
  int **layout;//2D array stores domain connectivity information
  int xcor=0;
  int ycor=0;
  int smallindex=0;
  int smallest =1;
  int count=0;
  ofstream fout;

  layout = new int*[ndom+1];
  for(int i=0;i<(ndom+1);i++) layout[i]=new int[ndom+1];

  while(expdom != ndom){
    for(int i = 0; i <(ndom+1);i++){
      for(int j=0; j<(ndom+1); j++){
	layout[i][j]=0;
      }
    }
    expdom=0;
    //search for first array location where there is a domain
    if(smallest==ndom && smallest>1){
      count=0;
      smallest=1;
      if((xcor)!=ndom)
	xcor=xcor+1;
      else{
	xcor=0;
	ycor=ycor+1;
      }
    }
	
    //call recursive function until all domains are entered
    if(count==0)
      layout[xcor][ycor]=smallest;
    else{
      smallest=smallest+1;
      layout[xcor][ycor]=smallest;
    }
    if(smallest>ndom){
      cout<<"error, error"<<endl;
      exit(0);
    }
    ICEMCFD_get_layout(layout, xcor, ycor, expdom, smallest, smallindex);
    count=count+1;
  }

  //reduce the array to proper size
  int flagx, flagy;
  int domxx=ndom;
  int domyy=ndom;

  for(int i = 0; i <domxx;i++){
    flagx=0;
    for(int j = 0; j<domyy; j++){
      if(layout[i][j]!=0)
	flagx=-1;
    }
    if(flagx==0)
      domxx=i;
  }

  for(int j = 0; j <domyy;j++){
    flagy=0;
    for(int i = 0; i<domxx; i++){
      if(layout[i][j]!=0)
	flagy=-1;
    }
    if(flagy==0)
      domyy=j;
  }

  if (domxx <= 0 || domyy <= 0) return(NULL);

  //output the connectivity information  
//   fout.open("icemcfd_block_connectivity.dat");
//   fout<<"["<<domxx<<","<<domyy<<"]";
//   for(int j = 0; j < domyy ; j++){
//     for(int i = 0; i < domxx; i++){
//       if(i==domxx-1 && j==domyy-1)
//   	fout<<layout[i][j];
//       else
//       fout<<layout[i][j]<<",";
//     }
//   }
//   fout.close();

  /******* Allocating memory for Multi block grid ********/
  Grid_ptr = Allocate_Multi_Block_Grid(Grid_ptr, domxx, domyy);  

  for (y = 0; y < domyy; y++) {
    for (x = 0; x < domxx; x++) {

      /****** Ignore if domain number is 0 *******/
      if (layout[x][y]!=0){

	sprintf(dom_name,"domain.%d",layout[x][y]);
	
        // *********** ICEM PART
	mode=MODE_READ;
	type=STRUCTURED_DOMAIN;

	// OPEN the domain file 
	file_no=df_open(dom_name, mode, type);
	if (file_no<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */
      
	// GET the number of subdomains
	ier = df_n_domain(file_no,&n_domain);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	// Get node range
	ier = df_struct_domain_range(file_no,n_domain-1,imin,imax);
	if (ier<0) {
           ICEMCFD_error(); 
           return (NULL);
        } /* endif */

	Ni=imax[0];
	Nj=imax[1];
      
	n_nodes=Ni*Nj*3;
	// READ all the nodes from ICEM domain file
	node_pnts=(double *)malloc(n_nodes*sizeof(double));

	ier=df_struct_read_nodes(file_no, n_domain-1, imin,imax, node_pnts);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	// CLOSE the domain file
	ier=df_close(file_no);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	//**********************
	// Find the edges numbers associated with the 
	// current domain
	//**********************
	nedges = tp_edges_of_domain(layout[x][y],tempedges);

	//***************************
	// Find the north, south, east, and west boundary edges.
	//***************************
	for (i=0; i<4; i++) {
          edges[i] = UNDEFINED_EDGE_NUMBER;
        } /* endfor */
	for (i=0; i<4; i++) {
	  ier = tp_edge_entity_range(layout[x][y], tempedges[i], jmin, jmax);
          if (ier<0) {
            ICEMCFD_error();
            return (NULL);
          } /* endif */
	  if     (jmin[0]==1 && jmin[1]==1 && jmax[0]!=1 && jmax[1]==1) edges[0]=tempedges[i]; //south
	  else if(jmin[0]==1 && jmin[1]==1 && jmax[0]==1 && jmax[1]!=1) edges[1]=tempedges[i]; //west
	  else if(jmin[0]==1 && jmin[1]!=1 && jmax[0]!=1 && jmax[1]!=1) edges[2]=tempedges[i]; //north
	  else if(jmin[0]!=1 && jmin[1]==1 && jmax[0]!=1 && jmax[1]!=1) edges[3]=tempedges[i]; //east
	  else {
	    //printf("***ERROR: Can;t figure out the boundary edges!!!");
          }
	} /* endfor */

	//****** Allocate memory for current domain *********/	
	Grid_ptr[x][y].allocate(Ni-1,Nj-1,2);

	// Convert 1D array of nodes into a 2D array
	for (j = Grid_ptr[x][y].JNl; j <= Grid_ptr[x][y].JNu; j++) {
	  for (i = Grid_ptr[x][y].INl; i <= Grid_ptr[x][y].INu; i++) {
	    Grid_ptr[x][y].Node[i][j].X.x = node_pnts[3*(i-Grid_ptr[x][y].INl+Ni*(j-Grid_ptr[x][y].JNl))];
	    Grid_ptr[x][y].Node[i][j].X.y = node_pnts[3*(i-Grid_ptr[x][y].INl+Ni*(j-Grid_ptr[x][y].JNl))+1];
	  } /* endfor */
	} /* endfor */

	//**** Specify the spline type for the edges of the domain*****/
 	spline_type = SPLINE2D_QUINTIC;
	
	// North boundary
	Grid_ptr[x][y].BndNorthSpline.allocate(Grid_ptr[x][y].NNi-4);
	Grid_ptr[x][y].BndNorthSpline.settype(spline_type);

	/******* Assign boundary conditions for the north edge ********/
	if (edges[2] != UNDEFINED_EDGE_NUMBER) {
           bc_family_name(3,edges[2],values);
	} else {
 	   values[0] = "BC_NONE";
        } /* endif */
	Grid_ptr[x][y].BndNorthSpline.setBCtype(ICEMCFD_get_boco(values[0]));
    
	/******* Assign north boundary spline points ********/
	for (i = Grid_ptr[x][y].INl; i <= Grid_ptr[x][y].INu; i++) {
          k = i-Grid_ptr[x][y].INl;
	  Grid_ptr[x][y].BndNorthSpline.Xp[k] = Grid_ptr[x][y].Node[i][Grid_ptr[x][y].JNu].X;
	  if (i==Grid_ptr[x][y].INl || i==Grid_ptr[x][y].INu) {
             Grid_ptr[x][y].BndNorthSpline.tp[k] = SPLINE2D_POINT_SHARP_CORNER;
	  } else {
             Grid_ptr[x][y].BndNorthSpline.tp[k] = SPLINE2D_POINT_NORMAL;
          } /* endif */
	} /* endfor */
	Grid_ptr[x][y].BndNorthSpline.pathlength();
    
	// South boundary
	Grid_ptr[x][y].BndSouthSpline.allocate(Grid_ptr[x][y].NNi-4);
	Grid_ptr[x][y].BndSouthSpline.settype(spline_type);
    
	/******* Assign boundary conditions for the south edge ********/
	if (edges[0] != UNDEFINED_EDGE_NUMBER) {
           bc_family_name(3,edges[0],values);
        } else {
	   values[0] = "BC_NONE";
        } /* endif */
	Grid_ptr[x][y].BndSouthSpline.setBCtype(ICEMCFD_get_boco(values[0]));

	/******* Assign south boundary spline points ********/
	for (i = Grid_ptr[x][y].INl; i <= Grid_ptr[x][y].INu; i++) {
          k = i-Grid_ptr[x][y].INl;
	  Grid_ptr[x][y].BndSouthSpline.Xp[k] = Grid_ptr[x][y].Node[i][Grid_ptr[x][y].JNl].X;
	  if (i==Grid_ptr[x][y].INl || i==Grid_ptr[x][y].INu) {
             Grid_ptr[x][y].BndSouthSpline.tp[k] = SPLINE2D_POINT_SHARP_CORNER;
	  } else {
             Grid_ptr[x][y].BndSouthSpline.tp[k] = SPLINE2D_POINT_NORMAL;
          } /* endif */
	} /* endfor */
	Grid_ptr[x][y].BndSouthSpline.pathlength(); 
    
	// East boundary
	Grid_ptr[x][y].BndEastSpline.allocate(Grid_ptr[x][y].NNj-4);
	Grid_ptr[x][y].BndEastSpline.settype(spline_type);
    
	/******* Assign boundary conditions for the east edge ********/
	if (edges[3] != UNDEFINED_EDGE_NUMBER) {
           bc_family_name(3,edges[3],values);
        } else {
	   values[0] = "BC_NONE";
        } /* endif */
	Grid_ptr[x][y].BndEastSpline.setBCtype(ICEMCFD_get_boco(values[0]));

	/******* Assign east boundary spline points ********/
	for (j = Grid_ptr[x][y].JNl; j <= Grid_ptr[x][y].JNu; j++) {
          k = j-Grid_ptr[x][y].JNl;
	  Grid_ptr[x][y].BndEastSpline.Xp[k] = Grid_ptr[x][y].Node[Grid_ptr[x][y].INu][j].X;
	  if (j==Grid_ptr[x][y].JNl || j==Grid_ptr[x][y].JNu) {
             Grid_ptr[x][y].BndEastSpline.tp[k] = SPLINE2D_POINT_SHARP_CORNER;
	  } else {
             Grid_ptr[x][y].BndEastSpline.tp[k] = SPLINE2D_POINT_NORMAL;
          } /* endif */
	} /* endfor */
	Grid_ptr[x][y].BndEastSpline.pathlength(); 

	// West boundary
	Grid_ptr[x][y].BndWestSpline.allocate(Grid_ptr[x][y].NNj-4);
	Grid_ptr[x][y].BndWestSpline.settype(spline_type);
    
	/******* Assign boundary conditions for the west edge ********/
	if (edges[1] != UNDEFINED_EDGE_NUMBER) {
           bc_family_name(3,edges[1],values);
        } else {
	   values[0] = "BC_NONE";
        } /* endif */
	Grid_ptr[x][y].BndWestSpline.setBCtype(ICEMCFD_get_boco(values[0]));

	/******* Assign west boundary spline points ********/
	for (j = Grid_ptr[x][y].JNl; j <= Grid_ptr[x][y].JNu; j++) {
          k = j-Grid_ptr[x][y].JNl;
	  Grid_ptr[x][y].BndWestSpline.Xp[k] = Grid_ptr[x][y].Node[Grid_ptr[x][y].INl][j].X;
	  if (j==Grid_ptr[x][y].JNl || j==Grid_ptr[x][y].JNu) {
             Grid_ptr[x][y].BndWestSpline.tp[k] = SPLINE2D_POINT_SHARP_CORNER;
	  } else {
             Grid_ptr[x][y].BndWestSpline.tp[k] = SPLINE2D_POINT_NORMAL;
          } /* endif */
	} /* endfor */
    	Grid_ptr[x][y].BndWestSpline.pathlength(); 

	/****** Process the Grid *******/
	Set_BCs(Grid_ptr[x][y]);
	Update_Exterior_Nodes(Grid_ptr[x][y]);
	Update_Cells(Grid_ptr[x][y]);

      } /* endif */
    } /* endfor */
  } /* endfor */  

  /***** Return the domain layout of the mesh ******/
  *domx_buf = domxx;
  *domy_buf = domyy;
#endif

  return (Grid_ptr);

}


/*!
 * ICEMCFD_Read reads the data in the domain files from ICEMCFD
 * and stores the data in a 2D quadrilateral multiblock grid 
 * structure defined by Grid2D_Quad_MultiBlock_HO class.
 * The boundary condtions are gathered from the toplogy and 
 * boundary conditions files.
 * 
 * filenames should have 3 strings including
 * file name for the topology information,
 * by default the filename is "topo_mulcad_out".
 * the two boundary condition files which in ICEMCFD
 * v4.1 by default the names are "family_boco" and "family_topo"
 * respectively.
 * 
 * domx_buf and domy_buf are variables to hold  the number of 
 * domains in the x and y direction.
 ****************************************************************/
void ICEMCFD_Read(char **filenames,
		  Grid2D_Quad_MultiBlock_HO &MeshBlk,
		  const int & Nghost,
		  const int & HighestRecOrder,
		  int *domx_buf, 
		  int *domy_buf){

#ifdef _ICEMCFD_VERSION
  // CFD Variables
  int Ni, Nj;
  int i,j,k,x,y;
  int spline_type;

  // ICEM Variables
  int file_no,mode,type, ier;
  int coord, n_domain,n_nodes;
  char sub_name[200];
  int imin[3],imax[3];
  int jmin[3],jmax[3];
  double *node_pnts;
  char dom_name[20];

  //*************** Topology and Boundary conditions
  int ndom,nsfac,nar,nvert,nedges;
  int edges[4],tempedges[4];
  int UNDEFINED_EDGE_NUMBER = -1000;

  // boundary conditions library variables
  int ibc;
  char **values;
  char bc_temp[40];

  values = new char*[2];
  for (i=0; i<2; i++) values[i] = new char[20];

  tp_init(filenames[0]);//opens, reads, and closes the topology file.  Information is stored in memory.
  ndom=tp_ndom();
  nsfac=tp_nsfac();
  nar=tp_nar();
  nvert=tp_nvert();

  /********* Initializing Boundary conditions Library**********/
  ier = bc_init_both(filenames[1], filenames[2] ,ndom, nsfac,nar,nvert,0,0,0);  
  
  /*********getting layout of domains**********************/
  /**calls the recursive ICEMCFD_get_layout function until all the domains have been entered into a 2D array****/
  int expdom=0;//keeps track of the number of domains entered into array
  int **layout;//2D array stores domain connectivity information
  int xcor=0;
  int ycor=0;
  int smallindex=0;
  int smallest =1;
  int count=0;
  ofstream fout;

  layout = new int*[ndom+1];
  for(int i=0;i<(ndom+1);i++) layout[i]=new int[ndom+1];

  while(expdom != ndom){
    for(int i = 0; i <(ndom+1);i++){
      for(int j=0; j<(ndom+1); j++){
	layout[i][j]=0;
      }
    }
    expdom=0;
    //search for first array location where there is a domain
    if(smallest==ndom && smallest>1){
      count=0;
      smallest=1;
      if((xcor)!=ndom)
	xcor=xcor+1;
      else{
	xcor=0;
	ycor=ycor+1;
      }
    }
	
    //call recursive function until all domains are entered
    if(count==0)
      layout[xcor][ycor]=smallest;
    else{
      smallest=smallest+1;
      layout[xcor][ycor]=smallest;
    }
    if(smallest>ndom){
      cout<<"error, error"<<endl;
      exit(0);
    }
    ICEMCFD_get_layout(layout, xcor, ycor, expdom, smallest, smallindex);
    count=count+1;
  }

  //reduce the array to proper size
  int flagx, flagy;
  int domxx=ndom;
  int domyy=ndom;

  for(int i = 0; i <domxx;i++){
    flagx=0;
    for(int j = 0; j<domyy; j++){
      if(layout[i][j]!=0)
	flagx=-1;
    }
    if(flagx==0)
      domxx=i;
  }

  for(int j = 0; j <domyy;j++){
    flagy=0;
    for(int i = 0; i<domxx; i++){
      if(layout[i][j]!=0)
	flagy=-1;
    }
    if(flagy==0)
      domyy=j;
  }

  if (domxx <= 0 || domyy <= 0) MeshBlk.deallocate();

  //output the connectivity information  
  //   fout.open("icemcfd_block_connectivity.dat");
  //   fout<<"["<<domxx<<","<<domyy<<"]";
  //   for(int j = 0; j < domyy ; j++){
  //     for(int i = 0; i < domxx; i++){
  //       if(i==domxx-1 && j==domyy-1)
  //   	fout<<layout[i][j];
  //       else
  //       fout<<layout[i][j]<<",";
  //     }
  //   }
  //   fout.close();
  
  /******* Allocating memory for Multi block grid ********/
  MeshBlk.allocate(domxx,domyy);

  for (y = 0; y < domyy; y++) {
    for (x = 0; x < domxx; x++) {

      /****** Ignore if domain number is 0 *******/
      if (layout[x][y]!=0){

	sprintf(dom_name,"domain.%d",layout[x][y]);
	
        // *********** ICEM PART
	mode=MODE_READ;
	type=STRUCTURED_DOMAIN;

	// OPEN the domain file 
	file_no=df_open(dom_name, mode, type);
	if (file_no<0) {
           ICEMCFD_error();
	   MeshBlk.deallocate();
        } /* endif */
      
	// GET the number of subdomains
	ier = df_n_domain(file_no,&n_domain);
	if (ier<0) {
           ICEMCFD_error();
	   MeshBlk.deallocate();
        } /* endif */

	// Get node range
	ier = df_struct_domain_range(file_no,n_domain-1,imin,imax);
	if (ier<0) {
           ICEMCFD_error(); 
	   MeshBlk.deallocate();
        } /* endif */

	Ni=imax[0];
	Nj=imax[1];
      
	n_nodes=Ni*Nj*3;
	// READ all the nodes from ICEM domain file
	node_pnts=(double *)malloc(n_nodes*sizeof(double));

	ier=df_struct_read_nodes(file_no, n_domain-1, imin,imax, node_pnts);
	if (ier<0) {
           ICEMCFD_error();
	   MeshBlk.deallocate();
        } /* endif */

	// CLOSE the domain file
	ier=df_close(file_no);
	if (ier<0) {
           ICEMCFD_error();
	   MeshBlk.deallocate();
        } /* endif */

	//**********************
	// Find the edges numbers associated with the 
	// current domain
	//**********************
	nedges = tp_edges_of_domain(layout[x][y],tempedges);

	//***************************
	// Find the north, south, east, and west boundary edges.
	//***************************
	for (i=0; i<4; i++) {
          edges[i] = UNDEFINED_EDGE_NUMBER;
        } /* endfor */
	for (i=0; i<4; i++) {
	  ier = tp_edge_entity_range(layout[x][y], tempedges[i], jmin, jmax);
          if (ier<0) {
            ICEMCFD_error();
	    MeshBlk.deallocate();
          } /* endif */
	  if     (jmin[0]==1 && jmin[1]==1 && jmax[0]!=1 && jmax[1]==1) edges[0]=tempedges[i]; //south
	  else if(jmin[0]==1 && jmin[1]==1 && jmax[0]==1 && jmax[1]!=1) edges[1]=tempedges[i]; //west
	  else if(jmin[0]==1 && jmin[1]!=1 && jmax[0]!=1 && jmax[1]!=1) edges[2]=tempedges[i]; //north
	  else if(jmin[0]!=1 && jmin[1]==1 && jmax[0]!=1 && jmax[1]!=1) edges[3]=tempedges[i]; //east
	  else {
	    //printf("***ERROR: Can;t figure out the boundary edges!!!");
          }
	} /* endfor */

	//****** Allocate memory for current domain *********/	
	MeshBlk.Grid_ptr[x][y].allocate(Ni-1,Nj-1,Nghost,HighestRecOrder);

	// Convert 1D array of nodes into a 2D array
	for (j = MeshBlk.Grid_ptr[x][y].JNl; j <= MeshBlk.Grid_ptr[x][y].JNu; j++) {
	  for (i = MeshBlk.Grid_ptr[x][y].INl; i <= MeshBlk.Grid_ptr[x][y].INu; i++) {
	    MeshBlk.Grid_ptr[x][y].Node[i][j].X.x = node_pnts[3*(i-MeshBlk.Grid_ptr[x][y].INl+Ni*(j-MeshBlk.Grid_ptr[x][y].JNl))];
	    MeshBlk.Grid_ptr[x][y].Node[i][j].X.y = node_pnts[3*(i-MeshBlk.Grid_ptr[x][y].INl+Ni*(j-MeshBlk.Grid_ptr[x][y].JNl))+1];
	  } /* endfor */
	} /* endfor */

	//**** Specify the spline type for the edges of the domain*****/
 	spline_type = SPLINE2D_QUINTIC;
	
	// North boundary
	MeshBlk.Grid_ptr[x][y].BndNorthSpline.allocate(MeshBlk.Grid_ptr[x][y].NNi-4);
	MeshBlk.Grid_ptr[x][y].BndNorthSpline.settype(spline_type);

	/******* Assign boundary conditions for the north edge ********/
	if (edges[2] != UNDEFINED_EDGE_NUMBER) {
           bc_family_name(3,edges[2],values);
	} else {
 	   values[0] = "BC_NONE";
        } /* endif */
	MeshBlk.Grid_ptr[x][y].BndNorthSpline.setBCtype(ICEMCFD_get_boco(values[0]));
    
	/******* Assign north boundary spline points ********/
	for (i = MeshBlk.Grid_ptr[x][y].INl; i <= MeshBlk.Grid_ptr[x][y].INu; i++) {
          k = i-MeshBlk.Grid_ptr[x][y].INl;
	  MeshBlk.Grid_ptr[x][y].BndNorthSpline.Xp[k] = MeshBlk.Grid_ptr[x][y].Node[i][MeshBlk.Grid_ptr[x][y].JNu].X;
	  if (i==MeshBlk.Grid_ptr[x][y].INl || i==MeshBlk.Grid_ptr[x][y].INu) {
             MeshBlk.Grid_ptr[x][y].BndNorthSpline.tp[k] = SPLINE2D_POINT_SHARP_CORNER;
	  } else {
             MeshBlk.Grid_ptr[x][y].BndNorthSpline.tp[k] = SPLINE2D_POINT_NORMAL;
          } /* endif */
	} /* endfor */
	MeshBlk.Grid_ptr[x][y].BndNorthSpline.pathlength();
    
	// South boundary
	MeshBlk.Grid_ptr[x][y].BndSouthSpline.allocate(MeshBlk.Grid_ptr[x][y].NNi-4);
	MeshBlk.Grid_ptr[x][y].BndSouthSpline.settype(spline_type);
    
	/******* Assign boundary conditions for the south edge ********/
	if (edges[0] != UNDEFINED_EDGE_NUMBER) {
           bc_family_name(3,edges[0],values);
        } else {
	   values[0] = "BC_NONE";
        } /* endif */
	MeshBlk.Grid_ptr[x][y].BndSouthSpline.setBCtype(ICEMCFD_get_boco(values[0]));

	/******* Assign south boundary spline points ********/
	for (i = MeshBlk.Grid_ptr[x][y].INl; i <= MeshBlk.Grid_ptr[x][y].INu; i++) {
          k = i-MeshBlk.Grid_ptr[x][y].INl;
	  MeshBlk.Grid_ptr[x][y].BndSouthSpline.Xp[k] = MeshBlk.Grid_ptr[x][y].Node[i][MeshBlk.Grid_ptr[x][y].JNl].X;
	  if (i==MeshBlk.Grid_ptr[x][y].INl || i==MeshBlk.Grid_ptr[x][y].INu) {
             MeshBlk.Grid_ptr[x][y].BndSouthSpline.tp[k] = SPLINE2D_POINT_SHARP_CORNER;
	  } else {
             MeshBlk.Grid_ptr[x][y].BndSouthSpline.tp[k] = SPLINE2D_POINT_NORMAL;
          } /* endif */
	} /* endfor */
	MeshBlk.Grid_ptr[x][y].BndSouthSpline.pathlength(); 
    
	// East boundary
	MeshBlk.Grid_ptr[x][y].BndEastSpline.allocate(MeshBlk.Grid_ptr[x][y].NNj-4);
	MeshBlk.Grid_ptr[x][y].BndEastSpline.settype(spline_type);
    
	/******* Assign boundary conditions for the east edge ********/
	if (edges[3] != UNDEFINED_EDGE_NUMBER) {
           bc_family_name(3,edges[3],values);
        } else {
	   values[0] = "BC_NONE";
        } /* endif */
	MeshBlk.Grid_ptr[x][y].BndEastSpline.setBCtype(ICEMCFD_get_boco(values[0]));

	/******* Assign east boundary spline points ********/
	for (j = MeshBlk.Grid_ptr[x][y].JNl; j <= MeshBlk.Grid_ptr[x][y].JNu; j++) {
          k = j-MeshBlk.Grid_ptr[x][y].JNl;
	  MeshBlk.Grid_ptr[x][y].BndEastSpline.Xp[k] = MeshBlk.Grid_ptr[x][y].Node[MeshBlk.Grid_ptr[x][y].INu][j].X;
	  if (j==MeshBlk.Grid_ptr[x][y].JNl || j==MeshBlk.Grid_ptr[x][y].JNu) {
             MeshBlk.Grid_ptr[x][y].BndEastSpline.tp[k] = SPLINE2D_POINT_SHARP_CORNER;
	  } else {
             MeshBlk.Grid_ptr[x][y].BndEastSpline.tp[k] = SPLINE2D_POINT_NORMAL;
          } /* endif */
	} /* endfor */
	MeshBlk.Grid_ptr[x][y].BndEastSpline.pathlength(); 

	// West boundary
	MeshBlk.Grid_ptr[x][y].BndWestSpline.allocate(MeshBlk.Grid_ptr[x][y].NNj-4);
	MeshBlk.Grid_ptr[x][y].BndWestSpline.settype(spline_type);
    
	/******* Assign boundary conditions for the west edge ********/
	if (edges[1] != UNDEFINED_EDGE_NUMBER) {
           bc_family_name(3,edges[1],values);
        } else {
	   values[0] = "BC_NONE";
        } /* endif */
	MeshBlk.Grid_ptr[x][y].BndWestSpline.setBCtype(ICEMCFD_get_boco(values[0]));

	/******* Assign west boundary spline points ********/
	for (j = MeshBlk.Grid_ptr[x][y].JNl; j <= MeshBlk.Grid_ptr[x][y].JNu; j++) {
          k = j-MeshBlk.Grid_ptr[x][y].JNl;
	  MeshBlk.Grid_ptr[x][y].BndWestSpline.Xp[k] = MeshBlk.Grid_ptr[x][y].Node[MeshBlk.Grid_ptr[x][y].INl][j].X;
	  if (j==MeshBlk.Grid_ptr[x][y].JNl || j==MeshBlk.Grid_ptr[x][y].JNu) {
             MeshBlk.Grid_ptr[x][y].BndWestSpline.tp[k] = SPLINE2D_POINT_SHARP_CORNER;
	  } else {
             MeshBlk.Grid_ptr[x][y].BndWestSpline.tp[k] = SPLINE2D_POINT_NORMAL;
          } /* endif */
	} /* endfor */
    	MeshBlk.Grid_ptr[x][y].BndWestSpline.pathlength(); 

	/* Require update of the whole mesh */
	MeshBlk.Schedule_Interior_Mesh_Update();
	MeshBlk.Schedule_Ghost_Cells_Update();

	/****** Process the Grid *******/
	Set_BCs(MeshBlk.Grid_ptr[x][y]);
	Update_Exterior_Nodes(MeshBlk.Grid_ptr[x][y]);
	Update_Cells(MeshBlk.Grid_ptr[x][y]);

      } /* endif */
    } /* endfor */
  } /* endfor */  

  /***** Return the domain layout of the mesh ******/
  *domx_buf = domxx;
  *domy_buf = domyy;
#endif

}

/************
 * 3D STUFF *
 ************/

void ICEMCFD_get_layout(int ***layout, 
                        int x, 
                        int y, 
                        int z, 
                        int &expdom, 
                        int &smallest, 
                        int &smallindex){

#ifdef _ICEMCFD_VERSION
  int ier;//return value of functions
  int ndomad;//number of adjacent domains
  int domad_record[5];//array holding information regarding block connectivity

  expdom=expdom+1;
  ndomad= tp_ndom_nsub_ad(layout[x][y][z]);

  /*for each adjacent domain, there is a connecting face.  The orientation
    of the face can be deduced from the face index which is stored in
    domad_record[0].  
    1 - West
    2 - East
    3 - South
    4 - North
    5 - Bottom
    6 - Top
  */

  for(int i = 1; i<=ndomad; i++){ 
    ier=tp_domad_record( layout[x][y][z], i, domad_record);
      if(domad_record[0] == 5 && (z-1)>=0 && layout[x][y][z-1]==0 ){
	layout[x][y][z-1]=domad_record[1];
	if(layout[x][y][z-1]==(smallest+1))
	  smallest++;
	if(layout[x][y][z-1]>smallindex)
	  smallindex=layout[x][y][z-1];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y, z-1,expdom, smallest, smallindex);
      }
      
      if(domad_record[0] == 6 && layout[x][y][z+1]==0 ){
	layout[x][y][z+1]=domad_record[1];
	if(layout[x][y][z+1]==(smallest+1))
	  smallest++;
	if(layout[x][y][z+1]>smallindex)
	  smallindex=layout[x][y][z+1];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y, z+1,expdom, smallest, smallindex);
      } 

      if(domad_record[0] == 1 && (x-1)>=0 && layout[x-1][y][z]==0 ){
	layout[x-1][y][z]=domad_record[1];
	if(layout[x-1][y][z]==(smallest+1))
	  smallest++;
	if(layout[x-1][y][z]>smallindex)
	  smallindex=layout[x-1][y][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x-1, y, z, expdom, smallest, smallindex);
      }

      if(domad_record[0] == 2 && layout[x+1][y][z]==0 ){
	layout[x+1][y][z]=domad_record[1];
	if(layout[x+1][y][z]==(smallest+1))
	  smallest++;
	if(layout[x+1][y][z]>smallindex)
	  smallindex=layout[x+1][y][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x+1, y, z, expdom, smallest, smallindex);
      }

      if(domad_record[0] == 3 && (y-1)>=0 && layout[x][y-1][z]==0 ){
	layout[x][y-1][z]=domad_record[1];
	if(layout[x][y-1][z]==(smallest+1))
	  smallest++;
	if(layout[x][y-1][z]>smallindex)
	  smallindex=layout[x][y-1][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y-1, z,expdom, smallest, smallindex);
      }

      if(domad_record[0] == 4 && layout[x][y+1][z]==0 ){
	layout[x][y+1][z]=domad_record[1];
	if(layout[x][y+1][z]==(smallest+1))
	  smallest++;
	if(layout[x][y+1][z]>smallindex)
	  smallindex=layout[x][y+1][z];
	if((smallest+1)==smallindex)
	  smallest=smallest+1;
	ICEMCFD_get_layout(layout, x, y+1, z, expdom, smallest, smallindex);
      }
  }
#endif
}

/********************************************************
ICEMCFD_Read reads the data in the domain files from ICEMCFD
and stores the data in a 3D hexahedral multiblock grid 
structure defined by Grid3D_Hexa_Block class. The Boundary 
condtions are gathered from the toplogy and boundary 
conditions files.
                
filenames should have 3 strings including
file name for the topology information,
by default the filename is "topo_mulcad_out".
the two boundary condition files which in ICEMCFD
v4.1 by default the names are "family_boco" and "family_topo"
respectively.

domx_buf, domy_buf and domz_buf are variables to hold the number of 
domains in the x,y, and z directions.
********************************************************/

Grid3D_Hexa_Block*** ICEMCFD_Read(char **filenames,
                                  Grid3D_Hexa_Block ***Grid_ptr,
                                  int *domx_buf, 
                                  int *domy_buf,
			 	  int *domz_buf){

#ifdef _ICEMCFD_VERSION
  // CFD Variables
  int Ni, Nj, Nk;
  int i,j,k,x,y,z;
  int spline_type;
  int domxx,domyy, domzz;
  int Nghost = 2;//initializing number of nghost cells

  // ICEM Variables
  int file_no,mode,type, ier;
  int coord, n_domain,n_nodes;
  char sub_name[200];
  int imin[3],imax[3];
  int jmin[3],jmax[3];
  double *node_pnts;

  // Get domain layout in a multi grid environment
  char dom_name[20];
  char temp[20];

  //*************** Topology and Boundary conditions
  int ndom,nsfac,nar,nvert,nedges;
  int edges[4],tempedges[4];
  int UNDEFINED_EDGE_NUMBER = -1000;

  // boundary conditions library variables
  int ibc;
  char **values;
  char bc_temp[40];

  values = new char*[2];
  for (i=0; i<2; i++) values[i] = new char[20];

  tp_init(filenames[0]);//opens, reads, and closes the topology file.  Information is stored in memory.
  ndom=tp_ndom();
  nsfac=tp_nsfac();
  nar=tp_nar();
  nvert=tp_nvert();

  /********* Initializing Boundary conditions Library**********/
  ier = bc_init_both(filenames[1], filenames[2] ,ndom, nsfac,nar,nvert,0,0,0);  
  
  /*********getting layout without input**********************/
  /**calls the recursive ICEMCFD_get_layout function until all the domains have been entered into matrix****/
  int smallest=1;
  int expdom=0;
  int ***layout;
  int xcor=0;
  int ycor=0;
  int zcor=0;
  int smallindex=0;
  int count=0;

  //create 3D array to store domain connectivity information
  layout = new int**[ndom+1];
  for(int i=0; i<(ndom+1);i++){
    layout[i]=new int*[ndom+1];
    for(int j=0; j<(ndom+1); j++){
      layout[i][j]=new int[ndom+1];
    }
  }
  //call the recursive function until the number of explored domains equals the number of domains
  while(expdom != ndom){
    //clear 3D array
    for(int i = 0; i <(ndom+1);i++){
      for(int j = 0 ; j<(ndom+1); j++){
	for(int k = 0 ; k<(ndom+1); k++) {
	  layout[i][j][k]=0;
	}
      }
    }
    expdom=0;
    //search for the first array location with a domain*/
    if(smallest==ndom && smallest!=1){
      count = 0 ;
      smallest = 1;
      if(xcor!=ndom && ycor==0 && zcor ==0)
	xcor = xcor +1;
      else if(ycor!=ndom && zcor==0)
	ycor = ycor +1;
      else if(zcor !=ndom)
	zcor = zcor +1;
    }
    
    if(count==0)
      layout[xcor][ycor][zcor]=smallest;
    else{
      smallest=smallest+1;
      layout[xcor][ycor][zcor]=smallest;
    }
    ICEMCFD_get_layout(layout, xcor, ycor, zcor, expdom, smallest, smallindex);
    count=count+1;
  }

  /*reduce the array to proper size*/
  int flagx, flagy, flagz;
  domxx=ndom;
  domyy=ndom;
  domzz=ndom;

  for(int k = 0; k <domzz ; k++){
    flagz=0;
    for(int j = 0; j < domyy ; j++){
      for(int i =0 ; i < domxx ; i++) {
	if(layout[i][j][k]!=0)
	  flagz=-1;
      }
    }
    if(flagz==0)
      domzz=k;
  }

  for(int j = 0; j <domyy ; j++){
    flagy=0;
    for(int k = 0; k < domzz ; k++){
      for(int i =0 ; i < domxx ; i++) {
	if(layout[i][j][k]!=0)
	  flagy=-1;
      }
    }
    if(flagy==0)
      domyy=j;
  }

  for(int i = 0; i <domxx ; i++){
    flagx=0;
    for(int j = 0; j < domyy ; j++){
      for(int k =0 ; k < domzz ; k++) {
	if(layout[i][j][k]!=0)
	  flagx=-1;
      }
    }
    if(flagx==0)
      domxx=i;
  }
  
  //for(int k=0; k < domzz; k++){
  //  for(int j=0; j < domyy; j++){
  //    for(int i=0; i < domxx; i++){
  //	cout<<layout[i][j][k]<<" ";
  //    }
  //  }
  //}
  
  if (domxx <= 0 || domyy <= 0 || domzz <= 0) return(NULL);

  /******* Allocating memory for Multi block grid ********/
  Grid_ptr = Allocate_Multi_Block_Grid(Grid_ptr, domxx, domyy, domzz);  

  for(int z =0; z < domzz; z++){
    for (int y = 0; y < domyy; y++) {
      for (int x = 0; x < domxx; x++) {
	
	/****** Ignore if domain number is 0 *******/
	if (layout[x][y][z]!=0){

	sprintf(dom_name,"domain.%d",layout[x][y][z]);
	
        // *********** ICEM PART
	mode=MODE_READ;
	type=STRUCTURED_DOMAIN;

	// OPEN the domain file 
	file_no=df_open(dom_name, mode, type);
	if (file_no<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */
      
	// GET the number of subdomains
	ier = df_n_domain(file_no,&n_domain);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	// Get node range
	ier = df_struct_domain_range(file_no,n_domain-1,imin,imax);
	if (ier<0) {
           ICEMCFD_error(); 
           return (NULL);
        } /* endif */

	Ni=imax[0];
	Nj=imax[1];
	Nk=imax[2];
      
	
	n_nodes=Ni*Nj*Nk*3;

	// READ all the nodes from ICEM domain file
	node_pnts=(double *)malloc(n_nodes*sizeof(double));

	ier=df_struct_read_nodes(file_no, n_domain-1, imin,imax, node_pnts);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	// CLOSE the domain file
	ier=df_close(file_no);
	if (ier<0) {
           ICEMCFD_error();
           return (NULL);
        } /* endif */

	
	//****** Allocate memory for current domain *********/	
	Grid_ptr[x][y][z].allocate(Ni-1,Nj-1,Nk-1,Nghost);

	// Convert 1D array of nodes into a 3D array
	for ( int k = Grid_ptr[x][y][z].KNl; k <= Grid_ptr[x][y][z].KNu; k++) {
	  for (int j =  Grid_ptr[x][y][z].JNl; j <= Grid_ptr[x][y][z].JNu; j++) {
	    for (int i = Grid_ptr[x][y][z].INl; i <= Grid_ptr[x][y][z].INu; i++) {
	      Grid_ptr[x][y][z].Node[i][j][k].X.x = node_pnts[3*(i-Grid_ptr[x][y][z].INl+
								 Ni*(j-Grid_ptr[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_ptr[x][y][z].KNl))+0];
	      Grid_ptr[x][y][z].Node[i][j][k].X.y = node_pnts[3*(i-Grid_ptr[x][y][z].INl+
								 Ni*(j-Grid_ptr[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_ptr[x][y][z].KNl))+1];
	      Grid_ptr[x][y][z].Node[i][j][k].X.z = node_pnts[3*(i-Grid_ptr[x][y][z].INl+
								 Ni*(j-Grid_ptr[x][y][z].JNl)+
								 Ni*Nj*(k-Grid_ptr[x][y][z].KNl))+2];
	    } /* endfor */
	  } /* endfor */
	}/* endfor */
	
	
	
	/****** Process the Grid *******/
	Update_Cells(Grid_ptr[x][y][z]);
	
	} /* endif */
      } /* endfor */
    } /* endfor */
  } /* endor */  
    
  /***** Return the domain layout of the mesh ******/
  *domx_buf = domxx;
  *domy_buf = domyy;
  *domz_buf = domzz;
#endif
  
  return (Grid_ptr);
  
}
