/*! \file NavierStokes2DQuad_HighOrder.cc
  @brief High-order Subroutines for 2D Euler Equations Quadrilateral Mesh Solution Classes. */

/* Include required C++ libraries. */
// None

/* Using std namespace functions */
// None

/* Include CFFC header files */
#include "NavierStokes2DQuad.h"	// NavierStokes2D_Quad_Block class

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the nodes of the defined region of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 *
 * \param StartI_CellIndex index of the first cell in i-direction used to output the solution
 * \param EndI_CellIndex index of the last cell in i-direction used to output the solution
 * \param StartJ_CellIndex index of the first cell in j-direction used to output the solution
 * \param EndJ_CellIndex index of the last cell in j-direction used to output the solution
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 */
void NavierStokes2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							       const double &Time,
							       const int &Block_Number,
							       const int &Output_Title,
							       ostream &Out_File,
							       const int & StartI_CellIndex,
							       const int & EndI_CellIndex,
							       const int & StartJ_CellIndex,
							       const int & EndJ_CellIndex,
							       const int &IndexHO) {
  // Nothing
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the interior nodes of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 *
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void NavierStokes2D_Quad_Block::Output_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							 const double &Time,
							 const int &Block_Number,
							 const int &Output_Title,
							 ostream &Out_File,
							 const int &IndexHO) {

  return Output_Nodes_Tecplot_HighOrder(Number_of_Time_Steps,
					Time,
					Block_Number,
					Output_Title,
					Out_File,
					ICl, ICu, JCl, JCu,
					IndexHO);
}

/*!
 * Writes the solution values at the interior nodes of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note This subroutine is only used for debugging!
 */
void NavierStokes2D_Quad_Block::Output_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								    const NavierStokes2D_Input_Parameters &IP,
								    const int &Block_Number,
								    const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  
  /* Open the output data file. */
  
  output_file.open(output_file_name, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }
  
  try {
    Output_Tecplot_HighOrder(0,0,
			     Block_Number,
			     1,
			     output_file,
			     IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }

  /* Close the output data file. */
  output_file.close();

  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all nodes (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 */
void NavierStokes2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							const double &Time,
							const int &Block_Number,
							const int &Output_Title,
							ostream &Out_File,
							const int &IndexHO) {

  return Output_Nodes_Tecplot_HighOrder(Number_of_Time_Steps,
					Time,
					Block_Number,
					Output_Title,
					Out_File,
					ICl - HighOrderVariable(IndexHO).NghostHO(),
					ICu + HighOrderVariable(IndexHO).NghostHO(),
					JCl - HighOrderVariable(IndexHO).NghostHO(),
					JCu + HighOrderVariable(IndexHO).NghostHO(),
					IndexHO);
}

/*!
 * Writes the solution values at the nodes (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void NavierStokes2D_Quad_Block::Output_Nodes_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									  const NavierStokes2D_Input_Parameters &IP,
									  const int &Block_Number,
									  const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_nodes_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Nodes_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Nodes_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all cells (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void NavierStokes2D_Quad_Block::Output_Cells_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							       const double &Time,
							       const int &Block_Number,
							       const int &Output_Title,
							       ostream &Out_File,
							       const int &IndexHO) {
  // Nothing
}

/*!
 * Writes the solution values at the centroids (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost cells for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void NavierStokes2D_Quad_Block::Output_Cells_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									  const NavierStokes2D_Input_Parameters &IP,
									  const int &Block_Number,
									  const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cells_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Cells_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Cells_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Evaluate the residual for the solution block 
 * using the high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 * The residual is stored in dUdt[][][k_residual].
 *
 * \param IP  input parameters object
 * \param Pos index to identify the high-order variable used to calculate the residual
 * \param k_residual index to identify the residual storage location
 *
 */
int NavierStokes2D_Quad_Block::dUdt_Residual_HighOrder(const NavierStokes2D_Input_Parameters &IP,
						const int & k_residual,
						const bool & UseTimeStep,
						const unsigned short int Pos){
  // Nothing
}

/*!
 * Evaluate the residual for the solution block 
 * using a high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 * The residual is stored in dUdt[][][0].               
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *                                                      
 */
int NavierStokes2D_Quad_Block::dUdt_Residual_Evaluation_HighOrder(const NavierStokes2D_Input_Parameters &IP,
								  const unsigned short int Pos){

  int i,j;
  
  // ************* Step 1. (Re)-Set residual for k_residual=0 to zero in all affected cells **************
  // *****************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ) {
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {
      dUdt[i][j][0].Vacuum();  // set to zero
    } // endfor (i)
  } // endfor (j)

  // ** Step 2. Compute high-order spatial residual and write it to k_residual = 0 **
  // ********************************************************************************
  return dUdt_Residual_HighOrder(IP, 0, false, Pos);
}


/*!
 * This routine determines the solution residuals for a 
 * given stage of a variety of multi-stage explicit     
 * time integration schemes for the solution block.
 * The solution residuals are evaluated  
 * using a high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *
 */
int NavierStokes2D_Quad_Block::dUdt_Multistage_Explicit_HighOrder(const int &i_stage,
								  const NavierStokes2D_Input_Parameters &IP,
								  const unsigned short int Pos) {
  // SET VARIABLES USED IN THE RESIDUAL CALCULATION PROCESS

  int i, j, k_residual;

  /* Evaluate the solution residual for stage 
     i_stage of an N stage scheme. */

  /* Evaluate the time step fraction and residual storage location for the stage. */
  
  switch(IP.i_Time_Integration) {
  case TIME_STEPPING_EXPLICIT_EULER :
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
    k_residual = 0;
    if (IP.N_Stage == 4) {
      if (i_stage == 4) {
	k_residual = 0;
      } else {
	k_residual = i_stage - 1;
      } /* endif */
    } /* endif */
    break;
  case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
    k_residual = 0;
    break;
  default:
    k_residual = 0;
  } /* endswitch */


  // ************* Step 1. (Re)-Set parameters in all affected cells based on the time integration scheme **************
  // *******************************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ){
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {

      if ( i_stage == 1 ){
	Uo[i][j] = U[i][j];
	dUdt[i][j][k_residual].Vacuum();  // set to zero
      } else {
	switch(IP.i_Time_Integration) {
	case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
	  // 
	  break;
	case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
	  if (IP.N_Stage == 2) {
	    // 
	  } else if (IP.N_Stage == 4 && i_stage == 4) {
	    dUdt[i][j][k_residual] = ( dUdt[i][j][0] + 
				       TWO*dUdt[i][j][1] +
				       TWO*dUdt[i][j][2] );
	  } else {
	    dUdt[i][j][k_residual].Vacuum();  // set to zero
	  } /* endif */
	  break;
	case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	default:
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	} /* endswitch */
      }/* endif */

    } // endfor (i)
  } // endfor (j)


  // ** Step 2. Compute high-order spatial residual for the current time step fraction **
  // ************************************************************************************
  return dUdt_Residual_HighOrder(IP, k_residual, true, Pos);
}

/*!
 * Compute the solution state for evaluating the inviscid flux 
 * at a boundary interface such that to satisfy the 
 * required boundary conditions.
 * This routine works in conjunction with the high-order
 * implementation.
 * 
 * \param  BOUNDARY boundary position specifier (i.e. WEST, EAST, SOUTH or NORTH)
 * \param  ii       i-index of the cell in which the calculation is done
 * \param  jj       j-index of the cell in which the calculation is done
 * \param  Wl       the left interface state 
 * \param  Wr       the right interface state 
 * \param CalculationPoint the flux calculation point
 * \param NormalDirection the normal direction at the calculation point
 *
 * \return The solution state which is required to calculate the inviscid flux with 
 *         such that to satisfy the boundary condition.
 *
 * \todo Change the reference values to the high-order ones for some BCs!
 */
void NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder(const int &BOUNDARY,
									  const int &ii, const int &jj,
									  NavierStokes2D_pState &Wl,
									  NavierStokes2D_pState &Wr,
									  const Vector2D &CalculationPoint,
									  const Vector2D &NormalDirection,
									  const unsigned short int Pos) const {

  switch(BOUNDARY){

    // *******************************
    // === WEST boundary interface ===
    // *******************************
  case WEST :			
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeW[jj]){

    case BC_NONE :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;

    case BC_FROZEN :
      // Calculate Wr based on the reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;

    case BC_FARFIELD :
      // Setup value as in the case of Dirichlet BC
      
    case BC_DIRICHLET :		// BC_FIXED
      // Set Wr to the reference value for the given location
      // Note: The reference value should be changed to HO_WoW!
      Wr = WoW[jj];
      break;
      
    case BC_EXACT_SOLUTION :
      // Calculate W_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Wr = BC_Characteristic_Pressure(Wl,
					ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y),
					NormalDirection);
      } else {
	throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN :
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
      break;

    case BC_SYMMETRY_PLANE : 	// same as BC_REFLECTION
      Wr = Reflect(Wl, NormalDirection);
      break;

    case BC_WALL_INVISCID : 	// same as BC_REFLECTION
      Wr = Reflect(Wl, NormalDirection);
      break;

    case BC_EXTRAPOLATE :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      // Calculate Wr based on the reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii-1,jj,CalculationPoint);
      break;

    case BC_OUTFLOW :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CHARACTERISTIC :
      // Set Wr based on the directions of propogation for the solution characteristics at the boundary
      // Note: The reference value should be changed to HO_WoW!
      Wr = BC_Characteristic_Pressure(Wl,
				      WoW[jj],
				      NormalDirection);
      break;

    default:
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such West BCtype!");
    }// endswitch (Grid.BCtypeW[jj])
    break;


    // *******************************
    // === EAST boundary interface ===
    // *******************************
  case EAST :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeE[jj]){

    case BC_NONE :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;
      
    case BC_FARFIELD :
      // Setup value as in the case of Dirichlet BC

    case BC_DIRICHLET :		// BC_FIXED
      // Set Wr to the reference value for the given location
      // Note: The reference value should be changed to HO_WoE!
      Wr = WoE[jj];
      break;

    case BC_EXACT_SOLUTION :
      // Calculate W_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Wr = BC_Characteristic_Pressure(Wl,
					ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y),
					NormalDirection);
      } else {
	throw runtime_error("AdvectDiffuse2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
      break;

    case BC_SYMMETRY_PLANE : 	// same as BC_REFLECTION
      Wr = Reflect(Wl, NormalDirection);
      break;

    case BC_WALL_INVISCID : 	// same as BC_REFLECTION
      Wr = Reflect(Wl, NormalDirection);
      break;

    case BC_EXTRAPOLATE :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii+1,jj,CalculationPoint);
      break;

    case BC_OUTFLOW :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;
      
    case BC_CHARACTERISTIC :
      // Set Wr based on the directions of propogation for the solution characteristics at the boundary
      // Note: The reference value should be changed to HO_WoE!
      Wr = BC_Characteristic_Pressure(Wl,
				      WoE[jj],
				      NormalDirection);
      break;

    default:
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such East BCtype!");
    }// endswitch (Grid.BCtypeE[jj])
    break;

    // ********************************
    // === SOUTH boundary interface ===
    // ********************************
  case SOUTH :
    // Compute left interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeS[ii]){

    case BC_NONE :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Wr based on the reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;

    case BC_FARFIELD :
      // Setup value as in the case of Dirichlet BC
      
    case BC_DIRICHLET :		// BC_FIXED
      // Set Wr to the reference value for the given location
      // Note: The reference value should be changed to HO_WoS!
      Wr = WoS[ii];
      break;

    case BC_EXACT_SOLUTION :
      // Calculate W_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Wr = BC_Characteristic_Pressure(Wl,
					ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y),
					NormalDirection);
      } else {
	throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
      break;

    case BC_SYMMETRY_PLANE : 	// same as BC_REFLECTION
      Wr = Reflect(Wl, NormalDirection);
      break;

    case BC_WALL_INVISCID : 	// same as BC_REFLECTION
      Wr = Reflect(Wl, NormalDirection);
      break;

    case BC_EXTRAPOLATE :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj-1,CalculationPoint);
      break;

    case BC_OUTFLOW :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;
      
    case BC_CHARACTERISTIC :
      // Set Wr based on the directions of propogation for the solution characteristics at the boundary
      // Note: The reference value should be changed to HO_WoS!
      Wr = BC_Characteristic_Pressure(Wl,
				      WoS[ii],
				      NormalDirection);
      break;

    default:
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such South BCtype!");
    }// endswitch (Grid.BCtypeS[ii])
    break;

    // ********************************
    // === NORTH boundary interface ===
    // ********************************
  case NORTH :
    // Compute right interface state based on reconstruction or the particular boundary condition
    switch (Grid.BCtypeN[ii]){

    case BC_NONE :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;

    case BC_PERIODIC :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;

    case BC_FROZEN :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;
      
    case BC_FARFIELD :
      // Setup value as in the case of Dirichlet BC

    case BC_DIRICHLET :		// BC_FIXED
      // Set Wr to the reference value for the given location
      // Note: The reference value should be changed to HO_WoN!
      Wr = WoN[ii];
      break;
      
    case BC_EXACT_SOLUTION :
      // Calculate W_face based on the exact solution
      if (ExactSoln->IsExactSolutionSet()){
	Wr = BC_Characteristic_Pressure(Wl,
					ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y),
					NormalDirection);
      } else {
	throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
      }
      break;
      
    case BC_NEUMANN : 
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
      break;

    case BC_SYMMETRY_PLANE : 	// same as BC_REFLECTION
      Wr = Reflect(Wl, NormalDirection);
      break;

    case BC_WALL_INVISCID : 	// same as BC_REFLECTION
      Wr = Reflect(Wl, NormalDirection);
      break;

    case BC_EXTRAPOLATE :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_LINEAR_EXTRAPOLATION :
      // Compute Wr based on the high-order reconstruction in the ghost cell
      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ii,jj+1,CalculationPoint);
      break;

    case BC_OUTFLOW :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CONSTANT_EXTRAPOLATION :
      // Set Wr equal to the left side value (i.e Wl)
      Wr = Wl;
      break;

    case BC_CHARACTERISTIC :
      // Set Wr based on the directions of propogation for the solution characteristics at the boundary
      // Note: The reference value should be changed to HO_WoN!
      Wr = BC_Characteristic_Pressure(Wl,
				      WoN[ii],
				      NormalDirection);
      break;
      
    default:
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such North BCtype!");
    }// endswitch (Grid.BCtypeN[ii])
    break;

  default:
    throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such boundary!");
  }  

}

/*!
 * Set high-order boundary conditions.
 */
void NavierStokes2D_Quad_Block::BCs_HighOrder(void){
  // Nothing
}

/*!
 * Calculate refinement criteria for AMR
 * based on the CENO smoothness indicator.
 */
void NavierStokes2D_Quad_Block::Calculate_Refinement_Criteria_HighOrder(double *refinement_criteria,
									NavierStokes2D_Input_Parameters &IP,
									int &number_refinement_criteria){
  
  number_refinement_criteria = 1;

  /* Allocate memory for the refinement criteria */
  Refinement_Criteria().reserve(number_refinement_criteria);
  
  /* Return the refinement criteria. */
  refinement_criteria[0] = HighOrderVariable(0).AMR_Criteria_Based_On_Minimum_Smoothness_Indicator(*this);

  /* Store the refinement_criteria values in the solution block designated variable */
  Refinement_Criterion(0) = refinement_criteria[0];

}

/*!
 * Set physical boundary condition constraints based on
 * the current flow state and the BC_Type.
 */
void NavierStokes2D_Quad_Block::EnsurePhysicalBCsConstraints(const int & BOUNDARY, const int & BndCellIndex){
  // Nothing
}
