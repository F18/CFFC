/*! \file NavierStokes2DQuad_HighOrder.cc
  @brief High-order Subroutines for 2D Euler Equations Quadrilateral Mesh Solution Classes. */

/* Include required C++ libraries. */
// None

/* Using std namespace functions */
// None

/* Include CFFC header files */
#include "NavierStokes2DQuad.h"	// NavierStokes2D_Quad_Block class

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the nodes of the defined region of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * This subroutine uses an increased resolution 
 * (i.e. 9 values/cell) in order to generate a more accurate
 * profile of the high-order solution representation.
 *
 * \param StartI_CellIndex index of the first cell in i-direction used to output the solution
 * \param EndI_CellIndex index of the last cell in i-direction used to output the solution
 * \param StartJ_CellIndex index of the first cell in j-direction used to output the solution
 * \param EndJ_CellIndex index of the last cell in j-direction used to output the solution
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 */
void NavierStokes2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const NavierStokes2D_Input_Parameters &IP,
							       const int &Number_of_Time_Steps,
							       const double &Time,
							       const int &Block_Number,
							       const int &Output_Title,
							       ostream &Out_File,
							       const int & StartI_CellIndex,
							       const int & EndI_CellIndex,
							       const int & StartJ_CellIndex,
							       const int & EndJ_CellIndex,
							       const int &IndexHO) {

  int i, j, nRow, nLoop;
  NavierStokes2D_pState W_node;
  Vector2D Node;
  int Index_GQP(Spline2DInterval_HO::get_NumGQPoints_ContourIntegral()/2 + 1);

  if (NumberOfHighOrderVariables <= IndexHO){
    throw runtime_error("NavierStokes2D_Quad_Block::Output_Nodes_Tecplot_HighOrder() ERROR! High-order object index out of range!");
  }

  /* Output node solution data. */

  Out_File << setprecision(14);
  if (Output_Title) {
    // Set the Brief format
    Out_File << "TITLE = \"" << CFFC_Name() << ": 2D NavierStokes Solution, "
	     << "Time Step/Iteration Level = " << Number_of_Time_Steps
	     << ", Time = " << Time
	     << "\"" << "\n"
	     << "VARIABLES = \"x\" \\ \n"
	     << "\"y\" \\ \n"
	     << "\"rho\" \\ \n"
	     << "\"u\" \\ \n"
	     << "\"v\" \\ \n"
	     << "\"p\" \\ \n";

    // Add more variables for the Detailed format
    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
      Out_File << "\"T\" \n"
	       << "\"M\" \n"
	       << "\"H\" \n"
	       << "\"s\" \n";
    }

    // Add more variables for turbulent flows
    if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
      
      // Add to Brief format
      Out_File << "\"k\" \\ \n"
	       << "\"omega\" \\ \n";


      // Add more variables for the Detailed format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "\"epsilon\" \\ \n"
		 << "\"ell\" \\ \n"
		 << "\"p_modified\" \\ \n"
		 << "\"PrT\" \\ \n"
		 << "\"yplus\" \\ \n";
      }

      // Add to Brief format and variable Prandtl number
      if (Variable_Prandtl == ON) {
	Out_File << "\"ke\" \\ \n"
		 << "\"ee\" \\ \n";
      }
    }

    // Output Reynolds number along x direction
    if (Tecplot_Execution_Mode::IsDetailedOutputRequired() && Flow_Type != FLOWTYPE_INVISCID){
      Out_File << "\"Re_x\" \\ \n";
    }

    // Add more variables for the Full format
    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
      Out_File << "\"ValISrho\" \\ \n"
	       << "\"ISrho\" \\ \n"
	       << "\"ValISu\" \\ \n"
	       << "\"ISu\" \\ \n"
	       << "\"ValISv\" \\ \n"
	       << "\"ISv\" \\ \n"
	       << "\"ValISp\" \\ \n"
	       << "\"ISp\" \\ \n";

      // Add more variables for turbulent flows
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	Out_File << "\"ValISk\" \\ \n"
		 << "\"ISk\" \\ \n"
		 << "\"ValISomega\" \\ \n"
		 << "\"ISomega\" \\ \n";

	if (Variable_Prandtl == ON){
	  Out_File << "\"ValISke\" \\ \n"
		   << "\"ISke\" \\ \n"
		   << "\"ValISee\" \\ \n"
		   << "\"ISee\" \\ \n";
	}
      }

      if (ExactSoln->IsExactSolutionSet()){
	ExactSoln->Output_Tecplot_Title(Out_File);
      }
    }

    // Add more variables for the Extended format
    if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
      Out_File << "\"ResidualRho\" \\ \n"
	       << "\"ResidualDvX\" \\ \n"
	       << "\"ResidualDvY\" \\ \n"
	       << "\"ResidualE\" \\ \n";

      // Add more variables for turbulent flows
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	Out_File << "\"Residualdk\" \\ \n"
		 << "\"Residualdomega\" \\ \n";

	if (Variable_Prandtl == ON){
	  Out_File << "\"Residualdke\" \\ \n"
		   << "\"Residualdee\" \\ \n";
	}
      }
    } /* endif */

  } /* endif */

  Out_File << "ZONE T =  \"Block Number = " << Block_Number
	   << "\" \\ \n"
	   << "I = " << (EndI_CellIndex - StartI_CellIndex + 1)*3  << " \\ \n"
	   << "J = " << (EndJ_CellIndex - StartJ_CellIndex + 1)*3 << " \\ \n"
	   << "F = POINT \n";


  // Set the accuracy properly
  if (Tecplot_Execution_Mode::IsDoublePrecision()){
    Out_File << "DT = (DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

    // Detail format
    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
      Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
    }

    // Add more variables for turbulent flows
    if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
      // Brief format
      Out_File << "DOUBLE DOUBLE ";

      // Detail format
      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";
      }

      // Brief format and variable Prandtl number
      if (Variable_Prandtl == ON) {
	Out_File << "DOUBLE DOUBLE ";
      }
    }

    // Output Reynolds number along x direction
    if (Tecplot_Execution_Mode::IsDetailedOutputRequired() && Flow_Type != FLOWTYPE_INVISCID){
      Out_File << "DOUBLE ";
    }

    // Full format
    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
      Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT ";

      // Add more variables for turbulent flows
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT ";

	if (Variable_Prandtl == ON){
	  Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT ";
	}
      }

      if (ExactSoln->IsExactSolutionSet()){
	ExactSoln->Output_Tecplot_Double_Precision(Out_File);
      }
    }

    // Extended format
    if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
      Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";

      // Add more variables for turbulent flows
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	Out_File << "DOUBLE DOUBLE ";

	if (Variable_Prandtl == ON){
	  Out_File << "DOUBLE DOUBLE ";
	}
      }    
    }

    // Close line
    Out_File << " ) \n";
  } // endif (DoublePrecision)


    // Output data
  for ( j  = StartJ_CellIndex ; j <= EndJ_CellIndex ; ++j ) {	// for every j Cell
    for ( nRow = 1; nRow <= 3; ++nRow){ // for 3 rows of nodes
      for ( i = StartI_CellIndex ; i <= EndI_CellIndex ; ++i ) { // for every i Cell
	for (nLoop = 1; nLoop <= 3; ++nLoop){	// for every node
	  // Get the node location
	  switch(nRow){
	  case 1: // output the 1st row of nodes (i.e. NodeSW(i,j), xfaceS(i,j), NodeSE(i,j))
	    switch(nLoop){
	    case 1:		// output NodeSW(i,j)
	      Node = Grid.nodeSW(i,j).X;
	      break;
	    case 2:		// output xfaceS(i,j) or BndSouthSplineInfo[i].GQPointContourIntegral(Index_GQP)
	      if(j == JCl && Grid.BndSouthSplineInfo != NULL && i>= ICl && i<= ICu ){
		Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(Index_GQP);
	      } else if (j == JCu+1 && Grid.BndNorthSplineInfo != NULL & i>= ICl && i<= ICu ){
		Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(Index_GQP);
	      } else {
		Node = Grid.xfaceS(i,j);
	      }
	      break;
	    case 3:		// output NodeSE(i,j)
	      Node = Grid.nodeSE(i,j).X;
	      break;
	    }
	    break;

	  case 2: // output the 2nd row of nodes (i.e. xfaceW(i,j), Grid.CellCentroid(i,j), xfaceE(i,j))
	    switch(nLoop){
	    case 1:		// output xfaceW(i,j) or BndWestSplineInfo[j].GQPointContourIntegral(Index_GQP)
	      if (i == ICl && Grid.BndWestSplineInfo != NULL && j>=JCl && j<=JCu ){
		Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(Index_GQP);
	      } else if (i == ICu+1 && Grid.BndEastSplineInfo != NULL && j>=JCl && j<=JCu) {
		Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(Index_GQP);
	      } else {
		Node = Grid.xfaceW(i,j);
	      }
	      break;
	    case 2:		// output Grid.CellCentroid(i,j)
	      Node = Grid.CellCentroid(i,j);
	      break;
	    case 3:		// output xfaceE(i,j) or BndEastSplineInfo[j].GQPointContourIntegral(Index_GQP)
	      if (i == ICu && Grid.BndEastSplineInfo != NULL && j>=JCl && j<=JCu ){
		Node = Grid.BndEastSplineInfo[j].GQPointContourIntegral(Index_GQP);
	      } else if (i == ICl-1 && Grid.BndWestSplineInfo != NULL && j>=JCl && j<=JCu ) { 
		Node = Grid.BndWestSplineInfo[j].GQPointContourIntegral(Index_GQP);
	      } else {
		Node = Grid.xfaceE(i,j);
	      }
	      break;
	    }
	    break;

	  case 3: // output the 3rd row of nodes (i.e. NodeNW(i,j), xfaceN(i,j), NodeNE(i,j))
	    switch(nLoop){
	    case 1:		// output NodeNW(i,j)
	      Node = Grid.nodeNW(i,j).X;
	      break;
	    case 2:		// output xfaceN(i,j) or BndNorthSplineInfo[i].GQPointContourIntegral(Index_GQP)
	      if(j == JCu && Grid.BndNorthSplineInfo != NULL  && i>= ICl && i<= ICu ){
		Node = Grid.BndNorthSplineInfo[i].GQPointContourIntegral(Index_GQP);
	      } else if (j == JCl-1 && Grid.BndSouthSplineInfo != NULL && i>= ICl && i<= ICu ) {
		Node = Grid.BndSouthSplineInfo[i].GQPointContourIntegral(Index_GQP);
	      } else {
		Node = Grid.xfaceN(i,j);
	      }
	      break;
	    case 3:		// output NodeNE(i,j)
	      Node = Grid.nodeNE(i,j).X;
	      break;
	    }
	    break;
	  } // endswitch

	  if (i < ICl-HighOrderVariable(IndexHO).NghostHO() || 
	      i > ICu+HighOrderVariable(IndexHO).NghostHO() || 
	      j < JCl-HighOrderVariable(IndexHO).NghostHO() ||
	      j > JCu+HighOrderVariable(IndexHO).NghostHO()  ) {
	    
	    // No high-order interpolant is calculated for this cells.
	    // The average solution is plotted at the nodes of these cells.
	    
	    // Output Brief format
	    W_node = CellSolution(i,j);
	    Out_File << " "  << Node 
		     << " "  << W_node.rho
		     << " "  << W_node.v
		     << " "  << W_node.p;

	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File.setf(ios::scientific);
	      Out_File << " " << W_node.T()
		       << " " << W_node.v.abs()/W_node.a() 
		       << " " << W_node.H()
		       << " " << W_node.s();
	      Out_File.unsetf(ios::scientific);
	    }

	    // Add more variables for turbulent flows
	    if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	      Out_File << " " << W_node.k
		       << " " << W_node.omega;

	      // Add more variables for the Detailed format
	      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
		Out_File << " " << W_node.epsilon()
			 << " " << W_node.ell()
			 << " " << W_node.pmodified()
			 << " " << W_node.PrT(Wall[i][j].ywall,Wall[i][j].yplus)
			 << " " << Wall[i][j].yplus;
	      }

	      // Brief format and variable Prandtl number
	      if (Variable_Prandtl == ON) {
		Out_File << " " << W_node.ke
			 << " " << W_node.ee; 
	      }
	    }

	    // Output Reynolds number along x direction
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired() && Flow_Type != FLOWTYPE_INVISCID){
	      Out_File << " " << IP.Wo.v.x/IP.Wo.nu()*Node.x;
	    }

	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File.setf(ios::scientific);
	      Out_File << " " << 1.0E8
		       << " " << 0
		       << " " << 1.0E8
		       << " " << 0
		       << " " << 1.0E8
		       << " " << 0
		       << " " << 1.0E8
		       << " " << 0;

	      // Add more variables for turbulent flows
	      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
		Out_File << " " << 1.0E8
			 << " " << 0
			 << " " << 1.0E8
			 << " " << 0;

		if (Variable_Prandtl == ON){
		  Out_File << " " << 1.0E8
			   << " " << 0
			   << " " << 1.0E8
			   << " " << 0;
		}
	      }
	      Out_File.unsetf(ios::scientific);

	      if (ExactSoln->IsExactSolutionSet()){
		ExactSoln->Output_Tecplot_Solution(Out_File,
						   Node.x,Node.y);
	      }
	    }

	    // Add more variables for the Extended format
	    if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	      Out_File << " " << dUdt[i][j][0].rho
		       << " " << dUdt[i][j][0].dv
		       << " " << dUdt[i][j][0].E;

	      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
		Out_File << " " << dUdt[i][j][0].dk
			 << " " << dUdt[i][j][0].domega;
	      
		if (Variable_Prandtl == ON){
		  Out_File << " " << dUdt[i][j][0].dke
			   << " " << dUdt[i][j][0].dee;
		}
	      }
	    } // endif (ExtendedOutput)

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);
	    
	  } else {

	    // Output Brief format
	    W_node = HighOrderVariable(IndexHO).SolutionStateAtLocation(i,j,Node);
	    Out_File << " "  << Node 
		     << " "  << W_node.rho
		     << " "  << W_node.v
		     << " "  << W_node.p;
	    
	    // Add more variables for the Detailed format
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){ 
	      Out_File.setf(ios::scientific);
	      Out_File << " " << W_node.T()
		       << " " << W_node.v.abs()/W_node.a() 
		       << " " << W_node.H()
		       << " " << W_node.s();
	      Out_File.unsetf(ios::scientific);
	    }

	    // Add more variables for turbulent flows
	    if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	      Out_File << " " << W_node.k
		       << " " << W_node.omega;

	      // Add more variables for the Detailed format
	      if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
		Out_File << " " << W_node.epsilon()
			 << " " << W_node.ell()
			 << " " << W_node.pmodified()
			 << " " << W_node.PrT(Wall[i][j].ywall,Wall[i][j].yplus)
			 << " " << Wall[i][j].yplus;
	      }

	      // Brief format and variable Prandtl number
	      if (Variable_Prandtl == ON) {
		Out_File << " " << W_node.ke
			 << " " << W_node.ee; 
	      }
	    }

	    // Output Reynolds number along x direction
	    if (Tecplot_Execution_Mode::IsDetailedOutputRequired() && Flow_Type != FLOWTYPE_INVISCID){
	      Out_File << " " << IP.Wo.v.x/IP.Wo.nu()*Node.x;
	    }

	    // Add more variables for the Full format
	    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	      Out_File.setf(ios::scientific);
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,2)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,2)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,3)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,3)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,4)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,4);

	      // Add more variables for turbulent flows
	      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
		Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,5)
			 << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,5)
			 << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,6)
			 << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,6);

		if (Variable_Prandtl == ON){
		  Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,7)
			   << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,7)
			   << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,8)
			   << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,8);
		}
	      }
	      Out_File.unsetf(ios::scientific);

	      if (ExactSoln->IsExactSolutionSet()){
		ExactSoln->Output_Tecplot_Solution(Out_File,
						   Node.x,Node.y);
	      }
	    }

	    // Add more variables for the Extended format
	    if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	      Out_File << " " << dUdt[i][j][0].rho
		       << " " << dUdt[i][j][0].dv
		       << " " << dUdt[i][j][0].E;

	      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
		Out_File << " " << dUdt[i][j][0].dk
			 << " " << dUdt[i][j][0].domega;
	      
		if (Variable_Prandtl == ON){
		  Out_File << " " << dUdt[i][j][0].dke
			   << " " << dUdt[i][j][0].dee;
		}
	      }
	    } // endif (ExtendedOutput)

	    // Close line
	    Out_File << "\n";
	    Out_File.unsetf(ios::scientific);
	  }

	}
      } /* endfor */
    }
  } /* endfor */
  Out_File << setprecision(6);

}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at the interior nodes of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 *
 * \param IndexHO the high-order variable index that is used to calculate the solution
 */
void NavierStokes2D_Quad_Block::Output_Tecplot_HighOrder(const NavierStokes2D_Input_Parameters &IP,
							 const int &Number_of_Time_Steps,
							 const double &Time,
							 const int &Block_Number,
							 const int &Output_Title,
							 ostream &Out_File,
							 const int &IndexHO) {

  return Output_Nodes_Tecplot_HighOrder(IP,
					Number_of_Time_Steps,
					Time,
					Block_Number,
					Output_Title,
					Out_File,
					ICl, ICu, JCl, JCu,
					IndexHO);
}

/*!
 * Writes the solution values at the interior nodes of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note This subroutine is only used for debugging!
 */
void NavierStokes2D_Quad_Block::Output_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
								    const NavierStokes2D_Input_Parameters &IP,
								    const int &Block_Number,
								    const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  
  /* Open the output data file. */
  
  output_file.open(output_file_name, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }
  
  try {
    Output_Tecplot_HighOrder(IP,
			     0,0,
			     Block_Number,
			     1,
			     output_file,
			     IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }

  /* Close the output data file. */
  output_file.close();

  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all nodes (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 */
void NavierStokes2D_Quad_Block::Output_Nodes_Tecplot_HighOrder(const NavierStokes2D_Input_Parameters &IP,
							       const int &Number_of_Time_Steps,
							       const double &Time,
							       const int &Block_Number,
							       const int &Output_Title,
							       ostream &Out_File,
							       const int &IndexHO) {

  return Output_Nodes_Tecplot_HighOrder(IP,
					Number_of_Time_Steps,
					Time,
					Block_Number,
					Output_Title,
					Out_File,
					ICl - Nghost,
					ICu + Nghost,
					JCl - Nghost,
					JCu + Nghost,
					IndexHO);
}

/*!
 * Writes the solution values at the nodes (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost nodes for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void NavierStokes2D_Quad_Block::Output_Nodes_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									  const NavierStokes2D_Input_Parameters &IP,
									  const int &Block_Number,
									  const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_nodes_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Nodes_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Nodes_Tecplot_HighOrder(IP,
				   0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Writes the solution values generated by the high-order 
 * interpolant at all cells (interior + ghost) of the
 * quadrilateral solution block to the specified output
 * stream suitable for plotting with TECPLOT.
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \todo Add some omitted turbulent quantities!
 */
void NavierStokes2D_Quad_Block::Output_Cells_Tecplot_HighOrder(const int &Number_of_Time_Steps,
							       const double &Time,
							       const int &Block_Number,
							       const int &Output_Title,
							       ostream &Out_File,
							       const int &IndexHO) {

  int i, j;
  NavierStokes2D_pState W_node, dWdx_node, dWdy_node;
  Vector2D Node;

  if (NumberOfHighOrderVariables <= IndexHO){
    throw runtime_error("NavierStokes2D_Quad_Block::Output_Cells_Tecplot_HighOrder() ERROR! High-order object index out of range!");
  }

  /* Output cell centroid solution data. */

  Out_File << setprecision(14);
  if (Output_Title) {
    // Set the Brief format
    Out_File << "TITLE = \"" << CFFC_Name() << ": 2D NavierStokes Solution, "
	     << "Time Step/Iteration Level = " << Number_of_Time_Steps
	     << ", Time = " << Time
	     << "\"" << "\n"
	     << "VARIABLES = \"x\" \\ \n"
	     << "\"y\" \\ \n"
	     << "\"rho\" \\ \n"
	     << "\"u\" \\ \n"
	     << "\"v\" \\ \n"
	     << "\"p\" \\ \n";

    // Add more variables to Brief format for turbulent flows
    if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
      
      Out_File << "\"k\" \\ \n"
	       << "\"omega\" \\ \n";

      if (Variable_Prandtl == ON){
	Out_File << "\"ke\" \\ \n"
		 << "\"ee\" \\ \n";
      }
    }
      
    // Add more variables for the Detailed format
    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
      Out_File << "\"T\" \\ \n"
	       << "\"M\" \\ \n"
	       << "\"H\" \\ \n"
	       << "\"s\" \\ \n";
      
      Out_File << "\"rhoAvg\" \\ \n"
	       << "\"uAvg\" \\ \n"
	       << "\"vAvg\" \\ \n"
	       << "\"pAvg\" \\ \n";
      // Add more variables to Detailed format for turbulent flows
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
	Out_File << "\"kAvg\" \\ \n"
		 << "\"omegaAvg\" \\ \n";
	if (Variable_Prandtl == ON){
	  Out_File << "\"keAvg\" \\ \n"
		   << "\"eeAvg\" \\ \n";
	}
      }

      if (ExactSoln->IsExactSolutionSet()){
	ExactSoln->Output_Tecplot_Title(Out_File);
      }      
    } // endif (DetailedOutput)


    // Add more variables for the Full format
    if (Tecplot_Execution_Mode::IsFullOutputRequired()){

      Out_File << "\"ValISrho\" \\ \n"
	       << "\"ISrho\" \\ \n"
	       << "\"ValISu\" \\ \n"
	       << "\"ISu\" \\ \n"
	       << "\"ValISv\" \\ \n"
	       << "\"ISv\" \\ \n"
	       << "\"ValISp\" \\ \n"
	       << "\"ISp\" \\ \n";

      // Add more variables to Full format for turbulent flows
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	Out_File << "\"ValISk\" \\ \n"
		 << "\"ISk\" \\ \n"
		 << "\"ValISomega\" \\ \n"
		 << "\"ISomega\" \\ \n";
		 	
	if (Variable_Prandtl == ON){
	  Out_File << "\"ValISke\" \\ \n"
		   << "\"ISke\" \\ \n"
		   << "\"ValISee\" \\ \n"
		   << "\"ISee\" \\ \n";
	}
      }

      if (Flow_Type != FLOWTYPE_INVISCID){
	Out_File  << "\"tau_xx\" \\ \n"
		  << "\"tau_xy\" \\ \n"
		  << "\"tau_yy\" \\ \n";
	if (Axisymmetric){
	  Out_File << "\"tau_zz\" \\ \n";
	}
	Out_File << "\"qx\" \\ \n"
		 << "\"qy\" \\ \n"
		 << "\"alphaT\" \\ \n"
		 << "\"kappaT\" \\ \n";
      }
      Out_File << "\"mu\" \\ \n";

      Out_File << "\"ResidualRho\" \\ \n"
	       << "\"ResidualDvX\" \\ \n"
	       << "\"ResidualDvY\" \\ \n"
	       << "\"ResidualE\" \\ \n";
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	Out_File << "\"ResidualK\" \\ \n"
		 << "\"ResidualOmega\" \\ \n";
		 	
	if (Variable_Prandtl == ON){
	  Out_File << "\"ResidualKe\" \\ \n"
		   << "\"ResidualEe\" \\ \n";
	}
      }

      Out_File << "\"dt\" \\ \n";

    } // endif (FullOutput)
      
    // Add more variables for the Extended format
    if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
      Out_File << "\"A\" \\ \n";

      switch(HighOrderVariable(IndexHO).RecOrder()){
      case 4:	  // 4th-order derivatives
	Out_File << "\"dxxxxrho\" \\ \n"
		 << "\"dxxxxu\" \\ \n"
		 << "\"dxxxxv\" \\ \n"
		 << "\"dxxxxp\" \\ \n"
		 << "\"dxxxxk\" \\ \n"
		 << "\"dxxxxomega\" \\ \n"
		 << "\"dxxxxke\" \\ \n"
		 << "\"dxxxxee\" \\ \n"
		 << "\"dxxxyrho\" \\ \n"
		 << "\"dxxxyu\" \\ \n"
		 << "\"dxxxyv\" \\ \n"
		 << "\"dxxxyp\" \\ \n"
		 << "\"dxxxyk\" \\ \n"
		 << "\"dxxxyomega\" \\ \n"
		 << "\"dxxxyke\" \\ \n"
		 << "\"dxxxyee\" \\ \n"
		 << "\"dxxyyrho\" \\ \n"
		 << "\"dxxyyu\" \\ \n"
		 << "\"dxxyyv\" \\ \n"
		 << "\"dxxyyp\" \\ \n"
		 << "\"dxxyyk\" \\ \n"
		 << "\"dxxyyomega\" \\ \n"
		 << "\"dxxyyke\" \\ \n"
		 << "\"dxxyyee\" \\ \n"
		 << "\"dxyyyrho\" \\ \n"
		 << "\"dxyyyu\" \\ \n"
		 << "\"dxyyyv\" \\ \n"
		 << "\"dxyyyp\" \\ \n"
		 << "\"dxyyyk\" \\ \n"
		 << "\"dxyyyomega\" \\ \n"
		 << "\"dxyyyke\" \\ \n"
		 << "\"dxyyyee\" \\ \n"
		 << "\"dyyyyrho\" \\ \n"
		 << "\"dyyyyu\" \\ \n"
		 << "\"dyyyyv\" \\ \n"
		 << "\"dyyyyp\" \\ \n"
		 << "\"dyyyyk\" \\ \n"
		 << "\"dyyyyomega\" \\ \n"
		 << "\"dyyyyke\" \\ \n"
		 << "\"dyyyyee\" \\ \n";
	  
      case 3:   // 3rd-order derivatives
	Out_File << "\"dxxxrho\" \\ \n"
		 << "\"dxxxu\" \\ \n"
		 << "\"dxxxv\" \\ \n"
		 << "\"dxxxp\" \\ \n"
		 << "\"dxxxk\" \\ \n"
		 << "\"dxxxomega\" \\ \n"
		 << "\"dxxxke\" \\ \n"
		 << "\"dxxxee\" \\ \n"
		 << "\"dxxyrho\" \\ \n"
		 << "\"dxxyu\" \\ \n"
		 << "\"dxxyv\" \\ \n"
		 << "\"dxxyp\" \\ \n"
		 << "\"dxxyk\" \\ \n"
		 << "\"dxxyomega\" \\ \n"
		 << "\"dxxyke\" \\ \n"
		 << "\"dxxyee\" \\ \n"
		 << "\"dxyyrho\" \\ \n"
		 << "\"dxyyu\" \\ \n"
		 << "\"dxyyv\" \\ \n"
		 << "\"dxyyp\" \\ \n"
		 << "\"dxyyk\" \\ \n"
		 << "\"dxyyomega\" \\ \n"
		 << "\"dxyyke\" \\ \n"
		 << "\"dxyyee\" \\ \n"
		 << "\"dyyyrho\" \\ \n"
		 << "\"dyyyu\" \\ \n"
		 << "\"dyyyv\" \\ \n"
		 << "\"dyyyp\" \\ \n"
		 << "\"dyyyk\" \\ \n"
		 << "\"dyyyomega\" \\ \n"
		 << "\"dyyyke\" \\ \n"
		 << "\"dyyyee\" \\ \n";

      case 2: 	 // 2nd-order derivatives
	Out_File << "\"dxxrho\" \\ \n"
		 << "\"dxxu\" \\ \n"
		 << "\"dxxv\" \\ \n"
		 << "\"dxxp\" \\ \n"
		 << "\"dxxk\" \\ \n"
		 << "\"dxxomega\" \\ \n"
		 << "\"dxxke\" \\ \n"
		 << "\"dxxee\" \\ \n"
		 << "\"dxyrho\" \\ \n"
		 << "\"dxyu\" \\ \n"
		 << "\"dxyv\" \\ \n"
		 << "\"dxyp\" \\ \n"
		 << "\"dxyk\" \\ \n"
		 << "\"dxyomega\" \\ \n"
		 << "\"dxyke\" \\ \n"
		 << "\"dxyee\" \\ \n"
		 << "\"dyyrho\" \\ \n"
		 << "\"dyyu\" \\ \n"
		 << "\"dyyv\" \\ \n"
		 << "\"dyyp\" \\ \n"
		 << "\"dyyk\" \\ \n"
		 << "\"dyyomega\" \\ \n"
		 << "\"dyyke\" \\ \n"
		 << "\"dyyee\" \\ \n";

      case 1:   // 1st-order derivatives
	Out_File << "\"dxrho\" \\ \n"
		 << "\"dxu\" \\ \n"
		 << "\"dxv\" \\ \n"
		 << "\"dxp\" \\ \n"
		 << "\"dxk\" \\ \n"
		 << "\"dxomega\" \\ \n"
		 << "\"dxke\" \\ \n"
		 << "\"dxee\" \\ \n"
		 << "\"dyrho\" \\ \n"
		 << "\"dyu\" \\ \n"
		 << "\"dyv\" \\ \n"
		 << "\"dyp\" \\ \n"
		 << "\"dyk\" \\ \n"
		 << "\"dyomega\" \\ \n"
		 << "\"dyke\" \\ \n"
		 << "\"dyee\" \\ \n"
		 << "\"phirho\" \\ \n"
		 << "\"phiu\" \\ \n"
		 << "\"phiv\" \\ \n"
		 << "\"phip\" \\ \n"
		 << "\"phik\" \\ \n"
		 << "\"phiomega\" \\ \n"
		 << "\"phike\" \\ \n"
		 << "\"phiee\" \\ \n";
      } // endswitch

    }
  } /* endif */

  Out_File << "ZONE T =  \"Block Number = " << Block_Number
	   << "\" \\ \n"
	   << "I = " << ( ICu - ICl + 2*Nghost + 1 ) << " \\ \n"
	   << "J = " << ( JCu - JCl + 2*Nghost + 1 ) << " \\ \n"
	   << "F = POINT \n";

  // Set the accuracy properly
  if (Tecplot_Execution_Mode::IsDoublePrecision()){
    Out_File << "DT = (DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

    if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
      Out_File << "DOUBLE DOUBLE ";
      if (Variable_Prandtl == ON){
	Out_File << "DOUBLE DOUBLE ";
      }
    }

    // Detail format
    if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
      Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";

      Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
	Out_File << "DOUBLE DOUBLE ";
	if (Variable_Prandtl == ON){
	  Out_File << "DOUBLE DOUBLE ";
	}
      }

      if (ExactSoln->IsExactSolutionSet()){
	ExactSoln->Output_Tecplot_Double_Precision(Out_File);
      }
    }

    // Full format
    if (Tecplot_Execution_Mode::IsFullOutputRequired()){
      Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT DOUBLE SHORTINT ";
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
	Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT ";
	if (Variable_Prandtl == ON){
	  Out_File << "DOUBLE SHORTINT DOUBLE SHORTINT ";
	}
      }

      if (Flow_Type != FLOWTYPE_INVISCID){
	Out_File << "DOUBLE DOUBLE DOUBLE ";
	if (Axisymmetric){
	  Out_File << "DOUBLE ";
	}
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
      }

      Out_File << "DOUBLE ";

      Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE ";
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
	Out_File << "DOUBLE DOUBLE ";
	if (Variable_Prandtl == ON){
	  Out_File << "DOUBLE DOUBLE ";
	}
      }
      
      Out_File << "DOUBLE ";
    }

    // Extended format
    if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
      Out_File << "\"A\" \\ \n";

      switch(HighOrderVariable(IndexHO).RecOrder()){
      case 4:	  // 4th-order derivatives
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

      case 3:   // 3rd-order derivatives
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

      case 2: 	 // 2nd-order derivatives
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";

      case 1:   // 1st-order derivatives
	Out_File << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "	  
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE "
		 << "DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE DOUBLE ";
      }
    }

    // Close line
    Out_File << " ) \n";
  } // endif (DoublePrecision)


  // Output data
  for (j = JCl-Nghost; j <= JCu+Nghost; ++j) {// for every j Cell
    for (i = ICl-Nghost; i <= ICu+Nghost; ++i) {// for every i Cell

      // Set the location
      Node = Grid.CellCentroid(i,j);

      if (i < ICl-HighOrderVariable(IndexHO).NghostHO() || 
	  i > ICu+HighOrderVariable(IndexHO).NghostHO() || 
	  j < JCl-HighOrderVariable(IndexHO).NghostHO() ||
	  j > JCu+HighOrderVariable(IndexHO).NghostHO()  ) {
	
	// No high-order interpolant is calculated for this cells.
	// The average solution is plotted at the centers of these cells.
	  
	// Output Brief format
	Out_File << " "  << Node
		 << " "  << CellSolution(i,j)[1]
		 << " "  << CellSolution(i,j)[2]
		 << " "  << CellSolution(i,j)[3]
		 << " "  << CellSolution(i,j)[4];

	// Add more variables to Brief format for turbulent flows
	if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
	  Out_File << " "  << CellSolution(i,j)[5]
		   << " "  << CellSolution(i,j)[6];
	  if (Variable_Prandtl == ON){
	    Out_File << " "  << CellSolution(i,j)[7]
		     << " "  << CellSolution(i,j)[8];
	  }
	}
	
	// Add more variables for the Detailed format
	if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	  Out_File << " " << CellSolution(i,j).T()
		   << " " << CellSolution(i,j).v.abs()/CellSolution(i,j).a()
		   << " " << CellSolution(i,j).H()
		   << " " << CellSolution(i,j).s();

	  Out_File << " "  << CellSolution(i,j)[1]
		   << " "  << CellSolution(i,j)[2]
		   << " "  << CellSolution(i,j)[3]
		   << " "  << CellSolution(i,j)[4];
	  // Add more variables to Brief format for turbulent flows
	  if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
	    Out_File << " "  << CellSolution(i,j)[5]
		     << " "  << CellSolution(i,j)[6];
	    if (Variable_Prandtl == ON){
	      Out_File << " "  << CellSolution(i,j)[7]
		       << " "  << CellSolution(i,j)[8];
	    }
	  }

	  if (ExactSoln->IsExactSolutionSet()){
	    ExactSoln->Output_Tecplot_Solution(Out_File,
					       Node.x,Node.y);
	  }
	} // endif (DetailedOutput)


	// Add more variables for the Full format
	if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	  Out_File.setf(ios::scientific);
	  Out_File << " " << 1.0E8
		   << " " << 0
		   << " " << 1.0E8
		   << " " << 0
		   << " " << 1.0E8
		   << " " << 0
		   << " " << 1.0E8
		   << " " << 0;

	  // Add more variables to Full format for turbulent flows
	  if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	    Out_File << " " << 1.0E8
		     << " " << 0
		     << " " << 1.0E8
		     << " " << 0;
	    if (Variable_Prandtl == ON){
	      Out_File << " " << 1.0E8
		       << " " << 0
		       << " " << 1.0E8
		       << " " << 0;
	    }
	  }
	  Out_File.unsetf(ios::scientific);

	  if (Flow_Type != FLOWTYPE_INVISCID){
	    Out_File  << " " << 0.0
		      << " " << 0.0
		      << " " << 0.0;
	    if (Axisymmetric){
	      Out_File << " " << 0.0;
	    }
	    Out_File << " " << 0.0
		     << " " << 0.0
		     << " " << 0.0
		     << " " << 0.0;
	  }

	  Out_File << " " << CellSolution(i,j).mu();
	  Out_File << " " << dUdt[i][j][0][1]
		   << " " << dUdt[i][j][0][2]
		   << " " << dUdt[i][j][0][3]
		   << " " << dUdt[i][j][0][4];

	  if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	    Out_File << " " << dUdt[i][j][0][5]
		     << " " << dUdt[i][j][0][6];
	    if (Variable_Prandtl == ON){
	      Out_File << " " << dUdt[i][j][0][7]
		       << " " << dUdt[i][j][0][8];
	    }
	  }

	  Out_File << " " << dt[i][j];
	}

	// Add more variables for the Extended format
	if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	  Out_File << " " << Grid.CellArea(i,j);

	  switch(HighOrderVariable(IndexHO).RecOrder()){
	  case 4:    // 4th-order derivatives
	    Out_File << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0);

	  case 3:   // 3rd-order derivatives
	    Out_File << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0);

	  case 2:    // 2nd-order derivatives
	    Out_File << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0);

	  case 1:	    
	    Out_File << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0) 
		     << " " << NavierStokes2D_pState(0);
	  } // endswitch
	}

	// Close line
	Out_File << "\n";
	Out_File.unsetf(ios::scientific);

      } else {

	// Use the high-order interpolant to calculate the solution at the cell centroids (i.e. it's equal to the state D00)
	  
	// Output Brief format
	W_node = HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,0);

	Out_File << " "  << Node 
		 << " "  << W_node[1]
		 << " "  << W_node[2]
		 << " "  << W_node[3]
		 << " "  << W_node[4];

	// Add more variables to Brief format for turbulent flows
	if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
	  Out_File << " "  << W_node[5]
		   << " "  << W_node[6];
	  if (Variable_Prandtl == ON){
	    Out_File << " "  << W_node[7]
		     << " "  << W_node[8];
	  }
	}
	

	// Add more variables for the Detailed format
	if (Tecplot_Execution_Mode::IsDetailedOutputRequired()){
	  Out_File << " "  << W_node.T()
		   << " "  << W_node.v.abs()/W_node.a()
		   << " "  << W_node.H()
		   << " "  << W_node.s();

	  Out_File << " "  << CellSolution(i,j)[1]
		   << " "  << CellSolution(i,j)[2]
		   << " "  << CellSolution(i,j)[3]
		   << " "  << CellSolution(i,j)[4];
	  // Add more variables to Brief format for turbulent flows
	  if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {   
	    Out_File << " "  << CellSolution(i,j)[5]
		     << " "  << CellSolution(i,j)[6];
	    if (Variable_Prandtl == ON){
	      Out_File << " "  << CellSolution(i,j)[7]
		       << " "  << CellSolution(i,j)[8];
	    }
	  }

	  if (ExactSoln->IsExactSolutionSet()){
	    ExactSoln->Output_Tecplot_Solution(Out_File,
					       Node.x,Node.y);
	  }
	}

	// Add more variables for the Full format
	if (Tecplot_Execution_Mode::IsFullOutputRequired()){
	  Out_File.setf(ios::scientific);
	  Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,1)
		   << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,1)
		   << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,2)
		   << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,2)
		   << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,3)
		   << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,3)
		   << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,4)
		   << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,4);
	  // Add more variables to Full format for turbulent flows
	  if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	    Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,5)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,5)
		     << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,6)
		     << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,6);
	    if (Variable_Prandtl == ON){
	      Out_File << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,7)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,7)
		       << " " << HighOrderVariable(IndexHO).CellSmoothnessIndicatorValue(i,j,8)
		       << " " << HighOrderVariable(IndexHO).CellInadequateFitValue(i,j,8);
	    }
	  }
	  Out_File.unsetf(ios::scientific);

	  if (Flow_Type != FLOWTYPE_INVISCID){
	    // Set state gradients at centroid
	    dWdx_node = HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,0);
	    dWdy_node = HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,1);
	    
	    // Compute viscous terms based on the state and the state gradients at centroid
	    W_node.ComputeViscousTerms(dWdx_node,
				       dWdy_node,
				       Node,
				       Axisymmetric,
				       OFF,
				       Wall[i][j].ywall,
				       Wall[i][j].yplus);
	    
	    Out_File << " " << W_node.tau.xx
		     << " " << W_node.tau.xy
		     << " " << W_node.tau.yy;
	    if (Axisymmetric){
	      Out_File << " " << W_node.tau.zz;
	    }
	    Out_File << " " << W_node.q.x
		     << " " << W_node.q.y
		     << " " << W_node.alphaT(Wall[i][j].ywall,Wall[i][j].yplus)
		     << " " << W_node.kappaT(Wall[i][j].ywall,Wall[i][j].yplus);
	  }

	  Out_File << " " << W_node.mu();

	  Out_File << " " << dUdt[i][j][0][1]
		   << " " << dUdt[i][j][0][2]
		   << " " << dUdt[i][j][0][3]
		   << " " << dUdt[i][j][0][4];
	  if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	    Out_File << " " << dUdt[i][j][0][5]
		     << " " << dUdt[i][j][0][6];
	    if (Variable_Prandtl == ON){
	      Out_File << " " << dUdt[i][j][0][7]
		       << " " << dUdt[i][j][0][8];
	    }
	  }

	  Out_File << " " << dt[i][j];
	}

	// Add more variables for the Extended format
	if (Tecplot_Execution_Mode::IsExtendedOutputRequired()){
	  Out_File << " " << Grid.CellArea(i,j);

	  switch(HighOrderVariable(IndexHO).RecOrder()){
	  case 4:    // 4th-order derivatives
	    Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,4,0) 
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,1) 
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,2) 
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,3) 
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,4);
	      
	  case 3:   // 3rd-order derivatives
	    Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,3,0)
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,1)
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,2)
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,3);
	      
	  case 2:    // 2nd-order derivatives
	    Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,2,0)
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,1)
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,2);

	  case 1:	    
	    Out_File << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,1,0) 
		     << " " << HighOrderVariable(IndexHO).CellTaylorDerivState(i,j,0,1) 
		     << " " << HighOrderVariable(IndexHO).CellTaylorDeriv(i,j).Limiter();
	  }
	}

	// Close line
	Out_File << "\n";
	Out_File.unsetf(ios::scientific);

      } // endif

    }
  } /* endfor */
  Out_File << setprecision(6);

}

/*!
 * Writes the solution values at the centroids (interior + ghost) of the       
 * specified quadrilateral solution block to the        
 * specified output stream suitable for plotting with
 * TECPLOT.                                         
 * \param IndexHO the high-order variable index that is used to calculate the solution
 *
 * \note Only the ghost cells for which the high-order solution can be calculated are included!
 * \note This subroutine is only used for debugging!
 */
void NavierStokes2D_Quad_Block::Output_Cells_Tecplot_HighOrder_Debug_Mode(AdaptiveBlock2D_List &Soln_Block_List,
									  const NavierStokes2D_Input_Parameters &IP,
									  const int &Block_Number,
									  const int &IndexHO){
 
  int i, j, i_output_title;
  char prefix[256], extension[256], extension2[20], output_file_name[256];
  char *output_file_name_ptr;
  ofstream output_file;    
  
  /* Determine prefix of output data file names. */
  i = 0;
  while (1) {
    if (IP.Output_File_Name[i] == ' ' ||
	IP.Output_File_Name[i] == '.') break;
    prefix[i]=IP.Output_File_Name[i];
    i = i + 1;
    if (i > strlen(IP.Output_File_Name) ) break;
  } /* endwhile */
  prefix[i] = '\0';
  strcat(prefix, "_cells_cpu");
  
  /* Determine output data file name for this processor. */

  sprintf(extension, "%.6d", Soln_Block_List.ThisCPU);
  strcat(extension, "_block");
  sprintf(extension2, "%03u", Block_Number);
  strcat(extension,extension2);
  strcat(extension, ".dat");
  strcpy(output_file_name, prefix);
  strcat(output_file_name, extension);
  output_file_name_ptr = output_file_name;
  
  /* Open the output data file. */
  
  output_file.open(output_file_name_ptr, ios::out);
  if (output_file.fail()) { throw runtime_error("Output_Cells_Tecplot_HighOrder_Debug_Mode() ERROR! Fail to open the output file!"); }

  try{
    
    Output_Cells_Tecplot_HighOrder(0,0,
				   Block_Number,
				   1,
				   output_file,
				   IndexHO);

  } catch (runtime_error) {
    /* Close the output data file. */
    output_file.close();

    // Try to remove the file
    remove(output_file_name);

    // Re-throw the error
    throw;
  }


  /* Close the output data file. */
  
  output_file.close();
  
  /* Writing of output data files complete. */
}

/*!
 * Evaluate the residual for the solution block 
 * using the high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 * The residual is stored in dUdt[][][k_residual].
 *
 * \param IP  input parameters object
 * \param Pos index to identify the high-order variable used to calculate the residual
 * \param k_residual index to identify the residual storage location
 *
 */
int NavierStokes2D_Quad_Block::dUdt_Residual_HighOrder(const NavierStokes2D_Input_Parameters &IP,
						       const int & k_residual,
						       const bool & UseTimeStep,
						       const unsigned short int Pos){
  
  // SET VARIABLES USED IN THE RESIDUAL CALCULATION PROCESS

  int i, j, GQPoint, Position, SplineSegment;
  bool IsNonSmoothHighOrderReconstruction;
  NavierStokes2D_pState Wl, Wr, W_face;
  NavierStokes2D_pState dWdxL, dWdyL, dWdxR, dWdyR, dWdx_face, dWdy_face; // Solution gradients at the inter-cellular face
  NavierStokes2D_cState Flux, FaceFlux, SourceTerm(0);
  int NumGQP(Grid.getNumGQP());	  // Number of Gauss quadrature points per face used to compute the flux integral

  Vector2D *GaussQuadPoints = new Vector2D [NumGQP]; // the GQPs at which a Riemann-like problem is solved
  double * GaussQuadWeights = new double [NumGQP];   // the Gauss integration weights for each Gauss quadrature
  int _dummy_flag(0);				     // defined only for convenience. It doesn't get used in the routine

  /* Set the GaussQuadWeights. */
  GaussQuadratureData::getGaussQuadWeights(GaussQuadWeights, NumGQP);

  /* Evaluate the solution residual 
     and write it to dUdt[][][k_residual]. */

  /***************************************************************************************
   *                 EVALUATE THE HIGH-ORDER SOLUTION RESIDUALS                          *
   *                                                                                     *
   * Algorithm Purpose: To evaluate solution residuals for solution blocks               *
   *                    characterized by a broad range of options.                       *
   *                                                                                     *
   * Important options to consider:                                                      *
   *         --> Geometry treatment: high-order or low-order                             *
   *         --> Spatial accuracy:   order of accuracy for flux calculation              *
   *         --> Boundary flux calculation: 'Riemann' problem or reconstruction based    *
   *                                                                                     *
   * In order to respond easier to all these parameter variations, the following         *
   * algorithm is adopted to sweep through the cell interfaces:                          *
   *         --> Compute all fluxes at interior inter-cellular faces.                    *
   *         --> Compute fluxes for North, South, East and West block boundary faces.    *
   *                                                                                     *
   * Note: Two passes are needed to compute both elliptic and hyperbolic terms!          *
   ***************************************************************************************/
  
  /* Evaluate the time rate of change of the solution
     (i.e., the solution residuals) using a centrally-weighted
     gradient reconstruction for the diffusive fluxes.
     NOTE: Include here the contribution of the elliptic and source terms! */

   
  /* Perform the unlimited high-order reconstruction within 
     each cell of the computational grid for this stage. 
     NOTE: This solution reconstruction IS NOT recommended for computing hyperbolic fluxes!
  */

  HighOrderVariable(Pos).ComputeUnlimitedSolutionReconstruction(*this);


  // ** Step 1. Compute interior viscous fluxes and any source contributions for cells between (ICl,JCl)-->(ICu,JCu) **
  // ********************************************************************************************************************
  for ( j = JCl ; j <= JCu ; ++j ){
    for ( i = ICl ; i <= ICu ; ++i ) {

      if (Flow_Type != FLOWTYPE_INVISCID){
      
	if ( i != ICu) { 		// (i == ICu) corresponds to the East block boundary which will be considered separately!
	
	  /* Evaluate the cell interface i-direction viscous fluxes.
	     --> ( i.e. East Flux for cell (i,j) & West Flux for cell (i+1,j) ) */
	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(i,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    /* Determine the solution state at the Gauss quadrature
	       point to be used for calculation of the viscous flux by taking the 
	       average of the left and right interface states at the current Gauss
	       point location based on the unlimited high-order reconstruction */
	    W_face = 0.5*(HighOrderVariable(Pos).SolutionStateAtLocation(i  ,j,GaussQuadPoints[GQPoint]) +
			  HighOrderVariable(Pos).SolutionStateAtLocation(i+1,j,GaussQuadPoints[GQPoint]));

	    // Validate W_face state
	    // At this stage, unphysical values might occur because the reconstruction monotonicity has not been enforced yet.
	    if (W_face.Unphysical_Properties()){
	      // Use the average of the cell averages (i.e. loose accuracy but maintain physical values)
	      W_face = 0.5*(CellSolution(i,j) + CellSolution(i+1,j));
	    }

	    // Calculate gradients at the Gauss quadrature point using a centrally-weighted reconstruction.
	    dWdx_face = 0.5*(HighOrderVariable(Pos).XGradientStateAtLocation(i  ,j,GaussQuadPoints[GQPoint]) + 
			     HighOrderVariable(Pos).XGradientStateAtLocation(i+1,j,GaussQuadPoints[GQPoint]) );
	    dWdy_face = 0.5*(HighOrderVariable(Pos).YGradientStateAtLocation(i  ,j,GaussQuadPoints[GQPoint]) + 
			     HighOrderVariable(Pos).YGradientStateAtLocation(i+1,j,GaussQuadPoints[GQPoint]) );

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
							      W_face, dWdx_face, dWdy_face,
							      Grid.nfaceE(i, j),
							      Axisymmetric,
							      _dummy_flag,
							      Wall[i][j].ywall,
							      Wall[i][j].yplus);
	  } //endfor (GQPoint)

	  
	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[i  ][j][k_residual] += ( (IP.CFL_Number * dt[i  ][j])*
					  Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );
	    
	    dUdt[i+1][j][k_residual] -= ( (IP.CFL_Number * dt[i+1][j])*
					  Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	  } else {
	    dUdt[i  ][j][k_residual] += ( Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );
	    
	    dUdt[i+1][j][k_residual] -= ( Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	  }

	} //endif (i != ICu)


	if ( j != JCu) {		// (j == JCu) corresponds to the North block boundary which will be considered separately!

	  /* Evaluate the cell interface j-direction viscous fluxes.
	     --> ( i.e. North Flux for cell (i,j) & South Flux for cell (i,j+1) ) */
	  // Determine the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  Flux.Vacuum();

	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    /* Determine the solution state at the Gauss quadrature
	       point to be used for calculation of the viscous flux by taking the 
	       average of the left and right interface states at the current Gauss
	       point location based on the unlimited high-order reconstruction */
	    W_face = 0.5*(HighOrderVariable(Pos).SolutionStateAtLocation(i,j  ,GaussQuadPoints[GQPoint]) +
			  HighOrderVariable(Pos).SolutionStateAtLocation(i,j+1,GaussQuadPoints[GQPoint]));

	    // Validate W_face state
	    // At this stage, unphysical values might occur because the reconstruction monotonicity has not been enforced yet.
	    if (W_face.Unphysical_Properties()){
	      // Use the average of the cell averages (i.e. loose accuracy but maintain physical values)
	      W_face = 0.5*(CellSolution(i,j) + CellSolution(i+1,j));
	    }

	    // Calculate gradients at the Gauss quadrature point using a centrally-weighted reconstruction.
	    dWdx_face = 0.5*(HighOrderVariable(Pos).XGradientStateAtLocation(i,j  ,GaussQuadPoints[GQPoint]) + 
			     HighOrderVariable(Pos).XGradientStateAtLocation(i,j+1,GaussQuadPoints[GQPoint]) );
	    dWdy_face = 0.5*(HighOrderVariable(Pos).YGradientStateAtLocation(i,j  ,GaussQuadPoints[GQPoint]) + 
			     HighOrderVariable(Pos).YGradientStateAtLocation(i,j+1,GaussQuadPoints[GQPoint]) );

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
							      W_face, dWdx_face, dWdy_face,
							      Grid.nfaceN(i, j),
							      Axisymmetric,
							      _dummy_flag,
							      Wall[i][j].ywall,
							      Wall[i][j].yplus);
	  } //endfor (GQPoint)


	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[i][j  ][k_residual] += ( (IP.CFL_Number * dt[i][j  ])*
					  Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );
	    
	    dUdt[i][j+1][k_residual] -= ( (IP.CFL_Number * dt[i][j+1])*
					  Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	  } else {
	    dUdt[i][j  ][k_residual] += ( Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );
	    
	    dUdt[i][j+1][k_residual] -= ( Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	  }

	} //endif (j != JCu)

      }	// endif (Flow_Type != FLOWTYPE_INVISCID)


      /* Include axisymmetric source terms as required. 
	 This terms are currently not considered with high-order accuracy.
	 Thus, they are based on the soln state and soln gradients at centroid. */
      SourceTerm.Vacuum();
      if (Axisymmetric) {
	// Include inviscid source term
	SourceTerm += W[i][j].Si(Grid.CellCentroid(i,j));
	
	if (Flow_Type){
	  // Include viscous source term
	  
	  // Calculate viscous terms at cell (i,j) centroid
	  W[i][j].ComputeViscousTerms(HighOrderVariable(Pos).CellTaylorDerivState(i,j,1,0),
				      HighOrderVariable(Pos).CellTaylorDerivState(i,j,0,1),
				      Grid.CellCentroid(i,j),
				      Axisymmetric,
				      _dummy_flag,
				      Wall[i][j].ywall,
				      Wall[i][j].yplus);

	  // Add contribution of the viscous source term
	  SourceTerm += W[i][j].Sv(Grid.CellCentroid(i,j),
				   HighOrderVariable(Pos).CellTaylorDerivState(i,j,0,1),
				   Wall[i][j].ywall,
				   Wall[i][j].yplus);
	}
      } /* endif (Axisymmetric) */
      
      // Include turbulent production and destruction source term.
      if (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) {
	SourceTerm += W[i][j].St(Grid.CellCentroid(i,j),
				 W[i][j],
				 HighOrderVariable(Pos).CellTaylorDerivState(i,j,1,0),
				 HighOrderVariable(Pos).CellTaylorDerivState(i,j,0,1),
				 Axisymmetric,
				 Wall[i][j].ywall,
				 Wall[i][j].yplus);
      }
      
      /* Update residual with the contribution of the source terms if required. */
      if (Axisymmetric || (Flow_Type == FLOWTYPE_TURBULENT_RANS_K_OMEGA) ){
	if (UseTimeStep) {
	  dUdt[i][j][k_residual] += ( (IP.CFL_Number*dt[i][j])* SourceTerm );
	} else {
	  dUdt[i][j][k_residual] += SourceTerm;
	}
      }

    } // endfor (i)
  } // endfor (j)

  
#ifdef CHANGE_NUMBER_OF_GQP_AT_BOUNDARY
  delete [] GaussQuadPoints;
  delete [] GaussQuadWeights;

  NumGQP = 3;

  GaussQuadPoints = new Vector2D [NumGQP]; // the GQPs at which a Riemann-like problem is solved
  GaussQuadWeights = new double [NumGQP];   // the Gauss integration weights for each Gauss quadrature

  /* Set the GaussQuadWeights. */
  GaussQuadratureData::getGaussQuadWeights(GaussQuadWeights, NumGQP);
#endif


  if (Flow_Type != FLOWTYPE_INVISCID){

    // ****** Step 2. Compute viscous fluxes through North block boundary ******
    // ***************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure. */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndNorthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Reset North flux for the current cell
	  FluxN[i].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of the viscous terms based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Calculate gradients at the Gauss quadrature point based on the constrained reconstruction.
	      dWdx_face = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu,
									  Grid.BndNorthSplineInfo[i].GQPoint(Position));
	      dWdy_face = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu,
									  Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 viscous flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(Grid.BndNorthSplineInfo[i].GQPoint(Position),
								W_face, dWdx_face, dWdy_face,
								Grid.BndNorthSplineInfo[i].NormalGQPoint(Position),
								Axisymmetric,
								_dummy_flag,
								Wall[i][JCu].ywall,
								Wall[i][JCu].yplus);
	    } //endfor (GQPoint)
	
	    // Update North face boundary flux with the contribution of this spline segment
	    FluxN[i] -= Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FluxN[i]/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxN[i].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of viscous terms based on the constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);

	    // Calculate gradients at the Gauss quadrature point based on the constrained reconstruction.
	    dWdx_face = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);
	    dWdy_face = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    FluxN[i] -= GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
								  W_face, dWdx_face, dWdy_face,
								  Grid.nfaceN(i,JCu),
								  Axisymmetric,
								  _dummy_flag,
								  Wall[i][JCu].ywall,
								  Wall[i][JCu].yplus);
	  } //endfor (GQPoint)
	
	  // Update North face boundary flux with the contribution of this cell face
	  FluxN[i] *= Grid.lfaceN(i,JCu);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* FluxN[i]/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)

      } // endif (Grid.BndNorthSplineInfo != NULL)


    } else {
      /* Calculate the flux using the centrally-weighted gradient reconstruction
	 and ensure that boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndNorthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Reset North flux for the current cell
	  FluxN[i].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left and right interface states at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu  ,Grid.BndNorthSplineInfo[i].GQPoint(Position));
	      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu+1,Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Compute left and right interface gradients at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      dWdxL = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu,
								      Grid.BndNorthSplineInfo[i].GQPoint(Position));
	      dWdyL = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu,
								      Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      dWdxR = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu+1,
								      Grid.BndNorthSplineInfo[i].GQPoint(Position));
	      dWdyR = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu+1,
								      Grid.BndNorthSplineInfo[i].GQPoint(Position));
	    
	      // Dsetermine the solution state at the Gauss quadrature point for the calculation 
	      // of viscous terms and the gradient at the interface such that
	      // to satisfy the specified boundary conditions.
	      ViscousFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							      i,JCu,
							      Wl, Wr,
							      W_face,
							      dWdxL, dWdyL, dWdxR, dWdyR,
							      dWdx_face, dWdy_face,
							      Grid.BndNorthSplineInfo[i].GQPoint(Position),
							      Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));	     

	      /* Add the weighted contribution of the current GQP to the total 
		 viscous flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(Grid.BndNorthSplineInfo[i].GQPoint(Position),
								W_face, dWdx_face, dWdy_face,
								Grid.BndNorthSplineInfo[i].NormalGQPoint(Position),
								Axisymmetric,
								_dummy_flag,
								Wall[i][JCu].ywall,
								Wall[i][JCu].yplus);
	    } //endfor (GQPoint)
	
	    // Update North face boundary flux with the contribution of this spline segment
	    FluxN[i] -= Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FluxN[i]/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,JCu) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	  // Reset North flux for the current cell
	  FluxN[i].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu  ,GaussQuadPoints[GQPoint]);
	    Wr = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu+1,GaussQuadPoints[GQPoint]);

	    // Compute left and right interface gradients at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    dWdxL = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);
	    dWdyL = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);
	    
	    dWdxR = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCu+1,GaussQuadPoints[GQPoint]);
	    dWdyR = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCu+1,GaussQuadPoints[GQPoint]);

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of viscous terms and the gradient at the interface such that
	    // to satisfy the specified boundary conditions.
	    ViscousFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							    i,JCu,
							    Wl, Wr,
							    W_face,
							    dWdxL, dWdyL, dWdxR, dWdyR,
							    dWdx_face, dWdy_face,
							    GaussQuadPoints[GQPoint],
							    Grid.nfaceN(i,JCu));

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    FluxN[i] -= GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
								  W_face, dWdx_face, dWdy_face,
								  Grid.nfaceN(i,JCu),
								  Axisymmetric,
								  _dummy_flag,
								  Wall[i][JCu].ywall,
								  Wall[i][JCu].yplus);
	  } //endfor (GQPoint)
	
	  // Update North face boundary flux with the contribution of this cell face
	  FluxN[i] *= Grid.lfaceN(i,JCu);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* FluxN[i]/Grid.Cell[i][JCu].A );
	  } else {
	    dUdt[i][JCu][k_residual] -= ( FluxN[i]/Grid.Cell[i][JCu].A );
	  }

	} // endfor (i)
      
      } // endif (Grid.BndNorthSplineInfo != NULL)
    
    } // endif (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 3. Compute viscous fluxes through South block boundary ******
    // ***************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure. */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndSouthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Reset South flux for the current cell
	  FluxS[i].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of viscous terms based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      // Calculate gradients at the Gauss quadrature point based on the constrained reconstruction.
	      dWdx_face = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl,
									  Grid.BndSouthSplineInfo[i].GQPoint(Position));
	      dWdy_face = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl,
									  Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 viscous flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(Grid.BndSouthSplineInfo[i].GQPoint(Position),
								W_face, dWdx_face, dWdy_face,
								Grid.BndSouthSplineInfo[i].NormalGQPoint(Position),
								Axisymmetric,
								_dummy_flag,
								Wall[i][JCl].ywall,
								Wall[i][JCl].yplus);
	    } //endfor (GQPoint)
	
	    // Update South face boundary flux with the contribution of this spline segment
	    FluxS[i] -= Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FluxS[i]/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxS[i].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of viscous terms based on the constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);

	    // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	    dWdx_face = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);
	    dWdy_face = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    FluxS[i] -= GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
								  W_face, dWdx_face, dWdy_face,
								  Grid.nfaceS(i,JCl),
								  Axisymmetric,
								  _dummy_flag,
								  Wall[i][JCl].ywall,
								  Wall[i][JCl].yplus);
	  } //endfor (GQPoint)
	
	  // Update South face boundary flux with the contribution of this cell face
	  FluxS[i] *= Grid.lfaceS(i,JCl);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* FluxS[i]/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)

      } // endif (Grid.BndSouthSplineInfo != NULL)


    } else {
      /* Calculate the flux using the centrally-weighted gradient reconstruction
	 and ensure that boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndSouthSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Reset South flux for the current cell	  
	  FluxS[i].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left and right interface states at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl  ,Grid.BndSouthSplineInfo[i].GQPoint(Position));
	      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl-1,Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      // Compute left and right interface gradients at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      dWdxL = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl,
								      Grid.BndSouthSplineInfo[i].GQPoint(Position));
	      dWdyL = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl,
								      Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      dWdxR = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl-1,
								      Grid.BndSouthSplineInfo[i].GQPoint(Position));
	      dWdyR = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl-1,
								      Grid.BndSouthSplineInfo[i].GQPoint(Position));
	    
	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of viscous terms and the gradient at the interface such that
	      // to satisfy the specified boundary conditions.
	      ViscousFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							      i,JCl,
							      Wl, Wr,
							      W_face,
							      dWdxL, dWdyL, dWdxR, dWdyR,
							      dWdx_face, dWdy_face,
							      Grid.BndSouthSplineInfo[i].GQPoint(Position),
							      Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 viscous flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(Grid.BndSouthSplineInfo[i].GQPoint(Position),
								W_face, dWdx_face, dWdy_face,
								Grid.BndSouthSplineInfo[i].NormalGQPoint(Position),
								Axisymmetric,
								_dummy_flag,
								Wall[i][JCl].ywall,
								Wall[i][JCl].yplus);
	    } //endfor (GQPoint)
	
	    // Update South face boundary flux with the contribution of this spline segment
	    FluxS[i] -= Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FluxS[i]/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. South Flux for cell (i,JCl) ) */
	for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxS[i].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl  ,GaussQuadPoints[GQPoint]);
	    Wr = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl-1,GaussQuadPoints[GQPoint]);

	    // Compute left and right interface gradients at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    dWdxL = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);
	    dWdyL = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);
	      
	    dWdxR = HighOrderVariable(Pos).XGradientStateAtLocation(i,JCl-1,GaussQuadPoints[GQPoint]);
	    dWdyR = HighOrderVariable(Pos).YGradientStateAtLocation(i,JCl-1,GaussQuadPoints[GQPoint]);

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of viscous terms and the gradient at the interface such that
	    // to satisfy the specified boundary conditions.
	    ViscousFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							    i,JCl,
							    Wl, Wr,
							    W_face,
							    dWdxL, dWdyL, dWdxR, dWdyR,
							    dWdx_face, dWdy_face,
							    GaussQuadPoints[GQPoint],
							    Grid.nfaceS(i,JCl));

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    FluxS[i] -= GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
								  W_face, dWdx_face, dWdy_face,
								  Grid.nfaceS(i,JCl),	  
								  Axisymmetric,
								  _dummy_flag,
								  Wall[i][JCl].ywall,
								  Wall[i][JCl].yplus);
	  } //endfor (GQPoint)
	
	  // Update South face boundary flux with the contribution of this cell face
	  FluxS[i] *= Grid.lfaceS(i,JCl);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* FluxS[i]/Grid.Cell[i][JCl].A );
	  } else {
	    dUdt[i][JCl][k_residual] -= ( FluxS[i]/Grid.Cell[i][JCl].A );
	  }

	} // endfor (i)
      
      } // endif (Grid.BndSouthSplineInfo != NULL)
    
    } // endif (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 4. Compute viscous fluxes through East block boundary ******
    // **************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure. */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndEastSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Reset East flux for the current cell
	  FluxE[j].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of viscous terms based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	      dWdx_face = HighOrderVariable(Pos).XGradientStateAtLocation(ICu,j,
									  Grid.BndEastSplineInfo[j].GQPoint(Position));
	      dWdy_face = HighOrderVariable(Pos).YGradientStateAtLocation(ICu,j,
									  Grid.BndEastSplineInfo[j].GQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 viscous flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(Grid.BndEastSplineInfo[j].GQPoint(Position),
								W_face, dWdx_face, dWdy_face,
								Grid.BndEastSplineInfo[j].NormalGQPoint(Position),	
								Axisymmetric,
								_dummy_flag,
								Wall[ICu][j].ywall,
								Wall[ICu][j].yplus);
	    } //endfor (GQPoint)
	
	    // Update East face boundary flux with the contribution of this spline segment
	    FluxE[j] -= Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FluxE[j]/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	  }
	  
	} // endfor (j)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxE[j].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of viscous terms based on the constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);

	    // Calculate gradient at the Gauss quadrature point based on the constrained reconstruction.
	    dWdx_face = HighOrderVariable(Pos).XGradientStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);
	    dWdy_face = HighOrderVariable(Pos).YGradientStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    FluxE[j] -= GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
								  W_face, dWdx_face, dWdy_face,
								  Grid.nfaceE(ICu,j),
								  Axisymmetric,
								  _dummy_flag,
								  Wall[ICu][j].ywall,
								  Wall[ICu][j].yplus);
	  } //endfor (GQPoint)
	
	  // Update East face boundary flux with the contribution of this cell face
	  FluxE[j] *= Grid.lfaceE(ICu,j);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* FluxE[j]/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)

      } // endif (Grid.BndEastSplineInfo != NULL)


    } else {
      /* Calculate the flux using the centrally-weighted gradient reconstruction
	 and ensure that boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndEastSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Reset East flux for the current cell
	  FluxE[j].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left and right interface states at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu  ,j,Grid.BndEastSplineInfo[j].GQPoint(Position));
	      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ICu+1,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Compute left and right interface gradients at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      dWdxL = HighOrderVariable(Pos).XGradientStateAtLocation(ICu,j,
								      Grid.BndEastSplineInfo[j].GQPoint(Position));
	      dWdyL = HighOrderVariable(Pos).YGradientStateAtLocation(ICu,j,
								      Grid.BndEastSplineInfo[j].GQPoint(Position));

	      dWdxR = HighOrderVariable(Pos).XGradientStateAtLocation(ICu+1,j,
								      Grid.BndEastSplineInfo[j].GQPoint(Position));
	      dWdyR = HighOrderVariable(Pos).YGradientStateAtLocation(ICu+1,j,
								      Grid.BndEastSplineInfo[j].GQPoint(Position));
	    
	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of viscous terms and the gradient at the interface such that
	      // to satisfy the specified boundary conditions.
	      ViscousFluxStates_AtBoundaryInterface_HighOrder(EAST,
							      ICu,j,
							      Wl, Wr,
							      W_face,
							      dWdxL, dWdyL, dWdxR, dWdyR,
							      dWdx_face, dWdy_face,
							      Grid.BndEastSplineInfo[j].GQPoint(Position),
							      Grid.BndEastSplineInfo[j].NormalGQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 viscous flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(Grid.BndEastSplineInfo[j].GQPoint(Position), 
								W_face, dWdx_face, dWdy_face,
								Grid.BndEastSplineInfo[j].NormalGQPoint(Position),
								Axisymmetric,
								_dummy_flag,
								Wall[ICu][j].ywall,
								Wall[ICu][j].yplus);
	    } //endfor (GQPoint)
	
	    // Update East face boundary flux with the contribution of this spline segment
	    FluxE[j] -= Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep) {
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FluxE[j]/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (ICu,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxE[j].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu  ,j,GaussQuadPoints[GQPoint]);
	    Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ICu+1,j,GaussQuadPoints[GQPoint]);

	    // Compute left and right interface gradients at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    dWdxL = HighOrderVariable(Pos).XGradientStateAtLocation(ICu  ,j,GaussQuadPoints[GQPoint]);
	    dWdyL = HighOrderVariable(Pos).YGradientStateAtLocation(ICu  ,j,GaussQuadPoints[GQPoint]);

	    dWdxR = HighOrderVariable(Pos).XGradientStateAtLocation(ICu+1,j,GaussQuadPoints[GQPoint]);
	    dWdyR = HighOrderVariable(Pos).YGradientStateAtLocation(ICu+1,j,GaussQuadPoints[GQPoint]);

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of viscous terms and the gradient at the interface such that
	    // to satisfy the specified boundary conditions.
	    ViscousFluxStates_AtBoundaryInterface_HighOrder(EAST,
							    ICu,j,
							    Wl, Wr,
							    W_face,
							    dWdxL, dWdyL, dWdxR, dWdyR,
							    dWdx_face, dWdy_face,
							    GaussQuadPoints[GQPoint],
							    Grid.nfaceE(ICu,j));

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    FluxE[j] -= GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
								  W_face, dWdx_face, dWdy_face,
								  Grid.nfaceE(ICu,j),
								  Axisymmetric,
								  _dummy_flag,
								  Wall[ICu][j].ywall,
								  Wall[ICu][j].yplus);
	  } //endfor (GQPoint)
	
	  // Update East face boundary flux with the contribution of this cell face
	  FluxE[j] *= Grid.lfaceE(ICu,j);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* FluxE[j]/Grid.Cell[ICu][j].A );
	  } else {
	    dUdt[ICu][j][k_residual] -= ( FluxE[j]/Grid.Cell[ICu][j].A );
	  }

	} // endfor (j)
      
      } // endif (Grid.BndEastSplineInfo != NULL)
    
    } // endif (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


    // ****** Step 5. Compute viscous fluxes through West block boundary ******
    // **************************************************************************
    // == Check the flux calculation method ==
    if (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
      /* Calculate the flux using information directly from the reconstruction.
	 The boundary conditions along this spline has been enforced to the reconstruction procedure. */
    
      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndWestSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Reset West flux for the current cell
	  FluxW[j].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of viscous terms based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Calculate gradients at the Gauss quadrature point based on the constrained reconstruction.
	      dWdx_face = HighOrderVariable(Pos).XGradientStateAtLocation(ICl,j,
									  Grid.BndWestSplineInfo[j].GQPoint(Position));
	      dWdy_face = HighOrderVariable(Pos).YGradientStateAtLocation(ICl,j,
									  Grid.BndWestSplineInfo[j].GQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 viscous flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(Grid.BndWestSplineInfo[j].GQPoint(Position),
								W_face, dWdx_face, dWdy_face,
								Grid.BndWestSplineInfo[j].NormalGQPoint(Position),
								Axisymmetric,
								_dummy_flag,
								Wall[ICl][j].ywall,
								Wall[ICl][j].yplus);
	    } //endfor (GQPoint)
	
	    // Update West face boundary flux with the contribution of this spline segment
	    FluxW[j] -= Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FluxW[j]/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)

      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxW[j].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of viscous terms based on the constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);

	    // Calculate gradients at the Gauss quadrature point based on the constrained reconstruction.
	    dWdx_face = HighOrderVariable(Pos).XGradientStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);
	    dWdy_face = HighOrderVariable(Pos).YGradientStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    FluxW[j] -= GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
								  W_face, dWdx_face, dWdy_face,
								  Grid.nfaceW(ICl,j),
								  Axisymmetric,
								  _dummy_flag,
								  Wall[ICl][j].ywall,
								  Wall[ICl][j].yplus);
	  } //endfor (GQPoint)
	
	  // Update West face boundary flux with the contribution of this cell face
	  FluxW[j] *= Grid.lfaceW(ICl,j);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* FluxW[j]/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)

      } // endif (Grid.BndWestSplineInfo != NULL)


    } else {
      /* Calculate the flux using the centrally-weighted gradient reconstruction
	 and ensure that boundary conditions for this boundary are correctly enforced. */

      // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
      if ( Grid.BndWestSplineInfo != NULL){
	/* High-order boundary representation is required.
	   Use all geometric information from the correspondent BndSplineInfo */
      
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Reset West flux for the current cell
	  FluxW[j].Vacuum();

	  for (SplineSegment = 1, Position = 1; 
	       SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	       ++SplineSegment){  // for each continuous spline subinterval

	    // Reset Flux
	    Flux.Vacuum();
	  
	    // Calculate total flux through the spline subinterval
	    for (GQPoint = 0;
		 GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
		 ++GQPoint, ++Position){  // for each Gauss Quadrature point

	      // Compute left and right interface states at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl  ,j,Grid.BndWestSplineInfo[j].GQPoint(Position));
	      Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ICl-1,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Compute left and right interface gradients at the current Gauss
	      // point location based on the unlimited high-order reconstruction
	      dWdxL = HighOrderVariable(Pos).XGradientStateAtLocation(ICl,j,
								      Grid.BndWestSplineInfo[j].GQPoint(Position));
	      dWdyL = HighOrderVariable(Pos).YGradientStateAtLocation(ICl,j,
								      Grid.BndWestSplineInfo[j].GQPoint(Position));

	      dWdxR = HighOrderVariable(Pos).XGradientStateAtLocation(ICl-1,j,
								      Grid.BndWestSplineInfo[j].GQPoint(Position));
	      dWdyR = HighOrderVariable(Pos).YGradientStateAtLocation(ICl-1,j,
								      Grid.BndWestSplineInfo[j].GQPoint(Position));
	    
	      // Determine the solution state at the Gauss quadrature point for the calculation 
	      // of viscous terms and the gradient at the interface such that
	      // to satisfy the specified boundary conditions.
	      ViscousFluxStates_AtBoundaryInterface_HighOrder(WEST,
							      ICl,j,
							      Wl, Wr,
							      W_face,
							      dWdxL, dWdyL, dWdxR, dWdyR,
							      dWdx_face, dWdy_face,
							      Grid.BndWestSplineInfo[j].GQPoint(Position),
							      Grid.BndWestSplineInfo[j].NormalGQPoint(Position));

	      /* Add the weighted contribution of the current GQP to the total 
		 viscous flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * ViscousFlux_n(Grid.BndWestSplineInfo[j].GQPoint(Position),
								W_face, dWdx_face, dWdy_face,
								Grid.BndWestSplineInfo[j].NormalGQPoint(Position),
								Axisymmetric,
								_dummy_flag,
								Wall[ICl][j].ywall,
								Wall[ICl][j].yplus);
	    } //endfor (GQPoint)
	
	    // Update West face boundary flux with the contribution of this spline segment
	    FluxW[j] -= Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	  } // endfor (SplineSegment)

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FluxW[j]/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)
      
      } else {
	/* Low-order boundary representation is required.
	   Treat the cell faces as straight edges. */

	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. West Flux for cell (ICl,j) ) */
	for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	  // Determine the location of the Gauss Quadrature Points
	  Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	  // Reset Flux
	  FluxW[j].Vacuum();

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Compute left and right interface states at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl  ,j,GaussQuadPoints[GQPoint]);
	    Wr = HighOrderVariable(Pos).SolutionStateAtLocation(ICl-1,j,GaussQuadPoints[GQPoint]);

	    // Compute left and right interface gradients at the current Gauss
	    // point location based on the unlimited high-order reconstruction
	    dWdxL = HighOrderVariable(Pos).XGradientStateAtLocation(ICl  ,j,GaussQuadPoints[GQPoint]);
	    dWdyL = HighOrderVariable(Pos).YGradientStateAtLocation(ICl  ,j,GaussQuadPoints[GQPoint]);

	    dWdxR = HighOrderVariable(Pos).XGradientStateAtLocation(ICl-1,j,GaussQuadPoints[GQPoint]);
	    dWdyR = HighOrderVariable(Pos).YGradientStateAtLocation(ICl-1,j,GaussQuadPoints[GQPoint]);

	    // Determine the solution state at the Gauss quadrature point for the calculation 
	    // of viscous terms and the gradient at the interface such that
	    // to satisfy the specified boundary conditions.
	    ViscousFluxStates_AtBoundaryInterface_HighOrder(WEST,
							    ICl,j,
							    Wl, Wr,
							    W_face,
							    dWdxL, dWdyL, dWdxR, dWdyR,
							    dWdx_face, dWdy_face,
							    GaussQuadPoints[GQPoint],
							    Grid.nfaceW(ICl,j));

	    /* Add the weighted contribution of the current GQP to the total 
	       viscous flux through the face in the normal direction. */
	    FluxW[j] -= GaussQuadWeights[GQPoint] * ViscousFlux_n(GaussQuadPoints[GQPoint],
								  W_face, dWdx_face, dWdy_face,
								  Grid.nfaceW(ICl,j),
								  Axisymmetric,
								  _dummy_flag,
								  Wall[ICl][j].ywall,
								  Wall[ICl][j].yplus);
	  } //endfor (GQPoint)
	
	  // Update West face boundary flux with the contribution of this cell face
	  FluxW[j] *= Grid.lfaceW(ICl,j);

	  /* Evaluate cell-averaged solution changes. */
	  if (UseTimeStep){
	    dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* FluxW[j]/Grid.Cell[ICl][j].A );
	  } else {
	    dUdt[ICl][j][k_residual] -= ( FluxW[j]/Grid.Cell[ICl][j].A );
	  }

	} // endfor (j)
      
      } // endif (Grid.BndWestSplineInfo != NULL)
    
    } // endif (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux)

  } // endif (Flow_Type != FLOWTYPE_INVISCID)


  /*****************************************************************
   * --------------------------------------------------------------*
     Evaluate the time rate of change of the solution 
     (i.e., the solution residuals) using a high-order 
     CENO upwind finite-volume scheme for the convective fluxes.
     NOTE: Include here the contribution of the hyperbolic terms! */

  /* Enforce monotonicity to the high-order interpolants detected as 
     non-smooth by the smoothness indicator analysis. 
     NOTE: This solution reconstruction IS recommended for computing hyperbolic fluxes!
  */
  HighOrderVariable(Pos).ComputeSmoothnessIndicator(*this);
  HighOrderVariable(Pos).EnforceMonotonicityToNonSmoothInterpolants(*this, IP.Limiter());

  // ** Step 1. Compute interior convective fluxes and any source contributions for cells between (ICl,JCl)-->(ICu,JCu) **
  // **********************************************************************************************************
  for ( j = JCl ; j <= JCu ; ++j ){
    for ( i = ICl ; i <= ICu ; ++i ) {

      if ( i != ICu) { 		// (i == ICu) corresponds to the East block boundary which will be considered separately!
	
	/* Evaluate the cell interface i-direction fluxes.
	   --> ( i.e. East Flux for cell (i,j) & West Flux for cell (i+1,j) ) */
	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceE(i,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i  ,j,GaussQuadPoints[GQPoint]);
	  Wr = HighOrderVariable(Pos).SolutionStateAtLocation(i+1,j,GaussQuadPoints[GQPoint]);

	  // Validate the left state
	  Validate_Primitive_SolnState(Wl,i ,j, "East", Pos);
	  // Validate the right state
	  Validate_Primitive_SolnState(Wr,i+1,j, "West", Pos);
	  
	  /* Add the weighted contribution of the current GQP to the total 
	     flux in the normal direction through the face. */
	  Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							    Wl, Wr,
							    Grid.nfaceE(i, j));

	} //endfor (GQPoint)
      
	  /* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[i  ][j][k_residual] -= ( (IP.CFL_Number * dt[i  ][j])*
					Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );
	    
	  dUdt[i+1][j][k_residual] += ( (IP.CFL_Number * dt[i+1][j])*
					Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	} else {
	  dUdt[i  ][j][k_residual] -= ( Flux * Grid.lfaceE(i  , j)/Grid.Cell[i  ][j].A );
	    
	  dUdt[i+1][j][k_residual] += ( Flux * Grid.lfaceW(i+1, j)/Grid.Cell[i+1][j].A );
	}

      }	//endif (i != ICu)


      if ( j != JCu) {		// (j == JCu) corresponds to the North block boundary which will be considered separately!

	/* Evaluate the cell interface j-direction fluxes.
	   --> ( i.e. North Flux for cell (i,j) & South Flux for cell (i,j+1) ) */
	// Determine the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceN(i,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,j  ,GaussQuadPoints[GQPoint]);
	  Wr = HighOrderVariable(Pos).SolutionStateAtLocation(i,j+1,GaussQuadPoints[GQPoint]);

	  // Validate the left state
	  Validate_Primitive_SolnState(Wl,i ,j  , "North", Pos);
	  // Validate the right state
	  Validate_Primitive_SolnState(Wr,i ,j+1, "South", Pos);	  

	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							    Wl, Wr,
							    Grid.nfaceN(i, j));
	} //endfor (GQPoint)


	  /* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[i][j  ][k_residual] -= ( (IP.CFL_Number * dt[i][j  ])*
					Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );
	    
	  dUdt[i][j+1][k_residual] += ( (IP.CFL_Number * dt[i][j+1])*
					Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	} else {
	  dUdt[i][j  ][k_residual] -= ( Flux * Grid.lfaceN(i, j  )/Grid.Cell[i][j  ].A );
	    
	  dUdt[i][j+1][k_residual] += ( Flux * Grid.lfaceS(i, j+1)/Grid.Cell[i][j+1].A );
	}

      } //endif (j != JCu)

    } // endfor (i)
  } // endfor (j)

  
  // ****** Step 7. Compute convective fluxes through North block boundary ******
  // ****************************************************************************
  // == Check the flux calculation method ==
  if (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
    /* Calculate the flux using information directly from the reconstruction.
       The boundary conditions along this spline has been enforced to the reconstruction procedure.
       If the high-order reconstruction has been detected as non-smooth compute an upwind flux
       with the value provided by the ghost cell reconstruction.
    */
    
    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndNorthSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. North Flux for cell (i,JCu) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCu);

	// Reset face flux for the current cell
	FaceFlux.Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // == Check if the solution reconstruction was detected as non-smooth.
	    if ( IsNonSmoothHighOrderReconstruction ){

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Validate Wl state
	      Validate_Primitive_SolnState(Wl, i, JCu, "North", Pos);
	      
	      // Determine the right interface state at the Gauss calculation point based on BCs
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							       i,JCu,
							       Wl,Wr,
							       Grid.BndNorthSplineInfo[i].GQPoint(Position),
							       Grid.BndNorthSplineInfo[i].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));

	    } else {

	      // Determine the solution state at the Gauss quadrature point for flux calculation
	      // based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,Grid.BndNorthSplineInfo[i].GQPoint(Position));

	      // Validate W_face state
	      Validate_Primitive_SolnState(W_face, i, JCu, "North", Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));
	    } // endif (IsNonSmoothHighOrderReconstruction)

	  } //endfor (GQPoint)
	
	  // Update FaceFlux with the contribution of this spline segment
	  FaceFlux += Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	// Update North face boundary flux with the contribution of the hyperbolic term
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxN[i] += FaceFlux;
	} else {
	  FluxN[i] = FaceFlux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FaceFlux/Grid.Cell[i][JCu].A );
	} else {
	  dUdt[i][JCu][k_residual] -= ( FaceFlux/Grid.Cell[i][JCu].A );
	}

      } // endfor (i)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. North Flux for cell (i,JCu) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCu);

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	// == Check if the solution reconstruction was detected as non-smooth.
	if ( IsNonSmoothHighOrderReconstruction ){

	  // Calculate total flux through the cell face in the normal direction
	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the low-order reconstruction.
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);
	  
	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, i, JCu, "North", Pos);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							     i,JCu,
							     Wl,Wr,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceN(i,JCu),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.nfaceN(i,JCu));
	  } //endfor (GQPoint)
	
	} else {

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point
	  
	    // Determine the solution state at the Gauss quadrature point for flux calculation
	    // based on constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);

	    // Validate W_face state
	    Validate_Primitive_SolnState(W_face, i, JCu, "North", Pos);
	  
	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.nfaceN(i,JCu));
	  } //endfor (GQPoint)
	
	} // endif

	// Calculate final flux through the cell face
	Flux *= Grid.lfaceN(i,JCu);

	// Update North face boundary flux with the contribution of this cell face
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxN[i] += Flux;
	} else {
	  FluxN[i]  = Flux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* Flux/Grid.Cell[i][JCu].A );
	} else {
	  dUdt[i][JCu][k_residual] -= ( Flux/Grid.Cell[i][JCu].A );
	}

      } // endfor (i)

    } // endif (Grid.BndNorthSplineInfo != NULL)


  } else {
    /* Calculate the flux by solving a Riemann problem and ensure
       that boundary conditions for this boundary are correctly enforced. */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndNorthSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */
      
      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. North Flux for cell (i,JCu) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	// Reset face flux
	FaceFlux.Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndNorthSplineInfo[i].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndNorthSplineInfo[i].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,
								Grid.BndNorthSplineInfo[i].GQPoint(Position));

	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, i, JCu, "North", Pos);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							     i,JCu,
							     Wl,Wr,
							     Grid.BndNorthSplineInfo[i].GQPoint(Position),
							     Grid.BndNorthSplineInfo[i].NormalGQPoint(Position),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the spline segment in the local normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.BndNorthSplineInfo[i].NormalGQPoint(Position));
	  } //endfor (GQPoint)
	
	  // Update face flux with the contribution of this spline segment
	  FaceFlux += Flux * Grid.BndNorthSplineInfo[i].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	// Update North face boundary flux with the contribution of the hyperbolic term
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxN[i] += FaceFlux;
	} else {
	  FluxN[i]  = FaceFlux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu]) * FaceFlux/Grid.Cell[i][JCu].A );
	} else {
	  dUdt[i][JCu][k_residual] -= ( FaceFlux/Grid.Cell[i][JCu].A );
	}

      } // endfor (i)
      
    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. North Flux for cell (i,JCu) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the North block boundary

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);

	// Reset flux
	Flux.Vacuum();

	// Calculate total flux through the cell face in the normal direction
	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCu,GaussQuadPoints[GQPoint]);

	  // Validate Wl state
	  Validate_Primitive_SolnState(Wl, i, JCu, "North", Pos);

	  // Determine right interface state at the Gauss calculation point
	  InviscidFluxStates_AtBoundaryInterface_HighOrder(NORTH,
							   i,JCu,
							   Wl,Wr,
							   GaussQuadPoints[GQPoint],
							   Grid.nfaceN(i,JCu),
							   Pos);

	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							    Wl, Wr,
							    Grid.nfaceN(i,JCu));
	} //endfor (GQPoint)

	// Calculate final flux through the cell face
	Flux *= Grid.lfaceN(i,JCu);

	// Update North face boundary flux with the contribution of this cell face
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxN[i] += Flux;
	} else {
	  FluxN[i]  = Flux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCu][k_residual] -= ( (IP.CFL_Number * dt[i][JCu])* Flux/Grid.Cell[i][JCu].A );
	} else {
	  dUdt[i][JCu][k_residual] -= ( Flux/Grid.Cell[i][JCu].A );
	}

      } // endfor (i)
      
    } // endif (Grid.BndNorthSplineInfo != NULL)
    
  } // endif (Grid.BndNorthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


  // ****** Step 8. Compute convective fluxes through South block boundary ******
  // ****************************************************************************
  // == Check the flux calculation method ==
  if (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
    /* Calculate the flux using information directly from the reconstruction.
       The boundary conditions along this spline has been enforced to the reconstruction procedure.
       If the high-order reconstruction has been detected as non-smooth compute a Riemann flux
       with the value provided by the ghost cell reconstruction.
    */
    
    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndSouthSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. South Flux for cell (i,JCl) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCl);

	// Reset face flux
	FaceFlux.Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // == Check if the solution reconstruction was detected as non-smooth.
	    if ( IsNonSmoothHighOrderReconstruction ){

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,Grid.BndSouthSplineInfo[i].GQPoint(Position));
	      
	      // Validate Wl state
	      Validate_Primitive_SolnState(Wl, i, JCl, "South", Pos);	      
	      
	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							       i,JCl,
							       Wl,Wr,
							       Grid.BndSouthSplineInfo[i].GQPoint(Position),
							       Grid.BndSouthSplineInfo[i].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));

	    } else {

	      // Determine the solution state at the Gauss quadrature point for calculation 
	      // based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,Grid.BndSouthSplineInfo[i].GQPoint(Position));

	      // Validate W_face state
	      Validate_Primitive_SolnState(W_face, i, JCl, "South", Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));
	    } // endif (IsNonSmoothHighOrderReconstruction)

	  } //endfor (GQPoint)
	
	  // Update FaceFlux with the contribution of this spline segment
	  FaceFlux += Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	// Update South face boundary flux with the contribution of the hyperbolic term
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxS[i] += FaceFlux;
	} else {
	  FluxS[i]  = FaceFlux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FaceFlux/Grid.Cell[i][JCl].A );
	} else {
	  dUdt[i][JCl][k_residual] -= ( FaceFlux/Grid.Cell[i][JCl].A );
	}

      } // endfor (i)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. South Flux for cell (i,JCl) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(i,JCl);

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	// == Check if the solution reconstruction was detected as non-smooth.
	if ( IsNonSmoothHighOrderReconstruction ){

	  // Calculate total flux through the cell face in the normal direction
	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the low-order reconstruction.
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);
	    
	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, i, JCl, "South", Pos);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							     i,JCl,
							     Wl,Wr,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceS(i,JCl),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.nfaceS(i,JCl));
	  } //endfor (GQPoint)
	    
	} else {

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for flux calculation 
	    // based on constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);

	    // Validate W_face state
	    Validate_Primitive_SolnState(W_face, i, JCl, "South", Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.nfaceS(i,JCl));
	  } //endfor (GQPoint)

	} // endif

	// Calculate final flux through the cell face
	Flux *= Grid.lfaceS(i,JCl);

	// Update South face boundary flux with the contribution of this cell face
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxS[i] += Flux;
	} else {
	  FluxS[i]  = Flux;
	}
	
	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* Flux/Grid.Cell[i][JCl].A );
	} else {
	  dUdt[i][JCl][k_residual] -= ( Flux/Grid.Cell[i][JCl].A );
	}

      } // endfor (i)

    } // endif (Grid.BndSouthSplineInfo != NULL)


  } else {
    /* Calculate the flux by solving a Riemann problem and ensure
       that boundary conditions for this boundary are correctly enforced. */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndSouthSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */
      
      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. South Flux for cell (i,JCl) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	// Reset face flux
	FaceFlux.Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndSouthSplineInfo[i].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndSouthSplineInfo[i].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,
								Grid.BndSouthSplineInfo[i].GQPoint(Position));
	    
	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, i, JCl, "South", Pos);

	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							     i,JCl,
							     Wl,Wr,
							     Grid.BndSouthSplineInfo[i].GQPoint(Position),
							     Grid.BndSouthSplineInfo[i].NormalGQPoint(Position),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the spline segment in the local normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.BndSouthSplineInfo[i].NormalGQPoint(Position));
	  } //endfor (GQPoint)
	
	  // Update FaceFlux with the contribution of this spline segment
	  FaceFlux += Flux * Grid.BndSouthSplineInfo[i].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	// Update South face boundary flux with the contribution of the hyperbolic term
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxS[i] += FaceFlux;
	} else {
	  FluxS[i]  = FaceFlux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl]) * FaceFlux/Grid.Cell[i][JCl].A );
	} else {
	  dUdt[i][JCl][k_residual] -= ( FaceFlux/Grid.Cell[i][JCl].A );
	}

      } // endfor (i)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface j-direction fluxes.
	 --> ( i.e. South Flux for cell (i,JCl) ) */
      for (i = ICl; i <= ICu; ++i){ // for each cell on the South block boundary

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	// Calculate total flux through the cell face in the normal direction
	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(i,JCl,GaussQuadPoints[GQPoint]);

	  // Validate Wl state
	  Validate_Primitive_SolnState(Wl, i, JCl, "South", Pos);
	  
	  // Determine right interface state at the Gauss calculation point
	  InviscidFluxStates_AtBoundaryInterface_HighOrder(SOUTH,
							   i,JCl,
							   Wl,Wr,
							   GaussQuadPoints[GQPoint],
							   Grid.nfaceS(i,JCl),
							   Pos);
	  
	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							    Wl, Wr,
							    Grid.nfaceS(i,JCl));
	} //endfor (GQPoint)
	
	// Calculate final flux through the cell face
	Flux *= Grid.lfaceS(i,JCl);

	// Update South face boundary flux with the contribution of this cell face
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxS[i] += Flux;
	} else {
	  FluxS[i]  = Flux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[i][JCl][k_residual] -= ( (IP.CFL_Number * dt[i][JCl])* Flux/Grid.Cell[i][JCl].A );
	} else {
	  dUdt[i][JCl][k_residual] -= ( Flux/Grid.Cell[i][JCl].A );
	}

      } // endfor (i)
      
    } // endif (Grid.BndSouthSplineInfo != NULL)
    
  } // endif (Grid.BndSouthSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


  // ****** Step 9. Compute convective fluxes through East block boundary ******
  // ***************************************************************************
  // == Check the flux calculation method ==
  if (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
    /* Calculate the flux using information directly from the reconstruction.
       The boundary conditions along this spline has been enforced to the reconstruction procedure.
       If the high-order reconstruction has been detected as non-smooth compute an upwind flux
       with the value provided by the ghost cell reconstruction.
    */
    
    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndEastSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. East Flux for cell (ICu,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICu,j);

	// Reset face flux
	FaceFlux.Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // == Check if the solution reconstruction was detected as non-smooth.
	    if ( IsNonSmoothHighOrderReconstruction ){

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Validate Wl state
	      Validate_Primitive_SolnState(Wl, ICu, j, "East", Pos);
	      
	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							       ICu,j,
							       Wl,Wr,
							       Grid.BndEastSplineInfo[j].GQPoint(Position),
							       Grid.BndEastSplineInfo[j].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.BndEastSplineInfo[j].NormalGQPoint(Position));

	    } else {

	      // Determine the solution state at the Gauss quadrature point for flux calculation 
	      // based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,Grid.BndEastSplineInfo[j].GQPoint(Position));

	      // Validate W_face state
	      Validate_Primitive_SolnState(W_face, ICu, j, "East", Pos);
	      
	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.BndEastSplineInfo[j].NormalGQPoint(Position));
	    } // endif (IsNonSmoothHighOrderReconstruction)

	  } //endfor (GQPoint)
	
	  // Update FaceFlux with the contribution of this spline segment
	  FaceFlux += Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	// Update East face boundary flux with the contribution of the hyperbolic term
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxE[j] += FaceFlux;
	} else {
	  FluxE[j]  = FaceFlux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FaceFlux/Grid.Cell[ICu][j].A );
	} else {
	  dUdt[ICu][j][k_residual] -= ( FaceFlux/Grid.Cell[ICu][j].A );
	}
	  
      } // endfor (j)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. East Flux for cell (ICu,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICu,j);

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	// == Check if the solution reconstruction was detected as non-smooth.
	if ( IsNonSmoothHighOrderReconstruction ){

	  // Calculate total flux through the cell face in the normal direction
	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the low-order reconstruction.
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);
	    
	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							     ICu,j,
							     Wl,Wr,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceE(ICu,j),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.nfaceE(ICu,j));
	  } //endfor (GQPoint)
	    
	} else {

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for flux calculation 
	    // based on the constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);

	    // Validate W_face state
	    Validate_Primitive_SolnState(W_face, ICu, j, "East", Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.nfaceE(ICu,j));
	  } //endfor (GQPoint)
	
	} // endif	  

	// Calculate final flux through the cell face
	Flux *= Grid.lfaceE(ICu,j);

	// Update East face boundary flux with the contribution of this cell face
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxE[j] += Flux;
	} else {
	  FluxE[j]  = Flux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* Flux/Grid.Cell[ICu][j].A );
	} else {
	  dUdt[ICu][j][k_residual] -= ( Flux/Grid.Cell[ICu][j].A );
	}

      } // endfor (j)

    } // endif (Grid.BndEastSplineInfo != NULL)


  } else {
    /* Calculate the flux by solving a Riemann problem and ensure 
       that boundary conditions for this boundary are correctly enforced. */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndEastSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */
      
      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. East Flux for cell (ICu,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	// Reset East flux for the current cell
	FaceFlux.Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndEastSplineInfo[j].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndEastSplineInfo[j].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,
								Grid.BndEastSplineInfo[j].GQPoint(Position));

	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, ICu, j, "East", Pos);
	    
	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							     ICu,j,
							     Wl,Wr,
							     Grid.BndEastSplineInfo[j].GQPoint(Position),
							     Grid.BndEastSplineInfo[j].NormalGQPoint(Position),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the spline segment in the local normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.BndEastSplineInfo[j].NormalGQPoint(Position));
	  } //endfor (GQPoint)

	  // Update FaceFlux with the contribution of this spline segment
	  FaceFlux += Flux * Grid.BndEastSplineInfo[j].IntLength(SplineSegment);
	
	} // endfor (SplineSegment)

	// Update East face boundary flux with the contribution of the hyperbolic term
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxE[j] += FaceFlux;
	} else {
	  FluxE[j]  = FaceFlux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep) {
	  dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j]) * FaceFlux/Grid.Cell[ICu][j].A );
	} else {
	  dUdt[ICu][j][k_residual] -= ( FaceFlux/Grid.Cell[ICu][j].A );
	}

      } // endfor (j)
      
    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. East Flux for cell (ICu,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the East block boundary

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	// Calculate total flux through the cell face in the normal direction
	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICu,j,GaussQuadPoints[GQPoint]);

	  // Validate Wl state
	  Validate_Primitive_SolnState(Wl, ICu, j, "East", Pos);

	  // Determine right interface state at the Gauss calculation point
	  InviscidFluxStates_AtBoundaryInterface_HighOrder(EAST,
							   ICu,j,
							   Wl,Wr,
							   GaussQuadPoints[GQPoint],
							   Grid.nfaceE(ICu,j),
							   Pos);

	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							    Wl, Wr,
							    Grid.nfaceE(ICu,j));
	} //endfor (GQPoint)

	// Calculate final flux through the cell face
	Flux *= Grid.lfaceE(ICu,j);
	
	// Update East face boundary flux with the contribution of this cell face
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxE[j] += Flux;
	} else {
	  FluxE[j]  = Flux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICu][j][k_residual] -= ( (IP.CFL_Number * dt[ICu][j])* Flux/Grid.Cell[ICu][j].A );
	} else {
	  dUdt[ICu][j][k_residual] -= ( Flux/Grid.Cell[ICu][j].A );
	}

      } // endfor (j)
      
    } // endif (Grid.BndEastSplineInfo != NULL)
    
  } // endif (Grid.BndEastSpline.getFluxCalcMethod() == ReconstructionBasedFlux)


  // ****** Step 10. Compute inviscid fluxes through West block boundary ******
  // ***************************************************************************
  // == Check the flux calculation method ==
  if (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux){
    /* Calculate the flux using information directly from the reconstruction.
       The boundary conditions along this spline has been enforced to the reconstruction procedure.
       If the high-order reconstruction has been detected as non-smooth compute a Riemann flux
       with the value provided by the ghost cell reconstruction.
    */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndWestSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. West Flux for cell (ICl,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICl,j);

	// Reset face flux
	FaceFlux.Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // == Check if the solution reconstruction was detected as non-smooth.
	    if ( IsNonSmoothHighOrderReconstruction ){

	      // Compute left interface state at the current Gauss
	      // point location based on the low-order reconstruction.
	      Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Validate Wl state
	      Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);	      

	      // Determine right interface state at the Gauss calculation point
	      InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							       ICl,j,
							       Wl,Wr,
							       Grid.BndWestSplineInfo[j].GQPoint(Position),
							       Grid.BndWestSplineInfo[j].NormalGQPoint(Position),
							       Pos);

	      /* Add the weighted contribution of the current GQP to the total 
		 flux in the normal direction through the face. */
	      Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
								Wl, Wr,
								Grid.BndWestSplineInfo[j].NormalGQPoint(Position));

	    } else {

	      // Determine the solution state at the Gauss quadrature point for flux calculation 
	      // based on the constrained reconstruction.
	      W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,Grid.BndWestSplineInfo[j].GQPoint(Position));

	      // Validate W_face state
	      Validate_Primitive_SolnState(W_face, ICl, j, "West", Pos);
	      
	      /* Add the weighted contribution of the current GQP to the total 
		 flux through the spline segment in the local normal direction. */
	      Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.BndWestSplineInfo[j].NormalGQPoint(Position));
	    } // endif (IsNonSmoothHighOrderReconstruction)

	  } //endfor (GQPoint)
	
	  // Update FaceFlux with the contribution of this spline segment
	  FaceFlux += Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	// Update West face boundary flux with the contribution of the hyperbolic term
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxW[j] += FaceFlux;
	} else {
	  FluxW[j]  = FaceFlux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FaceFlux/Grid.Cell[ICl][j].A );
	} else {
	  dUdt[ICl][j][k_residual] -= ( FaceFlux/Grid.Cell[ICl][j].A );
	}

      } // endfor (j)

    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. West Flux for cell (ICl,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	// Determine if the solution reconstruction was detected as non-smooth for the current cell.
	IsNonSmoothHighOrderReconstruction = HighOrderVariable(Pos).IsThereAnyNonSmoothHighOrderReconstruction(ICl,j);

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	// == Check if the solution reconstruction was detected as non-smooth.
	if ( IsNonSmoothHighOrderReconstruction ){

	  // Calculate total flux through the cell face in the normal direction
	  for (GQPoint = 0; GQPoint < NumGQP; ++GQPoint) { // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the low-order reconstruction.
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);

	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);
	    
	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							     ICl,j,
							     Wl,Wr,
							     GaussQuadPoints[GQPoint],
							     Grid.nfaceW(ICl,j),
							     Pos);
	    
	    /* Add the weighted contribution of the current GQP to the total 
	       flux in the normal direction through the face. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.nfaceW(ICl,j));
	  } //endfor (GQPoint)
	    
	} else {

	  // Calculate total flux through the cell face in the normal direction
	  for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	    // Determine the solution state at the Gauss quadrature point for flux calculation 
	    // based on constrained reconstruction.
	    W_face = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);
	    
	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the face in the normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * Fn(W_face, Grid.nfaceW(ICl,j));
	  } //endfor (GQPoint)
	
	} // endif

	// Calculate final flux through the cell face
	Flux *= Grid.lfaceW(ICl,j);
	
	// Update West face boundary flux with the contribution of this cell face
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxW[j] += Flux;
	} else {
	  FluxW[j]  = Flux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* Flux/Grid.Cell[ICl][j].A );
	} else {
	  dUdt[ICl][j][k_residual] -= ( Flux/Grid.Cell[ICl][j].A );
	}

      } // endfor (j)

    } // endif (Grid.BndWestSplineInfo != NULL)


  } else {
    /* Calculate the flux by solving a Riemann problem and ensure 
       that boundary conditions for this boundary are correctly enforced. */

    // == Check for the representation of the geometric boundary (i.e. high-order or low-order)
    if ( Grid.BndWestSplineInfo != NULL){
      /* High-order boundary representation is required.
	 Use all geometric information from the correspondent BndSplineInfo */
      
      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. West Flux for cell (ICl,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	// Reset face flux
	FaceFlux.Vacuum();

	for (SplineSegment = 1, Position = 1; 
	     SplineSegment <= Grid.BndWestSplineInfo[j].NumOfSubIntervals();
	     ++SplineSegment){  // for each continuous spline subinterval

	  // Reset Flux
	  Flux.Vacuum();
	  
	  // Calculate total flux through the spline subinterval
	  for (GQPoint = 0;
	       GQPoint < Grid.BndWestSplineInfo[j].GQPointsPerSubInterval();
	       ++GQPoint, ++Position){  // for each Gauss Quadrature point

	    // Compute left interface state at the current Gauss
	    // point location based on the reconstruction
	    Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,
								Grid.BndWestSplineInfo[j].GQPoint(Position));

	    // Validate Wl state
	    Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);
	    
	    // Determine right interface state at the Gauss calculation point
	    InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							     ICl,j,
							     Wl,Wr,
							     Grid.BndWestSplineInfo[j].GQPoint(Position),
							     Grid.BndWestSplineInfo[j].NormalGQPoint(Position),
							     Pos);

	    /* Add the weighted contribution of the current GQP to the total 
	       flux through the spline segment in the local normal direction. */
	    Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							      Wl, Wr,
							      Grid.BndWestSplineInfo[j].NormalGQPoint(Position));
	  } //endfor (GQPoint)
	
	  // Update FaceFlux with the contribution of this spline segment
	  FaceFlux += Flux * Grid.BndWestSplineInfo[j].IntLength(SplineSegment);

	} // endfor (SplineSegment)

	// Update West face boundary flux with the contribution of the hyperbolic term
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxW[j] += FaceFlux;
	} else {
	  FluxW[j]  = FaceFlux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j]) * FaceFlux/Grid.Cell[ICl][j].A );
	} else {
	  dUdt[ICl][j][k_residual] -= ( FaceFlux/Grid.Cell[ICl][j].A );
	}

      } // endfor (j)
      
    } else {
      /* Low-order boundary representation is required.
	 Treat the cell faces as straight edges. */

      /* Evaluate the cell interface i-direction fluxes.
	 --> ( i.e. West Flux for cell (ICl,j) ) */
      for (j = JCl; j <= JCu; ++j){ // for each cell on the West block boundary

	// Determine the location of the Gauss Quadrature Points
	Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);

	// Reset Flux
	Flux.Vacuum();

	// Calculate total flux through the cell face in the normal direction
	for(GQPoint = 0; GQPoint < NumGQP; ++GQPoint){ // for each Gauss Quadrature point

	  // Compute left and right interface states at the current Gauss
	  // point location based on the high-order reconstruction
	  Wl = HighOrderVariable(Pos).SolutionStateAtLocation(ICl,j,GaussQuadPoints[GQPoint]);
	  
	  // Validate Wl state
	  Validate_Primitive_SolnState(Wl, ICl, j, "West", Pos);

	  // Determine right interface state at the Gauss calculation point
	  InviscidFluxStates_AtBoundaryInterface_HighOrder(WEST,
							   ICl,j,
							   Wl,Wr,
							   GaussQuadPoints[GQPoint],
							   Grid.nfaceW(ICl,j),
							   Pos);

	  /* Add the weighted contribution of the current GQP to the total 
	     flux through the face in the normal direction. */
	  Flux += GaussQuadWeights[GQPoint] * RiemannFlux_n(IP.i_Flux_Function,
							    Wl, Wr,
							    Grid.nfaceW(ICl,j));
	} //endfor (GQPoint)
	
	// Calculate final flux through the cell face
	Flux *= Grid.lfaceW(ICl,j);
	
	// Update West face boundary flux with the contribution of this cell face
	if (Flow_Type != FLOWTYPE_INVISCID){
	  FluxW[j] += Flux;
	} else {
	  FluxW[j]  = Flux;
	}

	/* Evaluate cell-averaged solution changes. */
	if (UseTimeStep){
	  dUdt[ICl][j][k_residual] -= ( (IP.CFL_Number * dt[ICl][j])* Flux/Grid.Cell[ICl][j].A );
	} else {
	  dUdt[ICl][j][k_residual] -= ( Flux/Grid.Cell[ICl][j].A );
	}

      } // endfor (j)
      
    } // endif (Grid.BndWestSplineInfo != NULL)
    
  } // endif (Grid.BndWestSpline.getFluxCalcMethod() == ReconstructionBasedFlux)

  // Deallocate memory
  delete [] GaussQuadPoints;
  delete [] GaussQuadWeights;

  /* residual for the stage successfully calculated. */
  return (0);

}

/*!
 * Evaluate the residual for the solution block 
 * using a high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 * The residual is stored in dUdt[][][0].               
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *                                                      
 */
int NavierStokes2D_Quad_Block::dUdt_Residual_Evaluation_HighOrder(const NavierStokes2D_Input_Parameters &IP,
								  const unsigned short int Pos){

  int i,j;
  
  // ************* Step 1. (Re)-Set residual for k_residual=0 to zero in all affected cells **************
  // *****************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ) {
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {
      dUdt[i][j][0].Vacuum();  // set to zero
    } // endfor (i)
  } // endfor (j)

  // ** Step 2. Compute high-order spatial residual and write it to k_residual = 0 **
  // ********************************************************************************
  return dUdt_Residual_HighOrder(IP, 0, false, Pos);
}


/*!
 * This routine determines the solution residuals for a 
 * given stage of a variety of multi-stage explicit     
 * time integration schemes for the solution block.
 * The solution residuals are evaluated  
 * using a high-order CENO upwind finite-volume 
 * spatial discretization scheme.
 *
 * \param Pos index to identify the high-order variable used to calculate the residual
 *
 */
int NavierStokes2D_Quad_Block::dUdt_Multistage_Explicit_HighOrder(const int &i_stage,
								  const NavierStokes2D_Input_Parameters &IP,
								  const unsigned short int Pos) {
  // SET VARIABLES USED IN THE RESIDUAL CALCULATION PROCESS

  int i, j, k_residual;

  /* Evaluate the solution residual for stage 
     i_stage of an N stage scheme. */

  /* Evaluate the time step fraction and residual storage location for the stage. */
  
  switch(IP.i_Time_Integration) {
  case TIME_STEPPING_EXPLICIT_EULER :
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
    k_residual = 0;
    break;
  case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
    k_residual = 0;
    if (IP.N_Stage == 4) {
      if (i_stage == 4) {
	k_residual = 0;
      } else {
	k_residual = i_stage - 1;
      } /* endif */
    } /* endif */
    break;
  case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
    k_residual = 0;
    break;
  default:
    k_residual = 0;
  } /* endswitch */


  // ************* Step 1. (Re)-Set parameters in all affected cells based on the time integration scheme **************
  // *******************************************************************************************************************
  for ( j = JCl-1 ; j <= JCu+1 ; ++j ){
    for ( i = ICl-1 ; i <= ICu+1 ; ++i ) {

      if ( i_stage == 1 ){
	Uo[i][j] = U[i][j];
	dUdt[i][j][k_residual].Vacuum();  // set to zero
      } else {
	switch(IP.i_Time_Integration) {
	case TIME_STEPPING_EXPLICIT_PREDICTOR_CORRECTOR :
	  // 
	  break;
	case TIME_STEPPING_EXPLICIT_RUNGE_KUTTA :
	  if (IP.N_Stage == 2) {
	    // 
	  } else if (IP.N_Stage == 4 && i_stage == 4) {
	    dUdt[i][j][k_residual] = ( dUdt[i][j][0] + 
				       TWO*dUdt[i][j][1] +
				       TWO*dUdt[i][j][2] );
	  } else {
	    dUdt[i][j][k_residual].Vacuum();  // set to zero
	  } /* endif */
	  break;
	case TIME_STEPPING_MULTISTAGE_OPTIMAL_SMOOTHING :
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	default:
	  dUdt[i][j][k_residual].Vacuum(); // set to zero
	  break;
	} /* endswitch */
      }/* endif */

    } // endfor (i)
  } // endfor (j)


  // ** Step 2. Compute high-order spatial residual for the current time step fraction **
  // ************************************************************************************
  return dUdt_Residual_HighOrder(IP, k_residual, true, Pos);
}

/*!
 * Compute the solution state for evaluating the inviscid flux 
 * at a boundary interface such that to satisfy the 
 * required boundary conditions.
 * This routine works in conjunction with the high-order
 * implementation.
 * 
 * \param  BOUNDARY boundary position specifier (i.e. WEST, EAST, SOUTH or NORTH)
 * \param  ii       i-index of the cell in which the calculation is done
 * \param  jj       j-index of the cell in which the calculation is done
 * \param  Wl       the left interface state 
 * \param  Wr       the right interface state 
 * \param CalculationPoint the flux calculation point
 * \param NormalDirection the normal direction at the calculation point
 *
 * \return The solution state which is required to calculate the inviscid flux with 
 *         such that to satisfy the boundary condition.
 *
 * \todo Change the reference values to the high-order ones for some BCs!
 */
void NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder(const int &BOUNDARY,
										 const int &ii, const int &jj,
										 NavierStokes2D_pState &Wl,
										 NavierStokes2D_pState &Wr,
										 const Vector2D &CalculationPoint,
										 const Vector2D &NormalDirection,
										 const unsigned short int Pos) const {

  double rho_over_p;
  int BC_Type;
  string ErrorMsg;
  NavierStokes2D_pState *RefState;
  int iGhost, jGhost;

  switch (BOUNDARY){
    
    // *******************************
    // === WEST boundary interface ===
    // *******************************
  case WEST :			
    BC_Type = Grid.BCtypeW[jj];
    ErrorMsg = "NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such West BCtype!";
    RefState = &WoW[jj];     // Note: The reference value should be changed to HO_WoW!
    iGhost = ii-1;
    jGhost = jj;
    break;

    // *******************************
    // === EAST boundary interface ===
    // *******************************
  case EAST :			
    BC_Type = Grid.BCtypeE[jj];
    ErrorMsg = "NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such East BCtype!";
    RefState = &WoE[jj];    // Note: The reference value should be changed to HO_WoE!
    iGhost = ii+1;
    jGhost = jj;
    break;

    // *******************************
    // === NORTH boundary interface ==
    // *******************************
  case NORTH :	
    BC_Type = Grid.BCtypeN[ii];
    ErrorMsg = "NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such North BCtype!";
    RefState = &WoN[ii];    // Note: The reference value should be changed to HO_WoN!
    iGhost = ii;
    jGhost = jj+1;
    break;

    // *******************************
    // === SOUTH boundary interface ==
    // *******************************
  case SOUTH :			
    BC_Type = Grid.BCtypeS[ii];
    ErrorMsg = "NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such South BCtype!";
    RefState = &WoS[ii];    // Note: The reference value should be changed to HO_WoS!
    iGhost = ii;
    jGhost = jj-1;
    break;
  }

  // Compute right interface state based on reconstruction or the particular boundary condition
  switch(BC_Type){
  
  case BC_NONE :
    // Compute Wr based on the high-order reconstruction in the ghost cell
    Wr = HighOrderVariable(Pos).SolutionStateAtLocation(iGhost,jGhost,CalculationPoint);
    break;

  case BC_PERIODIC :
    // Compute Wr based on the high-order reconstruction in the ghost cell
    Wr = HighOrderVariable(Pos).SolutionStateAtLocation(iGhost,jGhost,CalculationPoint);
    break;

  case BC_FROZEN :
    // Calculate Wr based on the reconstruction in the ghost cell
    Wr = HighOrderVariable(Pos).SolutionStateAtLocation(iGhost,jGhost,CalculationPoint);
    break;

  case BC_FARFIELD :
    // Setup value as in the case of Dirichlet BC
      
  case BC_DIRICHLET :		// BC_FIXED
    // Set Wr to the reference value for the given location
    Wr = *RefState;
    break;
      
  case BC_EXACT_SOLUTION :
    // Calculate W_face based on the exact solution
    if (ExactSoln->IsExactSolutionSet()){
      Wr = BC_Characteristic_Pressure(Wl,
				      ExactSoln->Solution(CalculationPoint.x,CalculationPoint.y),
				      NormalDirection);
    } else {
      throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
    }
    break;
      
  case BC_NEUMANN :
    throw runtime_error("NavierStokes2D_Quad_Block::InviscidFluxStates_AtBoundaryInterface_HighOrder() ERROR! BC_NEUMANN not implemented yet.");
    break;

  case BC_SYMMETRY_PLANE : 	// same as BC_REFLECTION
    Wr = Reflect(Wl, NormalDirection);
    break;

  case BC_WALL_INVISCID : 	// same as BC_REFLECTION
    Wr = Reflect(Wl, NormalDirection);
    break;

  case BC_EXTRAPOLATE :
    // Set Wr equal to the left side value (i.e Wl)
    Wr = Wl;
    break;

  case BC_LINEAR_EXTRAPOLATION :
    // Calculate Wr based on the reconstruction in the ghost cell
    Wr = HighOrderVariable(Pos).SolutionStateAtLocation(iGhost,jGhost,CalculationPoint);
    break;

  case BC_OUTFLOW_SUBSONIC:
  case BC_OUTFLOW :
    // Set Wr equal to the left side value (i.e Wl)
    Wr = Wl;
    break;

  case BC_CONSTANT_EXTRAPOLATION :
    // Set Wr equal to the left side value (i.e Wl)
    Wr = Wl;
    break;

  case BC_INFLOW_SUBSONIC:
    Wr = *RefState;
    Wr.v.y = ZERO;
    break;

  case BC_CHARACTERISTIC :
    // Set Wr based on the directions of propogation for the solution characteristics at the boundary
    // Note: The reference value should be changed to HO_WoW!
    Wr = BC_Characteristic_Pressure(Wl,
				    *RefState,
				    NormalDirection);
    break;

  case BC_WALL_VISCOUS_HEATFLUX:
    // Set Wr to resemble a viscous wall with no heatflux
    Wr = WallViscousHeatFlux(Wl,
			     NormalDirection);
    break;

  case BC_WALL_VISCOUS_ISOTHERMAL:
    // Set Wr for a viscous isothermal wall
    Wr = WallViscousIsothermal(Wl,
			       NormalDirection,
			       Twall);
    break;

  case BC_MOVING_WALL_HEATFLUX :
    // Set Wr for a moving viscous wall with no heatflux
    Wr = MovingWallHeatFlux(Wl,
			    NormalDirection,
			    Vwall.x);
    break;

  case BC_MOVING_WALL_ISOTHERMAL :
    // Set Wr for a moving viscous and isothermal wall
    Wr = MovingWallIsothermal(Wl,
			      NormalDirection,
			      Vwall.x, 
			      Twall);
    break;

  case BC_FIXED_PRESSURE :
    // Constant extrapolation with fixed pressure.
    // Use the interior reconstruction to set the right state and the reference state for the pressure.    
    Wr = Wl;
    Wr.p = RefState->p;
    break;

  default:
    throw runtime_error(ErrorMsg);    
  }

}

/*!
 * Set high-order boundary conditions.
 */
void NavierStokes2D_Quad_Block::BCs_HighOrder(void){

  int i, j, Vertex;
  double Vn;
  Vector2D PointOfInterest, Normal;
  int NumGQP(Grid.getNumGQP());
  Vector2D *GaussQuadPoints = new Vector2D [NumGQP]; // the GQPs for flux calculation points if low-order geometry is used

  // == If no high-order BCs are present just return
  if ( BC_WestCell() == NULL && BC_EastCell() == NULL && 
       BC_SouthCell() == NULL && BC_NorthCell() == NULL ){
    return;
  }


  // == Set high-order boundary conditions
  for ( j = 0 ; j < NCj ; ++j ) {

    // Prescribe West boundary conditions.
    if (BC_WestCell() != NULL){
      for (Vertex = 1; Vertex <= BC_WestCell(j).NumOfPoints(); ++Vertex){

	switch(Grid.BCtypeW[j]) {	
	case BC_FROZEN :
	  throw runtime_error("BCs_HighOrder() ERROR! Frozen BC hasn't been implemented yet!");
	  break;
	case BC_NONE :
	  // Do nothing
	  break;

	case BC_PERIODIC :
	  throw runtime_error("BCs_HighOrder() ERROR! Periodic BC hasn't been implemented yet!");
	  break;

	case BC_INFLOW :
	  throw runtime_error("BCs_HighOrder() ERROR! Inflow BC hasn't been implemented yet!");
	  break;

	case BC_FARFIELD :
	  // Setup the data as in the case of Dirichlet BC.

	case BC_DIRICHLET :	// Use WoW as reference value
	  // Dirichlet constraint
	  BC_WestCell(j).DirichletBC(Vertex) = WoW[j];
	  BC_WestCell(j).a(Vertex) = Soln_State(1.0);
	  BC_WestCell(j).NeumannBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_WestCell(j).b(Vertex) = Soln_State(0.0);
	  break;

	case BC_NEUMANN :
	  // Neumann constraint
	  BC_WestCell(j).DirichletBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_WestCell(j).a(Vertex) = Soln_State(0.0);
	  BC_WestCell(j).NeumannBC(Vertex) =  WoW[j];
	  BC_WestCell(j).b(Vertex) = Soln_State(1.0);
	  break;

	case BC_SYMMETRY_PLANE :
	  // Do nothing
	  break;

	case BC_EXTRAPOLATE :
	case BC_LINEAR_EXTRAPOLATION :
	  throw runtime_error("BCs_HighOrder() ERROR! Linear extrapolation BC hasn't been implemented yet!");
	  break;

	case BC_OUTFLOW :
	  // Impose zero derivative in the normal direction at the boundary
	  // Neumann constraint
	  BC_WestCell(j).DirichletBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_WestCell(j).a(Vertex) = Soln_State(0.0);
	  BC_WestCell(j).NeumannBC(Vertex) =  Soln_State(0.0);
	  BC_WestCell(j).b(Vertex) = Soln_State(1.0);
	  break;

	case BC_CONSTANT_EXTRAPOLATION :
	  throw runtime_error("BCs_HighOrder() ERROR! Constant extrapolation BC hasn't been implemented yet!");
	  break;

	case BC_EXACT_SOLUTION :
	  // Use the exact solution to set up the reference states for this boundary type
	  if (ExactSoln->IsExactSolutionSet()){
	    // Determine the PointOfInterest if high-order boundaries are used
	    if ( j<JCl && Grid.ExtendSouth_BndWestSplineInfo != NULL){
	      PointOfInterest = Grid.ExtendSouth_BndWestSplineInfo[j].GQPoint(Vertex);
	    } else if ( j>=JCl && j<=JCu && Grid.BndWestSplineInfo != NULL){
	      PointOfInterest = Grid.BndWestSplineInfo[j].GQPoint(Vertex);
	    } else if ( j>JCu && Grid.ExtendNorth_BndWestSplineInfo != NULL){
	      PointOfInterest = Grid.ExtendNorth_BndWestSplineInfo[j-(JCu+1)].GQPoint(Vertex);
	    } else {
	      // Determine the PointOfInterest if low-order boundaries are used
	      Grid.getGaussQuadPointsFaceW(ICl,j,GaussQuadPoints,NumGQP);
	      PointOfInterest = GaussQuadPoints[Vertex-1];
	    }
	    // Set the boundary conditions at the current location
	    BC_WestCell(j).DirichletBC(Vertex) = ExactSoln->Solution(PointOfInterest.x,PointOfInterest.y);
	    BC_WestCell(j).a(Vertex) = Soln_State(1.0);
	    BC_WestCell(j).NeumannBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	    BC_WestCell(j).b(Vertex) = Soln_State(0.0);      
	  } else {
	    throw runtime_error("BCs_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
	  }
	  break;

	case BC_WALL_INVISCID:
	  // Do nothing
	  break;

	default:		
	  throw runtime_error("BCs_HighOrder() ERROR! Default BC hasn't been implemented yet!");
	  break;
	} /* endswitch */
      } /* endfor (Vertex) */
    } // endif

    // Prescribe East boundary conditions.
    if (BC_EastCell() != NULL){
      for (Vertex = 1; Vertex <= BC_EastCell(j).NumOfPoints(); ++Vertex){
      
	switch(Grid.BCtypeE[j]) {
	case BC_FROZEN :
	  throw runtime_error("BCs_HighOrder() ERROR! Frozen BC hasn't been implemented yet!");
	case BC_NONE :
	  // Do nothing
	  break;
	  
	case BC_PERIODIC :
	  throw runtime_error("BCs_HighOrder() ERROR! Periodic BC hasn't been implemented yet!");
	  break;
	  
	case BC_INFLOW :
	  throw runtime_error("BCs_HighOrder() ERROR! Inflow BC hasn't been implemented yet!");
	  break;
	
	case BC_FARFIELD :
	  // Setup the data as in the case of Dirichlet BC.

	case BC_DIRICHLET :	// Use WoE as reference value
	  // Dirichlet constraint
	  BC_EastCell(j).DirichletBC(Vertex) = WoE[j];
	  BC_EastCell(j).a(Vertex) = Soln_State(1.0);
	  BC_EastCell(j).NeumannBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_EastCell(j).b(Vertex) = Soln_State(0.0);
	  break;
	  
	case BC_NEUMANN :
	  // Neumann constraint
	  BC_EastCell(j).DirichletBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_EastCell(j).a(Vertex) = Soln_State(0.0);
	  BC_EastCell(j).NeumannBC(Vertex) =  WoE[j];
	  BC_EastCell(j).b(Vertex) = Soln_State(1.0);
	  break;

	case BC_SYMMETRY_PLANE :
	  // Do nothing
	  break;

	case BC_EXTRAPOLATE :
	case BC_LINEAR_EXTRAPOLATION :
	  throw runtime_error("BCs_HighOrder() ERROR! Linear extrapolation BC hasn't been implemented yet!");
	  break;

	case BC_OUTFLOW :
	  // Impose zero derivative in the normal direction at the boundary
	  // Neumann constraint
	  BC_EastCell(j).DirichletBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_EastCell(j).a(Vertex) = Soln_State(0.0);
	  BC_EastCell(j).NeumannBC(Vertex) =  Soln_State(0.0);
	  BC_EastCell(j).b(Vertex) = Soln_State(1.0);
	  break;

	case BC_CONSTANT_EXTRAPOLATION :
	  throw runtime_error("BCs_HighOrder() ERROR! Constant extrapolation BC hasn't been implemented yet!");
	  break;

	case BC_EXACT_SOLUTION :
	  // Use the exact solution to set up the reference states for this boundary type
	  if (ExactSoln->IsExactSolutionSet()){
	    // Determine the PointOfInterest if high-order boundaries are used
	    if ( j<JCl && Grid.ExtendSouth_BndEastSplineInfo != NULL){
	      PointOfInterest = Grid.ExtendSouth_BndEastSplineInfo[j].GQPoint(Vertex);
	    } else if ( j>=JCl && j<=JCu && Grid.BndEastSplineInfo != NULL){
	      PointOfInterest = Grid.BndEastSplineInfo[j].GQPoint(Vertex);
	    } else if ( j>JCu && Grid.ExtendNorth_BndEastSplineInfo != NULL){
	      PointOfInterest = Grid.ExtendNorth_BndEastSplineInfo[j-(JCu+1)].GQPoint(Vertex);
	    } else {
	      // Determine the PointOfInterest if low-order boundaries are used
	      Grid.getGaussQuadPointsFaceE(ICu,j,GaussQuadPoints,NumGQP);
	      PointOfInterest = GaussQuadPoints[Vertex-1];
	    }
	    // Set the boundary conditions at the current location
	    BC_EastCell(j).DirichletBC(Vertex) = ExactSoln->Solution(PointOfInterest.x,PointOfInterest.y);
	    BC_EastCell(j).a(Vertex) = Soln_State(1.0);
	    BC_EastCell(j).NeumannBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	    BC_EastCell(j).b(Vertex) = Soln_State(0.0);      
	  } else {
	    throw runtime_error("BCs_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
	  }
	  break;

	case BC_WALL_INVISCID:
	  // Do nothing
	  break;

	default:	
	  throw runtime_error("BCs_HighOrder() ERROR! Default BC hasn't been implemented yet!");	
	  break;
	} /* endswitch */
      } /* endfor (Vertex) */	
    } // endif

  } /* endfor (j) */


  for ( i = 0 ; i < NCi ; ++i ) {

    // Prescribe South boundary conditions.
    if (BC_SouthCell() != NULL){
      for (Vertex = 1; Vertex <= BC_SouthCell(i).NumOfPoints(); ++Vertex){

	switch(Grid.BCtypeS[i]) {
	case BC_FROZEN :
	  throw runtime_error("BCs_HighOrder() ERROR! Frozen BC hasn't been implemented yet!");
	  break;
	case BC_NONE :
	  // Do nothing
	  break;
      
	case BC_PERIODIC :
	  throw runtime_error("BCs_HighOrder() ERROR! Periodic BC hasn't been implemented yet!");
	  break;
      
	case BC_INFLOW :
	  throw runtime_error("BCs_HighOrder() ERROR! Inflow BC hasn't been implemented yet!");
	  break;

	case BC_FARFIELD :
	  // Setup the data as in the case of Dirichlet BC.

	case BC_DIRICHLET :	// Use WoS as reference value
	  // Dirichlet constraint
	  BC_SouthCell(i).DirichletBC(Vertex) = WoS[i];
	  BC_SouthCell(i).a(Vertex) = Soln_State(1.0);
	  BC_SouthCell(i).NeumannBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_SouthCell(i).b(Vertex) = Soln_State(0.0);
	  break;
      
	case BC_NEUMANN :
	  // Neumann constraint
	  BC_SouthCell(i).DirichletBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_SouthCell(i).a(Vertex) = Soln_State(0.0);
	  BC_SouthCell(i).NeumannBC(Vertex) =  WoS[i];
	  BC_SouthCell(i).b(Vertex) = Soln_State(1.0);
	  break;

	case BC_SYMMETRY_PLANE :
	  // Do nothing
	  break;
      
	case BC_EXTRAPOLATE :
	case BC_LINEAR_EXTRAPOLATION :
	  throw runtime_error("BCs_HighOrder() ERROR! Linear extrapolation BC hasn't been implemented yet!");
	  break;
      
	case BC_OUTFLOW :
	  // Impose zero derivative in the normal direction at the boundary
	  // Neumann constraint
	  BC_SouthCell(i).DirichletBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_SouthCell(i).a(Vertex) = Soln_State(0.0);
	  BC_SouthCell(i).NeumannBC(Vertex) =  Soln_State(0.0);
	  BC_SouthCell(i).b(Vertex) = Soln_State(1.0);
	  break;

	case BC_CONSTANT_EXTRAPOLATION :
	  throw runtime_error("BCs_HighOrder() ERROR! Constant extrapolation BC hasn't been implemented yet!");
	  break;
	
	case BC_EXACT_SOLUTION :
	  // Use the exact solution to set up the reference states for this boundary type
	  if (ExactSoln->IsExactSolutionSet()){
	    // Determine the PointOfInterest if high-order boundaries are used
	    if ( i<ICl && Grid.ExtendWest_BndSouthSplineInfo != NULL){
	      PointOfInterest = Grid.ExtendWest_BndSouthSplineInfo[i].GQPoint(Vertex);
	    } else if ( i>=ICl && i<=ICu && Grid.BndSouthSplineInfo != NULL){
	      PointOfInterest = Grid.BndSouthSplineInfo[i].GQPoint(Vertex);
	    } else if ( i>ICu && Grid.ExtendEast_BndSouthSplineInfo != NULL){
	      PointOfInterest = Grid.ExtendEast_BndSouthSplineInfo[i-(ICu+1)].GQPoint(Vertex);
	    } else {
	      // Determine the PointOfInterest if low-order boundaries are used
	      Grid.getGaussQuadPointsFaceS(i,JCl,GaussQuadPoints,NumGQP);
	      PointOfInterest = GaussQuadPoints[Vertex-1];
	    }
	    // Set the boundary conditions at the current location
	    BC_SouthCell(i).DirichletBC(Vertex) = ExactSoln->Solution(PointOfInterest.x,PointOfInterest.y);
	    BC_SouthCell(i).a(Vertex) = Soln_State(1.0);
	    BC_SouthCell(i).NeumannBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	    BC_SouthCell(i).b(Vertex) = Soln_State(0.0);      
	  } else {
	    throw runtime_error("BCs_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
	  }
	  break;

	case BC_WALL_INVISCID:
	  // Do nothing
	  break;
	
	default:	
	  throw runtime_error("BCs_HighOrder() ERROR! Default BC hasn't been implemented yet!");		
	  break;
	} /* endswitch */
      } /* endfor (Vertex) */
    } // endif    

    // Prescribe North boundary conditions.
    if (BC_NorthCell() != NULL){
      for (Vertex = 1; Vertex <= BC_NorthCell(i).NumOfPoints(); ++Vertex){

	switch(Grid.BCtypeN[i]) {
	case BC_FROZEN :
	  throw runtime_error("BCs_HighOrder() ERROR! Frozen BC hasn't been implemented yet!");
	  break;
	
	case BC_NONE :
	  // Do nothing
	  break;
      
	case BC_PERIODIC :
	  throw runtime_error("BCs_HighOrder() ERROR! Periodic BC hasn't been implemented yet!");
	  break;
      
	case BC_INFLOW :
	  throw runtime_error("BCs_HighOrder() ERROR! Inflow BC hasn't been implemented yet!");
	  break;

	case BC_FARFIELD :
	  // Setup the data as in the case of Dirichlet BC.

	case BC_DIRICHLET :	// Use WoN as reference value
	  // Dirichlet constraint
	  BC_NorthCell(i).DirichletBC(Vertex) = WoN[i];
	  BC_NorthCell(i).a(Vertex) = Soln_State(1.0);
	  BC_NorthCell(i).NeumannBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_NorthCell(i).b(Vertex) = Soln_State(0.0);
	  break;
      
	case BC_NEUMANN :
	  // Neumann constraint
	  BC_NorthCell(i).DirichletBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_NorthCell(i).a(Vertex) = Soln_State(0.0);
	  BC_NorthCell(i).NeumannBC(Vertex) =  WoN[i];
	  BC_NorthCell(i).b(Vertex) = Soln_State(1.0);
	  break;
      
	case BC_SYMMETRY_PLANE :
	  // Do nothing
	  break;
      
	case BC_EXTRAPOLATE :
	case BC_LINEAR_EXTRAPOLATION :
	  throw runtime_error("BCs_HighOrder() ERROR! Linear extrapolation BC hasn't been implemented yet!");
	  break;
      
	case BC_OUTFLOW :
	  // Impose zero derivative in the normal direction at the boundary
	  // Neumann constraint
	  BC_NorthCell(i).DirichletBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	  BC_NorthCell(i).a(Vertex) = Soln_State(0.0);
	  BC_NorthCell(i).NeumannBC(Vertex) =  Soln_State(0.0);
	  BC_NorthCell(i).b(Vertex) = Soln_State(1.0);
	  break;

	case BC_CONSTANT_EXTRAPOLATION :
	  throw runtime_error("BCs_HighOrder() ERROR! Constant extrapolation BC hasn't been implemented yet!");
	  break;

	case BC_EXACT_SOLUTION :
	  // Use the exact solution to set up the reference states for this boundary type
	  if (ExactSoln->IsExactSolutionSet()){
	    // Determine the PointOfInterest if high-order boundaries are used
	    if ( i<ICl && Grid.ExtendWest_BndNorthSplineInfo != NULL){
	      PointOfInterest = Grid.ExtendWest_BndNorthSplineInfo[i].GQPoint(Vertex);
	    } else if ( i>=ICl && i<=ICu && Grid.BndNorthSplineInfo != NULL){
	      PointOfInterest = Grid.BndNorthSplineInfo[i].GQPoint(Vertex);
	    } else if ( i>ICu && Grid.ExtendEast_BndNorthSplineInfo != NULL){
	      PointOfInterest = Grid.ExtendEast_BndNorthSplineInfo[i-(ICu+1)].GQPoint(Vertex);
	    } else {
	      // Determine the PointOfInterest if low-order boundaries are used
	      Grid.getGaussQuadPointsFaceN(i,JCu,GaussQuadPoints,NumGQP);
	      PointOfInterest = GaussQuadPoints[Vertex-1];
	    }
	    // Set the boundary conditions at the current location
	    BC_NorthCell(i).DirichletBC(Vertex) = ExactSoln->Solution(PointOfInterest.x,PointOfInterest.y);
	    BC_NorthCell(i).a(Vertex) = Soln_State(1.0);
	    BC_NorthCell(i).NeumannBC(Vertex) = Soln_State(0.0); // this value doesn't matter
	    BC_NorthCell(i).b(Vertex) = Soln_State(0.0);
	  } else {
	    throw runtime_error("BCs_HighOrder() ERROR! There is no exact solution set for the Exact_Solution BC.");
	  }
	  break;

	case BC_WALL_INVISCID:
	  // Do nothing
	  break;

	default:	
	  throw runtime_error("BCs_HighOrder() ERROR! Default BC hasn't been implemented yet!");			
	  break;
	} /* endswitch */
      } /* endfor (Vertex) */
    } // endif    

  } /* endfor */

  delete [] GaussQuadPoints;

}

/*!
 * Calculate refinement criteria for AMR
 * based on the CENO smoothness indicator.
 */
void NavierStokes2D_Quad_Block::Calculate_Refinement_Criteria_HighOrder(double *refinement_criteria,
									NavierStokes2D_Input_Parameters &IP,
									int &number_refinement_criteria){
  
  number_refinement_criteria = 1;

  /* Allocate memory for the refinement criteria */
  Refinement_Criteria().reserve(number_refinement_criteria);
  
  /* Return the refinement criteria. */
  refinement_criteria[0] = HighOrderVariable(0).AMR_Criteria_Based_On_Minimum_Smoothness_Indicator(*this);

  /* Store the refinement_criteria values in the solution block designated variable */
  Refinement_Criterion(0) = refinement_criteria[0];

}

/*!
 * Set physical boundary condition constraints based on
 * the current flow state and the BC_Type.
 */
void NavierStokes2D_Quad_Block::EnsurePhysicalBCsConstraints(const int & BOUNDARY, const int & BndCellIndex){
  // Nothing
}

/*!
 * Compute the solution state and the gradients for evaluating 
 * the viscous flux at a boundary interface such that to satisfy the 
 * required boundary conditions.
 * This routine works in conjunction with the high-order
 * implementation.
 * 
 * \param  BOUNDARY boundary position specifier (i.e. WEST, EAST, SOUTH or NORTH)
 * \param  ii       i-index of the cell in which the calculation is done
 * \param  jj       j-index of the cell in which the calculation is done
 * \param  Wl       the left interface state 
 * \param  Wr       the right interface state 
 * \param  W_face   the final interface state 
 * \param  dWdxL    the reconstructed left interface x-direction solution gradient
 * \param  dWdyL    the reconstructed left interface y-direction solution gradient
 * \param  dWdxR    the reconstructed right interface x-direction solution gradient
 * \param  dWdyR    the reconstructed right interface y-direction solution gradient
 * \param  dWdx_face   the final interface x-direction solution gradient
 * \param  dWdy_face   the final interface y-direction solution gradient
 * \param CalculationPoint the flux calculation point
 * \param NormalDirection the normal direction at the calculation point
 *
 * \return The solution and gradient state required to calculate the viscous flux with 
 *         such that to satisfy the imposed boundary condition.
 *
 * \todo Change the reference values to the high-order ones for some BCs!
 */
void NavierStokes2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder(const int &BOUNDARY,
										const int &ii, const int &jj,
										const NavierStokes2D_pState &Wl,
										const NavierStokes2D_pState &Wr,
										NavierStokes2D_pState &W_face,
										const NavierStokes2D_pState &dWdxL,
										const NavierStokes2D_pState &dWdyL,
										const NavierStokes2D_pState &dWdxR,
										const NavierStokes2D_pState &dWdyR,
										NavierStokes2D_pState &dWdx_face,
										NavierStokes2D_pState &dWdy_face,
										const Vector2D &CalculationPoint,
										const Vector2D &NormalDirection){

  double rho_over_p;
  int BC_Type;
  string ErrorMsg;
  NavierStokes2D_pState *RefState;

  switch (BOUNDARY){
    
    // *******************************
    // === WEST boundary interface ===
    // *******************************
  case WEST :			
    BC_Type = Grid.BCtypeW[jj];
    ErrorMsg = "NavierStokes2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such West BCtype!";
    RefState = &WoW[jj];
    break;

    // *******************************
    // === EAST boundary interface ===
    // *******************************
  case EAST :			
    BC_Type = Grid.BCtypeE[jj];
    ErrorMsg = "NavierStokes2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such East BCtype!";
    RefState = &WoE[jj];
    break;

    // *******************************
    // === NORTH boundary interface ==
    // *******************************
  case NORTH :	
    BC_Type = Grid.BCtypeN[ii];
    ErrorMsg = "NavierStokes2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such North BCtype!";
    RefState = &WoN[ii];
    break;

    // *******************************
    // === SOUTH boundary interface ==
    // *******************************
  case SOUTH :			
    BC_Type = Grid.BCtypeS[ii];
    ErrorMsg = "NavierStokes2D_Quad_Block::ViscousFluxStates_AtBoundaryInterface_HighOrder() ERROR! No such South BCtype!";
    RefState = &WoS[ii];
    break;
  }

  // Compute the face state and gradients based on the particular boundary condition
  switch(BC_Type){

  case BC_NONE:
    // Average the left and right states to determine the face state
    W_face = 0.5*(Wl + Wr);

    // Average the right and left gradients to determine the interface gradient
    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);
    break;

  case BC_WALL_VISCOUS_HEATFLUX:
    W_face = 0.5*(Wl + Wr);
    if (W_face.Unphysical_Properties()){
      W_face = CellSolution(ii,jj);
    }

    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);

    // Impose viscous wall
    W_face.v = Vector2D_ZERO;
    W_face.k = ZERO;
    W_face.ke = ZERO;

    // Impose no heat flux (i.e. adiabatic wall) by setting a ZERO temperature gradient
    rho_over_p = W_face.rho/W_face.p;
    dWdx_face.rho = rho_over_p * dWdx_face.p;
    dWdy_face.rho = rho_over_p * dWdy_face.p;
    break;

  case BC_WALL_VISCOUS_ISOTHERMAL:
    W_face = 0.5*(Wl + Wr);
    if (W_face.Unphysical_Properties()){
      W_face = CellSolution(ii,jj);
    }

    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);

    // Impose viscous wall
    W_face.v = Vector2D_ZERO;
    W_face.k = ZERO;
    W_face.ke = ZERO;

    // Impose isothermal wall (i.e. apply the specified wall temperature by modifying density)
    W_face.rho = W_face.p/(W_face.R * Twall);
    break;

  case BC_MOVING_WALL_HEATFLUX :
    W_face = 0.5*(Wl + Wr);
    if (W_face.Unphysical_Properties()){
      W_face = CellSolution(ii,jj);
    }

    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);

    // Impose impermeable moving wall
    W_face.v.x = - Vwall.x * NormalDirection.y;
    W_face.v.y =   Vwall.x * NormalDirection.x;
    W_face.k = ZERO;
    W_face.ke = ZERO;

    // Impose no heat flux (i.e. adiabatic wall) by setting a ZERO temperature gradient
    rho_over_p = W_face.rho/W_face.p;
    dWdx_face.rho = rho_over_p * dWdx_face.p;
    dWdy_face.rho = rho_over_p * dWdy_face.p;
    break;

  case BC_MOVING_WALL_ISOTHERMAL :
    W_face = 0.5*(Wl + Wr);
    if (W_face.Unphysical_Properties()){
      W_face = CellSolution(ii,jj);
    }

    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);

    // Impose impermeable moving wall
    W_face.v.x = - Vwall.x * NormalDirection.y;
    W_face.v.y =   Vwall.x * NormalDirection.x;
    W_face.k = ZERO;
    W_face.ke = ZERO;

    // Impose isothermal wall (i.e. apply the specified wall temperature by modifying density)
    W_face.rho = W_face.p/(W_face.R * Twall);
    break;

  case BC_FIXED:
    // Use the reference state for the face state
    W_face = *RefState;

    // Average the right and left gradients to determine the interface gradient
    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);    
    break;

  case BC_FIXED_PRESSURE:
    // Constant extrapolation with fixed pressure.
    // Use the interior reconstruction to set the state values and the reference state for the face pressure.
    W_face = Wl;
    W_face.p = RefState->p;
    
    // Average the right and left gradients to determine the interface gradient
    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);    
    break;

  case BC_CONSTANT_EXTRAPOLATION:
    // Use the interior reconstruction to set the state value
    W_face = Wl;

    // Average the right and left gradients to determine the interface gradient
    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);
    break;

  case BC_REFLECTION:
    // Average the left and right states to determine the face state
    W_face = 0.5*(Wl + Wr);

    // Average the right and left gradients to determine the interface gradient
    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);
    break;

  case BC_INFLOW_SUBSONIC:
    // Average the left and right states to determine the face state
    W_face = 0.5*(Wl + Wr);

    // Average the right and left gradients to determine the interface gradient
    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);    
    break;

  case BC_OUTFLOW_SUBSONIC:
    // Average the left and right states to determine the face state
    W_face = 0.5*(Wl + Wr);

    // Average the right and left gradients to determine the interface gradient
    dWdx_face = 0.5*(dWdxL + dWdxR);
    dWdy_face = 0.5*(dWdyL + dWdyR);
    break;

  default:
    throw runtime_error(ErrorMsg);

  }

}
